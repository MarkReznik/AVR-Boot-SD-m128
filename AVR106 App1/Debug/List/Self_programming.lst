
AVRASM ver. 2.1.30  F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm Wed Aug 07 22:53:25 2024

F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1100): warning: Register r4 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1101): warning: Register r5 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1102): warning: Register r6 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1103): warning: Register r7 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1104): warning: Register r8 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1105): warning: Register r9 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1106): warning: Register r10 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1107): warning: Register r11 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1108): warning: Register r13 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1109): warning: Register r12 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Debug
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 10.000000 MHz
                 ;Memory model           : Medium
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 2080 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_MEDIUM_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x10FF
                 	.EQU __DSTACK_SIZE=0x0820
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __GETBRPF
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETBRPF_INC
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z+
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F=R4
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_msb=R5
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W=R6
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_msb=R7
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_E=R8
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_E_msb=R9
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_EW=R10
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_EW_msb=R11
                 	.DEF __lcd_x=R13
                 	.DEF __lcd_y=R12
                 
                 	.CSEG
                 	.ORG 0x00
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
000000 940c 0212 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0000 	JMP  0x00
00001a 940c 0000 	JMP  0x00
00001c 940c 0247 	JMP  _timer_comp_isr
00001e 940c 0000 	JMP  0x00
000020 940c 0000 	JMP  0x00
000022 940c 0000 	JMP  0x00
000024 940c 0000 	JMP  0x00
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
                 
                 _error_msg:
000046 0276
000047 0000
000048 0277
000049 0000      	.DB  LOW(_0x0*2),HIGH(_0x0*2),BYTE3(_0x0*2),BYTE4(_0x0*2),LOW(_0x0*2+1),HIGH(_0x0*2+1),BYTE3(_0x0*2+1),BYTE4(_0x0*2+1)
00004a 0283
00004b 0000
00004c 0283
00004d 0000      	.DB  LOW(_0x0*2+13),HIGH(_0x0*2+13),BYTE3(_0x0*2+13),BYTE4(_0x0*2+13),LOW(_0x0*2+13),HIGH(_0x0*2+13),BYTE3(_0x0*2+13),BYTE4(_0x0*2+13)
00004e 028e
00004f 0000
000050 029b
000051 0000      	.DB  LOW(_0x0*2+24),HIGH(_0x0*2+24),BYTE3(_0x0*2+24),BYTE4(_0x0*2+24),LOW(_0x0*2+37),HIGH(_0x0*2+37),BYTE3(_0x0*2+37),BYTE4(_0x0*2+37)
000052 02a6
000053 0000
000054 02b1
000055 0000      	.DB  LOW(_0x0*2+48),HIGH(_0x0*2+48),BYTE3(_0x0*2+48),BYTE4(_0x0*2+48),LOW(_0x0*2+59),HIGH(_0x0*2+59),BYTE3(_0x0*2+59),BYTE4(_0x0*2+59)
000056 02c1
000057 0000
000058 02cb
000059 0000      	.DB  LOW(_0x0*2+75),HIGH(_0x0*2+75),BYTE3(_0x0*2+75),BYTE4(_0x0*2+75),LOW(_0x0*2+85),HIGH(_0x0*2+85),BYTE3(_0x0*2+85),BYTE4(_0x0*2+85)
00005a 02d4
00005b 0000
00005c 02e6
00005d 0000      	.DB  LOW(_0x0*2+94),HIGH(_0x0*2+94),BYTE3(_0x0*2+94),BYTE4(_0x0*2+94),LOW(_0x0*2+112),HIGH(_0x0*2+112),BYTE3(_0x0*2+112),BYTE4(_0x0*2+112)
00005e 02f9
00005f 0000
000060 030a
000061 0000      	.DB  LOW(_0x0*2+131),HIGH(_0x0*2+131),BYTE3(_0x0*2+131),BYTE4(_0x0*2+131),LOW(_0x0*2+148),HIGH(_0x0*2+148),BYTE3(_0x0*2+148),BYTE4(_0x0*2+148)
000062 0319
000063 0000
000064 032a
000065 0000      	.DB  LOW(_0x0*2+163),HIGH(_0x0*2+163),BYTE3(_0x0*2+163),BYTE4(_0x0*2+163),LOW(_0x0*2+180),HIGH(_0x0*2+180),BYTE3(_0x0*2+180),BYTE4(_0x0*2+180)
000066 033a
000067 0000      	.DB  LOW(_0x0*2+196),HIGH(_0x0*2+196),BYTE3(_0x0*2+196),BYTE4(_0x0*2+196)
                 _cvt_G002:
000068 9a80
000069 4190
00006a 418e
00006b 808f      	.DB  0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80
00006c 4545
00006d 4945
00006e 4949
00006f 8f8e      	.DB  0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F
000070 9290
000071 4f92
000072 4f99
000073 5555      	.DB  0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55
000074 9959
000075 9b9a
000076 9d9c
000077 9f9e      	.DB  0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F
000078 4941
000079 554f
00007a a5a5
00007b a7a6      	.DB  0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7
00007c a9a8
00007d abaa
00007e 21ac
00007f afae      	.DB  0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF
000080 b1b0
000081 b3b2
000082 b5b4
000083 b7b6      	.DB  0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7
000084 b9b8
000085 bbba
000086 bdbc
000087 bfbe      	.DB  0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF
000088 c1c0
000089 c3c2
00008a c5c4
00008b c7c6      	.DB  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
00008c c9c8
00008d cbca
00008e cdcc
00008f cfce      	.DB  0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF
000090 d1d0
000091 d3d2
000092 d5d4
000093 d7d6      	.DB  0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7
000094 d9d8
000095 dbda
000096 dddc
000097 dfde      	.DB  0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF
000098 e1e0
000099 e3e2
00009a e5e4
00009b e7e6      	.DB  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7
00009c e9e8
00009d ebea
00009e edec
00009f efee      	.DB  0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF
0000a0 f1f0
0000a1 f3f2
0000a2 f5f4
0000a3 f7f6      	.DB  0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7
0000a4 f9f8
0000a5 fbfa
0000a6 fdfc
0000a7 fffe      	.DB  0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
                 _tbl10_G100:
0000a8 2710
0000a9 03e8
0000aa 0064
0000ab 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
0000ac 0001      	.DB  0x1,0x0
                 _tbl16_G100:
0000ad 1000
0000ae 0100
0000af 0010
0000b0 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
                 __REG_VARS:
0000b1 f9db
0000b2 f9eb      	.DB  0xDB,0xF9,0xEB,0xF9
0000b3 fa0b
0000b4 fa2b      	.DB  0xB,0xFA,0x2B,0xFA
                 
                 _0x11:
0000b5 6e55
0000b6 7469
0000b7 5420
0000b8 7365      	.DB  0x55,0x6E,0x69,0x74,0x20,0x54,0x65,0x73
0000b9 2074
0000ba 0031
0000bb 302f
0000bc 752f      	.DB  0x74,0x20,0x31,0x0,0x2F,0x30,0x2F,0x75
0000bd 696e
0000be 7474
0000bf 7365
0000c0 2e74      	.DB  0x6E,0x69,0x74,0x74,0x65,0x73,0x74,0x2E
0000c1 7874
0000c2 0074
0000c3 0000
0000c4 0000      	.DB  0x74,0x78,0x74,0x0,0x0,0x0,0x0,0x0
0000c5 0000
0000c6 0000
0000c7 0000
0000c8 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000c9 0000
0000ca 0000
0000cb 0000
0000cc 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000cd 0000
0000ce 0000
0000cf 0000
0000d0 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000d1 0000
0000d2 0000
0000d3 0000
0000d4 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000d5 0000
0000d6 0000
0000d7 0000
0000d8 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000d9 0000
0000da 0000
0000db 0000
0000dc 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000dd 0000
0000de 0000
0000df 0000
0000e0 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000e1 0000
0000e2 0000
0000e3 0000
0000e4 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000e5 0000
0000e6 0000
0000e7 0000
0000e8 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000e9 0000
0000ea 0000
0000eb 0000
0000ec 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000ed 0000
0000ee 0000
0000ef 0000
0000f0 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000f1 0000
0000f2 0000
0000f3 0000
0000f4 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000f5 0000
0000f6 0000
0000f7 0000
0000f8 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000f9 0000
0000fa 0000
0000fb 0000
0000fc 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
0000fd 0000
0000fe 0000
0000ff 0000
000100 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000101 0000
000102 0000
000103 0000
000104 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000105 0000
000106 0000
000107 0000
000108 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000109 0000
00010a 0000
00010b 0000
00010c 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
00010d 0000
00010e 0000
00010f 0000
000110 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000111 0000
000112 0000
000113 0000
000114 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000115 0000
000116 0000
000117 0000
000118 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000119 0000
00011a 0000
00011b 0000
00011c 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
00011d 0000
00011e 0000
00011f 0000
000120 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000121 0000
000122 0000
000123 0000
000124 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000125 0000
000126 0000
000127 0000
000128 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000129 0000
00012a 0000
00012b 0000
00012c 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
00012d 0000
00012e 0000
00012f 0000
000130 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000131 0000
000132 0000
000133 0000
000134 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000135 0000
000136 0000
000137 0000
000138 0000      	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
000139 0000
00013a 0000      	.DB  0x0,0x0,0x0,0x0
                 _0x0:
00013b 4600
00013c 5f52
00013d 4944
00013e 4b53      	.DB  0x0,0x46,0x52,0x5F,0x44,0x49,0x53,0x4B
00013f 455f
000140 5252
000141 4600
000142 5f52      	.DB  0x5F,0x45,0x52,0x52,0x0,0x46,0x52,0x5F
000143 4e49
000144 5f54
000145 5245
000146 0052      	.DB  0x49,0x4E,0x54,0x5F,0x45,0x52,0x52,0x0
000147 5246
000148 4e5f
000149 544f
00014a 525f      	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x54,0x5F,0x52
00014b 4145
00014c 5944
00014d 4600
00014e 5f52      	.DB  0x45,0x41,0x44,0x59,0x0,0x46,0x52,0x5F
00014f 4f4e
000150 465f
000151 4c49
000152 0045      	.DB  0x4E,0x4F,0x5F,0x46,0x49,0x4C,0x45,0x0
000153 5246
000154 4e5f
000155 5f4f
000156 4150      	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x5F,0x50,0x41
000157 4854
000158 4600
000159 5f52
00015a 4e49      	.DB  0x54,0x48,0x0,0x46,0x52,0x5F,0x49,0x4E
00015b 4156
00015c 494c
00015d 5f44
00015e 414e      	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x4E,0x41
00015f 454d
000160 4600
000161 5f52
000162 4544      	.DB  0x4D,0x45,0x0,0x46,0x52,0x5F,0x44,0x45
000163 494e
000164 4445
000165 4600
000166 5f52      	.DB  0x4E,0x49,0x45,0x44,0x0,0x46,0x52,0x5F
000167 5845
000168 5349
000169 0054
00016a 5246      	.DB  0x45,0x58,0x49,0x53,0x54,0x0,0x46,0x52
00016b 495f
00016c 564e
00016d 4c41
00016e 4449      	.DB  0x5F,0x49,0x4E,0x56,0x41,0x4C,0x49,0x44
00016f 4f5f
000170 4a42
000171 4345
000172 0054      	.DB  0x5F,0x4F,0x42,0x4A,0x45,0x43,0x54,0x0
000173 5246
000174 575f
000175 4952
000176 4554      	.DB  0x46,0x52,0x5F,0x57,0x52,0x49,0x54,0x45
000177 505f
000178 4f52
000179 4554
00017a 5443      	.DB  0x5F,0x50,0x52,0x4F,0x54,0x45,0x43,0x54
00017b 4445
00017c 4600
00017d 5f52
00017e 4e49      	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x49,0x4E
00017f 4156
000180 494c
000181 5f44
000182 5244      	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x44,0x52
000183 5649
000184 0045
000185 5246
000186 4e5f      	.DB  0x49,0x56,0x45,0x0,0x46,0x52,0x5F,0x4E
000187 544f
000188 455f
000189 414e
00018a 4c42      	.DB  0x4F,0x54,0x5F,0x45,0x4E,0x41,0x42,0x4C
00018b 4445
00018c 4600
00018d 5f52
00018e 4f4e      	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x4E,0x4F
00018f 465f
000190 4c49
000191 5345
000192 5359      	.DB  0x5F,0x46,0x49,0x4C,0x45,0x53,0x59,0x53
000193 4554
000194 004d
000195 5246
000196 4d5f      	.DB  0x54,0x45,0x4D,0x0,0x46,0x52,0x5F,0x4D
000197 464b
000198 5f53
000199 4241
00019a 524f      	.DB  0x4B,0x46,0x53,0x5F,0x41,0x42,0x4F,0x52
00019b 4554
00019c 0044
00019d 5246
00019e 545f      	.DB  0x54,0x45,0x44,0x0,0x46,0x52,0x5F,0x54
00019f 4d49
0001a0 4f45
0001a1 5455
0001a2 4500      	.DB  0x49,0x4D,0x45,0x4F,0x55,0x54,0x0,0x45
0001a3 5252
0001a4 524f
0001a5 203a
0001a6 7025      	.DB  0x52,0x52,0x4F,0x52,0x3A,0x20,0x25,0x70
0001a7 0a0d
0001a8 5300
0001a9 2044
0001aa 5245      	.DB  0xD,0xA,0x0,0x53,0x44,0x20,0x45,0x52
0001ab 4f52
0001ac 3a52
0001ad 2c00
0001ae 4c00      	.DB  0x52,0x4F,0x52,0x3A,0x0,0x2C,0x0,0x4C
0001af 676f
0001b0 6369
0001b1 6c61
0001b2 6420      	.DB  0x6F,0x67,0x69,0x63,0x61,0x6C,0x20,0x64
0001b3 6972
0001b4 6576
0001b5 3020
0001b6 203a      	.DB  0x72,0x69,0x76,0x65,0x20,0x30,0x3A,0x20
0001b7 6f6d
0001b8 6e75
0001b9 6574
0001ba 2064      	.DB  0x6D,0x6F,0x75,0x6E,0x74,0x65,0x64,0x20
0001bb 4b4f
0001bc 0a0d
0001bd 2500
0001be 2073      	.DB  0x4F,0x4B,0xD,0xA,0x0,0x25,0x73,0x20
0001bf 0a0d
0001c0 4600
0001c1 6c69
0001c2 2065      	.DB  0xD,0xA,0x0,0x46,0x69,0x6C,0x65,0x20
0001c3 7325
0001c4 6320
0001c5 6572
0001c6 7461      	.DB  0x25,0x73,0x20,0x63,0x72,0x65,0x61,0x74
0001c7 6465
0001c8 4f20
0001c9 0d4b
0001ca 000a      	.DB  0x65,0x64,0x20,0x4F,0x4B,0xD,0xA,0x0
0001cb 7525
0001cc 6220
0001cd 7479
0001ce 7365      	.DB  0x25,0x75,0x20,0x62,0x79,0x74,0x65,0x73
0001cf 7720
0001d0 6972
0001d1 7474
0001d2 6e65      	.DB  0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6E
0001d3 6f20
0001d4 2066
0001d5 7525
0001d6 0a0d      	.DB  0x20,0x6F,0x66,0x20,0x25,0x75,0xD,0xA
0001d7 4600
0001d8 6c69
0001d9 2065
0001da 7325      	.DB  0x0,0x46,0x69,0x6C,0x65,0x20,0x25,0x73
0001db 6f20
0001dc 6570
0001dd 656e
0001de 2064      	.DB  0x20,0x6F,0x70,0x65,0x6E,0x65,0x64,0x20
0001df 4b4f
0001e0 0a0d
0001e1 2500
0001e2 2075      	.DB  0x4F,0x4B,0xD,0xA,0x0,0x25,0x75,0x20
0001e3 7962
0001e4 6574
0001e5 2073
0001e6 6572      	.DB  0x62,0x79,0x74,0x65,0x73,0x20,0x72,0x65
0001e7 6461
0001e8 0a0d
0001e9 5200
0001ea 6165      	.DB  0x61,0x64,0xD,0xA,0x0,0x52,0x65,0x61
0001eb 2064
0001ec 6574
0001ed 7478
0001ee 203a      	.DB  0x64,0x20,0x74,0x65,0x78,0x74,0x3A,0x20
0001ef 2522
0001f0 2273
0001f1 0a0d
0001f2 7000      	.DB  0x22,0x25,0x73,0x22,0xD,0xA,0x0,0x70
0001f3 6670
0001f4 5420
0001f5 7365
0001f6 2e74      	.DB  0x70,0x66,0x20,0x54,0x65,0x73,0x74,0x2E
0001f7 5400
0001f8 7365
0001f9 3174
0001fa 6420      	.DB  0x0,0x54,0x65,0x73,0x74,0x31,0x20,0x64
0001fb 6e6f
0001fc 2e65
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1276): warning: .cseg .db misalignment - padding zero byte
0001fd 0000      	.DB  0x6F,0x6E,0x65,0x2E,0x0
                 _0x2020060:
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1278): warning: .cseg .db misalignment - padding zero byte
0001fe 0001      	.DB  0x1
                 _0x2020000:
0001ff 4e2d
000200 4e41
000201 4900
000202 464e      	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 App1\Debug\List\Self_programming.asm(1281): warning: .cseg .db misalignment - padding zero byte
000203 0000      	.DB  0x0
                 _0x2060003:
000204 c080      	.DB  0x80,0xC0
                 
                 __GLOBAL_INI_TBL:
000205 0008      	.DW  0x08
000206 0004      	.DW  0x04
000207 0162 0000 	.DD  __REG_VARS*2
                 
000209 0001      	.DW  0x01
00020a 0926      	.DW  __seed_G101
00020b 03fc 0000 	.DD  _0x2020060*2
                 
00020d 0002      	.DW  0x02
00020e 092a      	.DW  __base_y_G103
00020f 0408 0000 	.DD  _0x2060003*2
                 
                 _0xFFFFFFFF:
000211 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
000212 94f8      	CLI
000213 27ee      	CLR  R30
000214 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
000215 e0f1      	LDI  R31,1
000216 bff5      	OUT  MCUCR,R31
000217 bfe5      	OUT  MCUCR,R30
000218 93e0 006c 	STS  XMCRB,R30
                 
                 ;CLEAR R2-R14
00021a e08d      	LDI  R24,(14-2)+1
00021b e0a2      	LDI  R26,2
00021c 27bb      	CLR  R27
                 __CLEAR_REG:
00021d 93ed      	ST   X+,R30
00021e 958a      	DEC  R24
00021f f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000220 e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
000221 e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
000222 e0a0      	LDI  R26,LOW(__SRAM_START)
000223 e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
000224 93ed      	ST   X+,R30
000225 9701      	SBIW R24,1
000226 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
000227 e0ea      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
000228 e0f4      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
000229 e0d0      	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00022a bfdb      	OUT  RAMPZ,R29
00022b 9187      	ELPM R24,Z+
00022c 9197      	ELPM R25,Z+
00022d 9700      	SBIW R24,0
00022e f081      	BREQ __GLOBAL_INI_END
00022f 91a7      	ELPM R26,Z+
000230 91b7      	ELPM R27,Z+
000231 9007      	ELPM R0,Z+
000232 9017      	ELPM R1,Z+
000233 91c7      	ELPM R28,Z+
000234 91d7      	ELPM R29,Z+
000235 01bf      	MOVW R22,R30
000236 b7db      	IN   R29,RAMPZ
000237 01f0      	MOVW R30,R0
000238 bfcb      	OUT  RAMPZ,R28
                 __GLOBAL_INI_LOOP:
000239 9007      	ELPM R0,Z+
00023a 920d      	ST   X+,R0
00023b 9701      	SBIW R24,1
00023c f7e1      	BRNE __GLOBAL_INI_LOOP
00023d 01fb      	MOVW R30,R22
00023e cfeb      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
00023f efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
000240 bfed      	OUT  SPL,R30
000241 e1e0      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
000242 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
000243 e2c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
000244 e0d9      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
000245 940c 034e 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x920
                 
                 	.CSEG
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming_main.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : This example is written for ATmega128.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains an example program using the Flash R/W
                 ;*                       functions provided with the files Self_programming.h /
                 ;*                       Self_programming.c . The program should be compiled using
                 ;*                       a linker file (*.xcl) that is configured to place the
                 ;*                       entire program code into the Boot section of the Flash memory.
                 ;*                       Please refer to the application note document for more
                 ;*                       information.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;*****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;#include <delay.h>
                 ;#include "Self_programming.h"
                 ;/* FAT on MMC/SD/SD HC card support */
                 ;#include <pff.h>
                 ;/* printf */
                 ;#include <stdio.h>
                 ;#include <stdlib.h>
                 ;/* string functions */
                 ;#include <string.h>
                 ;#include <alcd.h>
                 ;
                 ;/* Timer1 overflow interrupt frequency [Hz] */
                 ;#define T1_OVF_FREQ 100
                 ;/* Timer1 clock prescaler value */
                 ;#define T1_PRESC 1024L
                 ;/* Timer1 initialization value after overflow */
                 ;#define T1_INIT (0x10000L-(_MCU_CLOCK_FREQUENCY_/(T1_PRESC*T1_OVF_FREQ)))
                 ;/* 100Hz timer interrupt generated by ATmega128 Timer1 overflow */
                 ;interrupt [TIM1_OVF] void timer_comp_isr(void)
                 ; 0000 0030 {
                 
                 	.CSEG
                 _timer_comp_isr:
                 ; .FSTART _timer_comp_isr
000247 93ea      	ST   -Y,R30
                 ; 0000 0031     /* re-initialize Timer1 */
                 ; 0000 0032     TCNT1H=T1_INIT>>8;
000248 efef      	LDI  R30,LOW(255)
000249 bded      	OUT  0x2D,R30
                 ; 0000 0033     TCNT1L=T1_INIT&0xFF;
00024a e9ef      	LDI  R30,LOW(159)
00024b bdec      	OUT  0x2C,R30
                 ; 0000 0034     /* card access low level timing function */
                 ; 0000 0035     //disk_timerproc();
                 ; 0000 0036 }
00024c 91e9      	LD   R30,Y+
00024d 9518      	RETI
                 ; .FEND
                 ;
                 ;
                 ;/* error message list */
                 ;flash char * flash error_msg[]=
                 ;{
                 ;"", /* not used */
                 ;"FR_DISK_ERR",
                 ;"FR_INT_ERR",
                 ;"FR_INT_ERR",
                 ;"FR_NOT_READY",
                 ;"FR_NO_FILE",
                 ;"FR_NO_PATH",
                 ;"FR_INVALID_NAME",
                 ;"FR_DENIED",
                 ;"FR_EXIST",
                 ;"FR_INVALID_OBJECT",
                 ;"FR_WRITE_PROTECTED",
                 ;"FR_INVALID_DRIVE",
                 ;"FR_NOT_ENABLED",
                 ;"FR_NO_FILESYSTEM",
                 ;"FR_MKFS_ABORTED",
                 ;"FR_TIMEOUT"
                 ;};
                 ;/* display error message and stop */
                 ;void error(FRESULT res, unsigned char num)
                 ; 0000 0050 {
                 _error:
                 ; .FSTART _error
                 ; 0000 0051     char* strnum;
                 ; 0000 0052     itoa(num,strnum);
00024e 93aa      	ST   -Y,R26
00024f 931a      	ST   -Y,R17
000250 930a      	ST   -Y,R16
                 ;	res -> Y+3
                 ;	num -> Y+2
                 ;	*strnum -> R16,R17
000251 81ea      	LDD  R30,Y+2
000252 940e 1100 	CALL SUBOPT_0x0
                 ; 0000 0053     if ((res>=FR_DISK_ERR) && (res<=FR_NO_FILESYSTEM)){//FR_NO_FILESYSTEM  FR_TIMEOUT
000254 81ab      	LDD  R26,Y+3
000255 30a1      	CPI  R26,LOW(0x1)
000256 f010      	BRLO _0x4
000257 30a8      	CPI  R26,LOW(0x8)
000258 f008      	BRLO _0x5
                 _0x4:
000259 c033      	RJMP _0x3
                 _0x5:
                 ; 0000 0054        lcd_gotoxy(0,0);
00025a e0e0      	LDI  R30,LOW(0)
00025b 93ea      	ST   -Y,R30
00025c e0a0      	LDI  R26,LOW(0)
00025d 940e 107e 	CALL _lcd_gotoxy
                 ; 0000 0055        printf("ERROR: %p\r\n",error_msg[res]);
                +
00025f e4e5     +LDI R30 , LOW ( 2 * _0x0 + ( 207 ) )
000260 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 207 ) )
000261 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 207 ) )
000262 e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 207 ) )
                 	__POINTD1FN _0x0,207
000263 940e 1404 	CALL __PUTPARD1
000265 81ef      	LDD  R30,Y+7
000266 940e 1106 	CALL SUBOPT_0x1
000268 940e 13ed 	CALL __GETD1PF
00026a 940e 1113 	CALL SUBOPT_0x2
                 ; 0000 0056        lcd_putsf("SD ERROR:");
                +
00026c e5a1     +LDI R26 , LOW ( 2 * _0x0 + ( 219 ) )
00026d e0b3     +LDI R27 , HIGH ( 2 * _0x0 + ( 219 ) )
00026e e080     +LDI R24 , BYTE3 ( 2 * _0x0 + ( 219 ) )
00026f e090     +LDI R25 , BYTE4 ( 2 * _0x0 + ( 219 ) )
                 	__POINTD2FN _0x0,219
000270 940e 10bf 	CALL _lcd_putsf
                 ; 0000 0057        lcd_puts(strnum);
000272 01d8      	MOVW R26,R16
000273 940e 10ae 	CALL _lcd_puts
                 ; 0000 0058        lcd_putsf(",");
                +
000275 e5ab     +LDI R26 , LOW ( 2 * _0x0 + ( 229 ) )
000276 e0b3     +LDI R27 , HIGH ( 2 * _0x0 + ( 229 ) )
000277 e080     +LDI R24 , BYTE3 ( 2 * _0x0 + ( 229 ) )
000278 e090     +LDI R25 , BYTE4 ( 2 * _0x0 + ( 229 ) )
                 	__POINTD2FN _0x0,229
000279 940e 10bf 	CALL _lcd_putsf
                 ; 0000 0059        itoa(res,strnum);
00027b 81eb      	LDD  R30,Y+3
00027c 940e 1100 	CALL SUBOPT_0x0
                 ; 0000 005A        lcd_puts(strnum);
00027e 01d8      	MOVW R26,R16
00027f 940e 10ae 	CALL _lcd_puts
                 ; 0000 005B        lcd_gotoxy(0,1);
000281 e0e0      	LDI  R30,LOW(0)
000282 93ea      	ST   -Y,R30
000283 e0a1      	LDI  R26,LOW(1)
000284 940e 107e 	CALL _lcd_gotoxy
                 ; 0000 005C        lcd_putsf(error_msg[res]);
000286 81eb      	LDD  R30,Y+3
000287 940e 1106 	CALL SUBOPT_0x1
000289 940e 13f4 	CALL __GETD2PF
00028b 940e 10bf 	CALL _lcd_putsf
                 ; 0000 005D     }
                 ; 0000 005E     /* stop here */
                 ; 0000 005F     do
                 _0x3:
                 _0x7:
                 ; 0000 0060         {
                 ; 0000 0061           PORTC.0=0;
00028d 98a8      	CBI  0x15,0
                 ; 0000 0062           PORTC.1=0;
00028e 98a9      	CBI  0x15,1
                 ; 0000 0063           delay_ms(50);
00028f e3a2      	LDI  R26,LOW(50)
000290 e0b0      	LDI  R27,0
000291 940e 1316 	CALL _delay_ms
                 ; 0000 0064           PORTC.1=1;
000293 9aa9      	SBI  0x15,1
                 ; 0000 0065           PORTC.0=1;
000294 9aa8      	SBI  0x15,0
                 ; 0000 0066           delay_ms(50);
000295 e3a2      	LDI  R26,LOW(50)
000296 e0b0      	LDI  R27,0
000297 940e 1316 	CALL _delay_ms
                 ; 0000 0067           PORTC=0xFC;
000299 efec      	LDI  R30,LOW(252)
00029a bbe5      	OUT  0x15,R30
                 ; 0000 0068         }
                 ; 0000 0069       while(1);
00029b cff1      	RJMP _0x7
                 ; 0000 006A }
                 ; .FEND
                 ;
                 ;unsigned char UnitTest1(){
                 ; 0000 006C unsigned char UnitTest1(){
                 _UnitTest1:
                 ; .FSTART _UnitTest1
                 ; 0000 006D   //FRESULT f_mount(unsigned char vol, FATFS *fs);   FR_OK, FR_INVALID_DRIVE
                 ; 0000 006E   //FRESULT f_open(FIL* fp, const char* path, unsigned char mode);
                 ; 0000 006F   //[logical_drive_number:][/][directory_name/]file_name   0:file.txt(current dir file)
                 ; 0000 0070   // 0:/file.txt (root dir file)
                 ; 0000 0071   // FA_READ | FA_WRITE,FA_OPEN_EXISTING,FA_OPEN_ALWAYS,FA_CREATE_NEW,FA_CREATE_ALWAYS
                 ; 0000 0072   // f_read(FIL* fp, void* buff, unsigned int btr, unsigned int* br)
                 ; 0000 0073   // f_write(FIL* fp, const void* buff, unsigned int btw, unsigned int* bw)
                 ; 0000 0074   // f_lseek(FIL* fp, unsigned long ofs)
                 ; 0000 0075   // f_truncate(FIL* fp)  cut the size of file to current position of pointer
                 ; 0000 0076   // f_close(FIL* fp)
                 ; 0000 0077   // f_sync(FIL* fp) useful when file open in write mode a lomg time
                 ; 0000 0078   // f_opendir(DIR* dj, const char* path)
                 ; 0000 0079   // f_readdir(DIR* dj, FILINFO* fno)
                 ; 0000 007A   // FRESULT f_mkdir (const char* path)  FRESULT f_unlink(const char* path)
                 ; 0000 007B 
                 ; 0000 007C 
                 ; 0000 007D       /* FAT function result */
                 ; 0000 007E     FRESULT res;
                 ; 0000 007F     /* number of bytes written/read to the file */
                 ; 0000 0080     unsigned int nbytes;
                 ; 0000 0081     /* will hold the information for logical drive 0: */
                 ; 0000 0082     FATFS fat;
                 ; 0000 0083     /* will hold the file information */
                 ; 0000 0084     //FIL file;
                 ; 0000 0085     /* will hold file attributes, time stamp information */
                 ; 0000 0086     FILINFO finfo;
                 ; 0000 0087 
                 ; 0000 0088     /* root directory path */
                 ; 0000 0089     //char path[256]="0:/unittest.txt";
                 ; 0000 008A     char path[256]="/0/unittest.txt";
                 ; 0000 008B     /* text to be written to the file */
                 ; 0000 008C     char text[]="Unit Test 1";
                 ; 0000 008D     /* file read buffer */
                 ; 0000 008E     char buffer[256];
                 ; 0000 008F 
                 ; 0000 0090     /* globally enable interrupts */
                 ; 0000 0091     //#asm("sei")
                 ; 0000 0092 
                 ; 0000 0093 
                 ; 0000 0094     /* mount logical drive 0: */
                 ; 0000 0095     //if ((res=f_mount(0,&fat))==FR_OK)
                 ; 0000 0096     if ((res=pf_mount(&fat))==FR_OK)
00029c 97ef      	SBIW R28,63
00029d 972f      	SBIW R28,15
00029e 50d2      	SUBI R29,2
                +
00029f e08c     +LDI R24 , LOW ( 268 )
0002a0 e091     +LDI R25 , HIGH ( 268 )
                 	__GETWRN 24,25,268
0002a1 e0a0      	LDI  R26,LOW(256)
0002a2 e0b1      	LDI  R27,HIGH(256)
0002a3 e6ea      	LDI  R30,LOW(_0x11*2)
0002a4 e0f1      	LDI  R31,HIGH(_0x11*2)
0002a5 e060      	LDI  R22,BYTE3(_0x11*2)
0002a6 940e 146e 	CALL __INITLOCW
0002a8 940e 1462 	CALL __SAVELOCR4
                 ;	res -> R17
                 ;	nbytes -> R18,R19
                 ;	fat -> Y+550
                 ;	finfo -> Y+528
                 ;	path -> Y+272
                 ;	text -> Y+260
                 ;	buffer -> Y+4
0002aa 01de      	MOVW R26,R28
0002ab 5daa      	SUBI R26,LOW(-(550))
0002ac 4fbd      	SBCI R27,HIGH(-(550))
0002ad 940e 092d 	CALL _pf_mount
0002af 2f1e      	MOV  R17,R30
0002b0 30e0      	CPI  R30,0
0002b1 f459      	BRNE _0x12
                 ; 0000 0097        printf("Logical drive 0: mounted OK\r\n");
                +
0002b2 e5ed     +LDI R30 , LOW ( 2 * _0x0 + ( 231 ) )
0002b3 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 231 ) )
0002b4 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 231 ) )
0002b5 e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 231 ) )
                 	__POINTD1FN _0x0,231
0002b6 940e 1404 	CALL __PUTPARD1
0002b8 e080      	LDI  R24,0
0002b9 940e 0fef 	CALL _printf
0002bb 9624      	ADIW R28,4
                 ; 0000 0098     else
0002bc c003      	RJMP _0x13
                 _0x12:
                 ; 0000 0099        /* an error occured, display it and stop */
                 ; 0000 009A        error(res,1);
0002bd 931a      	ST   -Y,R17
0002be e0a1      	LDI  R26,LOW(1)
0002bf df8e      	RCALL _error
                 ; 0000 009B 
                 ; 0000 009C 
                 ; 0000 009D     printf("%s \r\n",path);
                 _0x13:
                +
0002c0 e7eb     +LDI R30 , LOW ( 2 * _0x0 + ( 261 ) )
0002c1 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 261 ) )
0002c2 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 261 ) )
0002c3 e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 261 ) )
                 	__POINTD1FN _0x0,261
0002c4 940e 111a 	CALL SUBOPT_0x3
                 ; 0000 009E     /*this line will remove READ_ONLY attribute*/
                 ; 0000 009F     //f_chmod(path, AM_ARC, AM_ARC|AM_RDO);
                 ; 0000 00A0     /* create a new file in the root of drive 0:
                 ; 0000 00A1        and set write access mode */
                 ; 0000 00A2     //if ((res=f_open(&file,path,FA_CREATE_ALWAYS | FA_WRITE))==FR_OK)
                 ; 0000 00A3     if ((res=pf_open(path))==FR_OK)
0002c6 940e 1122 	CALL SUBOPT_0x4
0002c8 f439      	BRNE _0x14
                 ; 0000 00A4        printf("File %s created OK\r\n",path);
                +
0002c9 e8e1     +LDI R30 , LOW ( 2 * _0x0 + ( 267 ) )
0002ca e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 267 ) )
0002cb e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 267 ) )
0002cc e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 267 ) )
                 	__POINTD1FN _0x0,267
0002cd 940e 111a 	CALL SUBOPT_0x3
                 ; 0000 00A5     else{
0002cf c005      	RJMP _0x15
                 _0x14:
                 ; 0000 00A6        /* an error occured, display it and stop */
                 ; 0000 00A7        if(res!=3)
0002d0 3013      	CPI  R17,3
0002d1 f019      	BREQ _0x16
                 ; 0000 00A8             error(res,2);
0002d2 931a      	ST   -Y,R17
0002d3 e0a2      	LDI  R26,LOW(2)
0002d4 df79      	RCALL _error
                 ; 0000 00A9     }
                 _0x16:
                 _0x15:
                 ; 0000 00AA 
                 ; 0000 00AB     /* write some text to the file,
                 ; 0000 00AC        without the NULL string terminator sizeof(data)-1 */
                 ; 0000 00AD     //if ((res=f_write(&file,text,sizeof(text)-1,&nbytes))==FR_OK)
                 ; 0000 00AE     if ((res=pf_write(text,sizeof(text)-1,&nbytes))==FR_OK)
0002d5 01fe      	MOVW R30,R28
0002d6 5fec      	SUBI R30,LOW(-(260))
0002d7 4ffe      	SBCI R31,HIGH(-(260))
0002d8 93fa      	ST   -Y,R31
0002d9 93ea      	ST   -Y,R30
0002da e0eb      	LDI  R30,LOW(11)
0002db e0f0      	LDI  R31,HIGH(11)
0002dc 93fa      	ST   -Y,R31
0002dd 93ea      	ST   -Y,R30
0002de b7ad      	IN   R26,SPL
0002df b7be      	IN   R27,SPH
0002e0 9711      	SBIW R26,1
0002e1 933f      	PUSH R19
0002e2 932f      	PUSH R18
0002e3 940e 0ba0 	CALL _pf_write
0002e5 912f      	POP  R18
0002e6 913f      	POP  R19
0002e7 2f1e      	MOV  R17,R30
0002e8 30e0      	CPI  R30,0
0002e9 f4b1      	BRNE _0x17
                 ; 0000 00AF        printf("%u bytes written of %u\r\n",nbytes,sizeof(text)-1);
                +
0002ea e9e6     +LDI R30 , LOW ( 2 * _0x0 + ( 288 ) )
0002eb e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 288 ) )
0002ec e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 288 ) )
0002ed e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 288 ) )
                 	__POINTD1FN _0x0,288
0002ee 940e 1404 	CALL __PUTPARD1
0002f0 01f9      	MOVW R30,R18
0002f1 2766      	CLR  R22
0002f2 2777      	CLR  R23
0002f3 940e 1404 	CALL __PUTPARD1
                +
0002f5 e0eb     +LDI R30 , LOW ( 0xB )
0002f6 e0f0     +LDI R31 , HIGH ( 0xB )
0002f7 e060     +LDI R22 , BYTE3 ( 0xB )
0002f8 e070     +LDI R23 , BYTE4 ( 0xB )
                 	__GETD1N 0xB
0002f9 940e 1404 	CALL __PUTPARD1
0002fb e088      	LDI  R24,8
0002fc 940e 0fef 	CALL _printf
0002fe 962c      	ADIW R28,12
                 ; 0000 00B0     else
0002ff c003      	RJMP _0x18
                 _0x17:
                 ; 0000 00B1        ///* an error occured, display it and stop */
                 ; 0000 00B2        error(res,3);
000300 931a      	ST   -Y,R17
000301 e0a3      	LDI  R26,LOW(3)
000302 df4b      	RCALL _error
                 ; 0000 00B3 
                 ; 0000 00B4         /* close the file */
                 ; 0000 00B5     /*
                 ; 0000 00B6     if ((res=f_close(&file))==FR_OK)
                 ; 0000 00B7        printf("File %s closed OK\r\n",path);
                 ; 0000 00B8     else
                 ; 0000 00B9        // an error occured, display it and stop
                 ; 0000 00BA        error(res,4);
                 ; 0000 00BB     */
                 ; 0000 00BC 
                 ; 0000 00BD     /* open the file in read mode */
                 ; 0000 00BE 
                 ; 0000 00BF     //if ((res=f_open(&file,path,FA_READ|FA_WRITE))==FR_OK)
                 ; 0000 00C0     if ((res=pf_open(path))==FR_OK)
                 _0x18:
000303 940e 1122 	CALL SUBOPT_0x4
000305 f439      	BRNE _0x19
                 ; 0000 00C1        printf("File %s opened OK\r\n",path);
                +
000306 eaef     +LDI R30 , LOW ( 2 * _0x0 + ( 313 ) )
000307 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 313 ) )
000308 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 313 ) )
000309 e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 313 ) )
                 	__POINTD1FN _0x0,313
00030a 940e 111a 	CALL SUBOPT_0x3
                 ; 0000 00C2     else
00030c c003      	RJMP _0x1A
                 _0x19:
                 ; 0000 00C3        ///* an error occured, display it and stop */
                 ; 0000 00C4        error(res,7);
00030d 931a      	ST   -Y,R17
00030e e0a7      	LDI  R26,LOW(7)
00030f df3e      	RCALL _error
                 ; 0000 00C5 
                 ; 0000 00C6 
                 ; 0000 00C7 
                 ; 0000 00C8     /* read and display the file's content.
                 ; 0000 00C9        make sure to leave space for a NULL terminator
                 ; 0000 00CA        in the buffer, so maximum sizeof(buffer)-1 bytes can be read */
                 ; 0000 00CB     //if ((res=f_read(&file,buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
                 ; 0000 00CC     if ((res=pf_read(buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
                 _0x1A:
000310 01fe      	MOVW R30,R28
000311 9634      	ADIW R30,4
000312 93fa      	ST   -Y,R31
000313 93ea      	ST   -Y,R30
000314 efef      	LDI  R30,LOW(255)
000315 e0f0      	LDI  R31,HIGH(255)
000316 93fa      	ST   -Y,R31
000317 93ea      	ST   -Y,R30
000318 b7ad      	IN   R26,SPL
000319 b7be      	IN   R27,SPH
00031a 9711      	SBIW R26,1
00031b 933f      	PUSH R19
00031c 932f      	PUSH R18
00031d 940e 0aaa 	CALL _pf_read
00031f 912f      	POP  R18
000320 913f      	POP  R19
000321 2f1e      	MOV  R17,R30
000322 30e0      	CPI  R30,0
000323 f501      	BRNE _0x1B
                 ; 0000 00CD        {
                 ; 0000 00CE        printf("%u bytes read\r\n",nbytes);
                +
000324 ece3     +LDI R30 , LOW ( 2 * _0x0 + ( 333 ) )
000325 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 333 ) )
000326 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 333 ) )
000327 e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 333 ) )
                 	__POINTD1FN _0x0,333
000328 940e 1404 	CALL __PUTPARD1
00032a 01f9      	MOVW R30,R18
00032b 2766      	CLR  R22
00032c 2777      	CLR  R23
00032d 940e 1113 	CALL SUBOPT_0x2
                 ; 0000 00CF        /* NULL terminate the char string in the buffer */
                 ; 0000 00D0        buffer[nbytes+1]=NULL;
00032f 01f9      	MOVW R30,R18
000330 9631      	ADIW R30,1
000331 01de      	MOVW R26,R28
000332 9614      	ADIW R26,4
000333 0fae      	ADD  R26,R30
000334 1fbf      	ADC  R27,R31
000335 e0e0      	LDI  R30,LOW(0)
000336 93ec      	ST   X,R30
                 ; 0000 00D1        /* display the buffer contents */
                 ; 0000 00D2        printf("Read text: \"%s\"\r\n",buffer);
                +
000337 ede3     +LDI R30 , LOW ( 2 * _0x0 + ( 349 ) )
000338 e0f3     +LDI R31 , HIGH ( 2 * _0x0 + ( 349 ) )
000339 e060     +LDI R22 , BYTE3 ( 2 * _0x0 + ( 349 ) )
00033a e070     +LDI R23 , BYTE4 ( 2 * _0x0 + ( 349 ) )
                 	__POINTD1FN _0x0,349
00033b 940e 1404 	CALL __PUTPARD1
00033d 01fe      	MOVW R30,R28
00033e 9638      	ADIW R30,8
00033f 2766      	CLR  R22
000340 2777      	CLR  R23
000341 940e 1113 	CALL SUBOPT_0x2
                 ; 0000 00D3        }
                 ; 0000 00D4     else
000343 c003      	RJMP _0x1C
                 _0x1B:
                 ; 0000 00D5        /* an error occured, display it and stop */
                 ; 0000 00D6        error(res,6);
000344 931a      	ST   -Y,R17
000345 e0a6      	LDI  R26,LOW(6)
000346 df07      	RCALL _error
                 ; 0000 00D7 
                 ; 0000 00D8 
                 ; 0000 00D9     /* close the file */
                 ; 0000 00DA     /*
                 ; 0000 00DB     if ((res=f_close(&file))==FR_OK)
                 ; 0000 00DC        printf("File %s closed OK\r\n",path);
                 ; 0000 00DD     else
                 ; 0000 00DE        // an error occured, display it and stop
                 ; 0000 00DF        error(res,6);
                 ; 0000 00E0     */
                 ; 0000 00E1 
                 ; 0000 00E2     /* display file's attribute, size and time stamp */
                 ; 0000 00E3     //display_status(path);
                 ; 0000 00E4 
                 ; 0000 00E5 
                 ; 0000 00E6     /* change file's attributes, set the file to be Read-Only */
                 ; 0000 00E7     /*
                 ; 0000 00E8     if ((res=f_chmod(path,AM_RDO,AM_RDO))==FR_OK)
                 ; 0000 00E9        printf("Read-Only attribute set OK\r\n",path);
                 ; 0000 00EA     else
                 ; 0000 00EB        // an error occured, display it and stop
                 ; 0000 00EC        error(res,7);
                 ; 0000 00ED     */
                 ; 0000 00EE   return 1;
                 _0x1C:
000347 e0e1      	LDI  R30,LOW(1)
000348 940e 1469 	CALL __LOADLOCR4
00034a 96ef      	ADIW R28,63
00034b 9663      	ADIW R28,19
00034c 5fde      	SUBI R29,-2
00034d 9508      	RET
                 ; 0000 00EF }
                 ; .FEND
                 ;void main( void ){
                 ; 0000 00F0 void main( void ){
                 _main:
                 ; .FSTART _main
                 ; 0000 00F1   unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
                 ; 0000 00F2   //unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                 ; 0000 00F3                                             // code stack
                 ; 0000 00F4   static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
                 ; 0000 00F5   int index;
                 ; 0000 00F6 
                 ; 0000 00F7   /* initialize Timer1 overflow interrupts in Mode 0 (Normal) */
                 ; 0000 00F8 TCCR1A=0x00;
00034e 50d1      	SUBI R29,1
                 ;	testBuffer1 -> Y+0
                 ;	index -> R16,R17
00034f e0e0      	LDI  R30,LOW(0)
000350 bdef      	OUT  0x2F,R30
                 ; 0000 00F9 /* clkio/1024 */
                 ; 0000 00FA TCCR1B=(1<<CS12)|(1<<CS10);
000351 e0e5      	LDI  R30,LOW(5)
000352 bdee      	OUT  0x2E,R30
                 ; 0000 00FB /* timer overflow interrupts will occur with 100Hz frequency */
                 ; 0000 00FC TCNT1H=T1_INIT>>8;
000353 efef      	LDI  R30,LOW(255)
000354 bded      	OUT  0x2D,R30
                 ; 0000 00FD TCNT1L=T1_INIT&0xFF;
000355 e9ef      	LDI  R30,LOW(159)
000356 bdec      	OUT  0x2C,R30
                 ; 0000 00FE /* enable Timer1 overflow interrupt */
                 ; 0000 00FF TIMSK=1<<TOIE1;
000357 e0e4      	LDI  R30,LOW(4)
000358 bfe7      	OUT  0x37,R30
                 ; 0000 0100 
                 ; 0000 0101   /* globally enable interrupts */
                 ; 0000 0102     #asm("sei")
000359 9478      	sei
                 ; 0000 0103 
                 ; 0000 0104   DDRC=0xFF;
00035a efef      	LDI  R30,LOW(255)
00035b bbe4      	OUT  0x14,R30
                 ; 0000 0105   PORTC=0xFF;
00035c bbe5      	OUT  0x15,R30
                 ; 0000 0106   /* initialize the LCD for 2 lines & 16 columns */
                 ; 0000 0107     lcd_init(16);
00035d e1a0      	LDI  R26,LOW(16)
00035e 940e 10d1 	CALL _lcd_init
                 ; 0000 0108   /* switch to writing in Display RAM */
                 ; 0000 0109     //lcd_gotoxy(0,0);
                 ; 0000 010A     lcd_clear();
000360 940e 108b 	CALL _lcd_clear
                 ; 0000 010B     //lcd_putsf("User char 0:");
                 ; 0000 010C 
                 ; 0000 010D   //disk_timerproc();
                 ; 0000 010E   lcd_clear();
000362 940e 108b 	CALL _lcd_clear
                 ; 0000 010F   lcd_putsf("ppf Test.");
                +
000364 eea5     +LDI R26 , LOW ( 2 * _0x0 + ( 367 ) )
000365 e0b3     +LDI R27 , HIGH ( 2 * _0x0 + ( 367 ) )
000366 e080     +LDI R24 , BYTE3 ( 2 * _0x0 + ( 367 ) )
000367 e090     +LDI R25 , BYTE4 ( 2 * _0x0 + ( 367 ) )
                 	__POINTD2FN _0x0,367
000368 940e 10bf 	CALL _lcd_putsf
                 ; 0000 0110   UnitTest1();
00036a df31      	RCALL _UnitTest1
                 ; 0000 0111   /* switch to writing in Display RAM */
                 ; 0000 0112     lcd_gotoxy(0,0);
00036b e0e0      	LDI  R30,LOW(0)
00036c 93ea      	ST   -Y,R30
00036d e0a0      	LDI  R26,LOW(0)
00036e 940e 107e 	CALL _lcd_gotoxy
                 ; 0000 0113     lcd_putsf("Test1 done.");
                +
000370 eeaf     +LDI R26 , LOW ( 2 * _0x0 + ( 377 ) )
000371 e0b3     +LDI R27 , HIGH ( 2 * _0x0 + ( 377 ) )
000372 e080     +LDI R24 , BYTE3 ( 2 * _0x0 + ( 377 ) )
000373 e090     +LDI R25 , BYTE4 ( 2 * _0x0 + ( 377 ) )
                 	__POINTD2FN _0x0,377
000374 940e 10bf 	CALL _lcd_putsf
                 ; 0000 0114   do
                 _0x1E:
                 ; 0000 0115     {
                 ; 0000 0116       PORTC.0=0;
000376 98a8      	CBI  0x15,0
                 ; 0000 0117       PORTC.1=0;
000377 940e 112a 	CALL SUBOPT_0x5
                 ; 0000 0118       delay_ms(500);
                 ; 0000 0119       PORTC.1=1;
                 ; 0000 011A       PORTC.0=1;
000379 9aa8      	SBI  0x15,0
                 ; 0000 011B       delay_ms(500);
00037a 940e 1131 	CALL SUBOPT_0x6
                 ; 0000 011C       PORTC=0xFC;
00037c efec      	LDI  R30,LOW(252)
00037d bbe5      	OUT  0x15,R30
                 ; 0000 011D     }
                 ; 0000 011E   while(1);
00037e cff7      	RJMP _0x1E
                 ; 0000 011F   for(index=0; index<PAGESIZE; index++){
                 _0x29:
                +
00037f 3000     +CPI R16 , LOW ( 256 )
000380 e0e1     +LDI R30 , HIGH ( 256 )
000381 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
000382 f444      	BRGE _0x2A
                 ; 0000 0120     testBuffer1[index]=index;//(unsigned char)0xFF; // Fills testBuffer1 with values FF
000383 01f8      	MOVW R30,R16
000384 01de      	MOVW R26,R28
000385 0fea      	ADD  R30,R26
000386 1ffb      	ADC  R31,R27
000387 8300      	ST   Z,R16
                 ; 0000 0121   }
                +
000388 5f0f     +SUBI R16 , LOW ( - 1 )
000389 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00038a cff4      	RJMP _0x29
                 _0x2A:
                 ; 0000 0122   if(WriteFlashBytes(0x2, testBuffer1,PAGESIZE)){     // Writes testbuffer1 to Flash page 2
00038b 940e 1135 	CALL SUBOPT_0x7
00038d 01fe      	MOVW R30,R28
00038e 9634      	ADIW R30,4
00038f 93fa      	ST   -Y,R31
000390 93ea      	ST   -Y,R30
000391 e0a0      	LDI  R26,LOW(256)
000392 e0b1      	LDI  R27,HIGH(256)
000393 d0b9      	RCALL _WriteFlashBytes
000394 30e0      	CPI  R30,0
000395 f009      	BREQ _0x2B
                 ; 0000 0123     PORTC.2=0;
000396 98aa      	CBI  0x15,2
                 ; 0000 0124   }                                            // Same as byte 4 on page 2
                 ; 0000 0125   //MCUCR &= ~(1<<IVSEL);
                 ; 0000 0126   ReadFlashBytes(0x2,&testChar,1);        // Reads back value from address 0x204
                 _0x2B:
000397 940e 1135 	CALL SUBOPT_0x7
000399 940e 113c 	CALL SUBOPT_0x8
                 ; 0000 0127   if(testChar==0x00)
00039b 91e0 0920 	LDS  R30,_testChar_S0000003000
00039d 30e0      	CPI  R30,0
00039e f529      	BRNE _0x2E
                 ; 0000 0128   {
                 ; 0000 0129       ReadFlashBytes(0x3,&testChar,1);        // Reads back value from address 0x204
                +
00039f e0e3     +LDI R30 , LOW ( 0x3 )
0003a0 e0f0     +LDI R31 , HIGH ( 0x3 )
0003a1 e060     +LDI R22 , BYTE3 ( 0x3 )
0003a2 e070     +LDI R23 , BYTE4 ( 0x3 )
                 	__GETD1N 0x3
0003a3 940e 1144 	CALL SUBOPT_0x9
                 ; 0000 012A       if(testChar==0x01)
0003a5 91a0 0920 	LDS  R26,_testChar_S0000003000
0003a7 30a1      	CPI  R26,LOW(0x1)
0003a8 f431      	BRNE _0x2F
                 ; 0000 012B         ReadFlashBytes(0x100,&testChar,1);        // Reads back value from address 0x204
                +
0003a9 e0e0     +LDI R30 , LOW ( 0x100 )
0003aa e0f1     +LDI R31 , HIGH ( 0x100 )
0003ab e060     +LDI R22 , BYTE3 ( 0x100 )
0003ac e070     +LDI R23 , BYTE4 ( 0x100 )
                 	__GETD1N 0x100
0003ad 940e 1144 	CALL SUBOPT_0x9
                 ; 0000 012C         if(testChar==0xFE)
                 _0x2F:
0003af 91a0 0920 	LDS  R26,_testChar_S0000003000
0003b1 3fae      	CPI  R26,LOW(0xFE)
0003b2 f431      	BRNE _0x30
                 ; 0000 012D             ReadFlashBytes(0x101,&testChar,1);        // Reads back value from address 0x204
                +
0003b3 e0e1     +LDI R30 , LOW ( 0x101 )
0003b4 e0f1     +LDI R31 , HIGH ( 0x101 )
0003b5 e060     +LDI R22 , BYTE3 ( 0x101 )
0003b6 e070     +LDI R23 , BYTE4 ( 0x101 )
                 	__GETD1N 0x101
0003b7 940e 1144 	CALL SUBOPT_0x9
                 ; 0000 012E             if(testChar==0xFF)
                 _0x30:
0003b9 91a0 0920 	LDS  R26,_testChar_S0000003000
0003bb 3faf      	CPI  R26,LOW(0xFF)
0003bc f439      	BRNE _0x31
                 ; 0000 012F               while(1)
                 _0x32:
                 ; 0000 0130               {
                 ; 0000 0131                   PORTC.0=0;
0003bd 98a8      	CBI  0x15,0
                 ; 0000 0132                   delay_ms(500);
0003be 940e 1131 	CALL SUBOPT_0x6
                 ; 0000 0133                   PORTC.0=1;
0003c0 9aa8      	SBI  0x15,0
                 ; 0000 0134                   delay_ms(500);
0003c1 940e 1131 	CALL SUBOPT_0x6
                 ; 0000 0135               }
0003c3 cff9      	RJMP _0x32
                 ; 0000 0136   }
                 _0x31:
                 ; 0000 0137 
                 ; 0000 0138   while(1)
                 _0x2E:
                 _0x39:
                 ; 0000 0139   {
                 ; 0000 013A       PORTC.1=0;
0003c4 940e 112a 	CALL SUBOPT_0x5
                 ; 0000 013B       delay_ms(500);
                 ; 0000 013C       PORTC.1=1;
                 ; 0000 013D       delay_ms(500);
0003c6 940e 1131 	CALL SUBOPT_0x6
                 ; 0000 013E   }
0003c8 cffb      	RJMP _0x39
                 ; 0000 013F   //}
                 ; 0000 0140 }
                 _0x40:
0003c9 cfff      	RJMP _0x40
                 ; .FEND
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : All devices with bootloaders support.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains functions for easy reading and writing
                 ;*                       of Flash memory on parts having the "Self-programming"
                 ;*                       feature. The user functions are as follows:
                 ;*
                 ;*                       ReadFlashByte()
                 ;*                       ReadFlashPage()
                 ;*                       WriteFlashByte()
                 ;*                       WriteFlashPage()
                 ;*                       RecoverFlash()
                 ;*
                 ;*                       The remaining functions contained in this file are used
                 ;*                       by the functions listet above.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;//#include <inavr.h>
                 ;#include "Self_programming.h"
                 ;//#include "flash.h"
                 ;
                 ;void (*__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F)(void flash * addr, unsigned int data)= (void(*)(void flash *, unsigned in ...
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_W)(void flash * addr)= (void(*)(void flash *)) 0x0F9EB;
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_E)(void flash * addr)= (void(*)(void flash *)) 0x0FA0B;
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_EW)(void flash * addr)= (void(*)(void flash *)) 0x0FA2B;
                 ;
                 ;/*!
                 ;* Declare global struct variable in EEPROM if Flash recovery enabled.
                 ;* FlashBackup pageNumber holds Flash pageaddress (/PAGESIZE) the data in Flash
                 ;* recovery buffer should be written to if data need to be recovered.
                 ;* FlashBackup.status tells if data need to be recovered.
                 ;**/
                 ;#ifdef __FLASH_RECOVER
                 ;__eeprom struct {
                 ;  unsigned int  pageNumber;
                 ;  unsigned char status;
                 ;}FlashBackup = {0};
                 ;#endif
                 ;
                 ;__eeprom struct {
                 ;  unsigned long  flashStartAdr;
                 ;  unsigned int length;
                 ;  unsigned char status;//0=already moved to flash, 1=not moved to flash yet
                 ;  unsigned char data[PAGESIZE];
                 ;}_EepromBackup @10;
                 ;
                 ;/*!
                 ;* The function Returns one byte located on Flash address given by ucFlashStartAdr.
                 ;**/
                 ;unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0001 0042 unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 
                 	.CSEG
                 _ReadFlashByte:
                 ; .FSTART _ReadFlashByte
                 ; 0001 0043 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0001 0044   flashStartAdr;//+=ADR_LIMIT_LOW;
0003ca 940e 1409 	CALL __PUTPARD2
                 ;	flashStartAdr -> Y+0
0003cc 940e 1147 	CALL SUBOPT_0xA
                 ; 0001 0045   return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
0003ce 940e 1147 	CALL SUBOPT_0xA
                +
0003d0 bf6b     +OUT RAMPZ , R22
0003d1 91e6     +ELPM R30 , Z
                 	__GETBRPF 30
0003d2 c1e2      	RJMP _0x20C0011
                 ; 0001 0046 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0001 0047 } // Returns data from Flash
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads one Flash page from address flashStartAdr and stores data
                 ;* in array dataPage[]. The number of bytes stored is depending upon the
                 ;* Flash page size. The function returns FALSE if input address is not a Flash
                 ;* page address, else TRUE.
                 ;**/
                 ;unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0001 004F unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 _ReadFlashPage:
                 ; .FSTART _ReadFlashPage
                 ; 0001 0050   unsigned int index;
                 ; 0001 0051   flashStartAdr;//+=ADR_LIMIT_LOW;
0003d3 940e 114a 	CALL SUBOPT_0xB
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
0003d5 940e 114f 	CALL SUBOPT_0xC
                 ; 0001 0052   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
0003d7 940e 114f 	CALL SUBOPT_0xC
0003d9 30e0      	CPI  R30,0
0003da f4c9      	BRNE _0x20003
                 ; 0001 0053     for(index = 0; index < PAGESIZE; index++){
                +
0003db e000     +LDI R16 , LOW ( 0 )
0003dc e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x20005:
                +
0003dd 3000     +CPI R16 , LOW ( 256 )
0003de e0e1     +LDI R30 , HIGH ( 256 )
0003df 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
0003e0 f478      	BRSH _0x20006
                 ; 0001 0054       dataPage[index] = ReadFlashByte(flashStartAdr + index);
0003e1 01f8      	MOVW R30,R16
0003e2 81aa      	LDD  R26,Y+2
0003e3 81bb      	LDD  R27,Y+2+1
0003e4 0fea      	ADD  R30,R26
0003e5 1ffb      	ADC  R31,R27
0003e6 93ff      	PUSH R31
0003e7 93ef      	PUSH R30
0003e8 940e 1154 	CALL SUBOPT_0xD
0003ea 91af      	POP  R26
0003eb 91bf      	POP  R27
0003ec 93ec      	ST   X,R30
                 ; 0001 0055     }
                +
0003ed 5f0f     +SUBI R16 , LOW ( - 1 )
0003ee 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0003ef cfed      	RJMP _0x20005
                 _0x20006:
                 ; 0001 0056     return TRUE;                            // Return TRUE if valid page address
0003f0 e0e1      	LDI  R30,LOW(1)
0003f1 8119      	LDD  R17,Y+1
0003f2 8108      	LDD  R16,Y+0
0003f3 c501      	RJMP _0x20C000B
                 ; 0001 0057   }
                 ; 0001 0058   else{
                 _0x20003:
                 ; 0001 0059     return FALSE;                           // Return FALSE if not valid page address
0003f4 e0e0      	LDI  R30,LOW(0)
0003f5 8119      	LDD  R17,Y+1
0003f6 8108      	LDD  R16,Y+0
0003f7 c4fd      	RJMP _0x20C000B
                 ; 0001 005A   }
                 ; 0001 005B }
                 ; .FEND
                 ;unsigned char ReadFlashBytes(MyAddressType flashStartAdr, unsigned char *dataPage, unsigned int length){
                 ; 0001 005C unsigned char ReadFlashBytes(MyAddressType flashStartAdr, unsigned char *dataPage, unsigned int length){
                 _ReadFlashBytes:
                 ; .FSTART _ReadFlashBytes
                 ; 0001 005D   	unsigned int index;
                 ; 0001 005E   	flashStartAdr+=ADR_LIMIT_LOW;
0003f8 940e 114a 	CALL SUBOPT_0xB
                 ;	flashStartAdr -> Y+6
                 ;	*dataPage -> Y+4
                 ;	length -> Y+2
                 ;	index -> R16,R17
0003fa 940e 115f 	CALL SUBOPT_0xE
                +
0003fc 50e0     +SUBI R30 , LOW ( - 57344 )
0003fd 42f0     +SBCI R31 , HIGH ( - 57344 )
0003fe 4f6f     +SBCI R22 , BYTE3 ( - 57344 )
0003ff 4f7f     +SBCI R23 , BYTE4 ( - 57344 )
                 	__ADDD1N 57344
000400 940e 1164 	CALL SUBOPT_0xF
                 ; 0001 005F     for(index = 0; index < length; index++){
                +
000402 e000     +LDI R16 , LOW ( 0 )
000403 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x20009:
000404 81ea      	LDD  R30,Y+2
000405 81fb      	LDD  R31,Y+2+1
000406 170e      	CP   R16,R30
000407 071f      	CPC  R17,R31
000408 f4b8      	BRSH _0x2000A
                 ; 0001 0060       dataPage[index] = ReadFlashByte(flashStartAdr + index);
000409 01f8      	MOVW R30,R16
00040a 81ac      	LDD  R26,Y+4
00040b 81bd      	LDD  R27,Y+4+1
00040c 0fea      	ADD  R30,R26
00040d 1ffb      	ADC  R31,R27
00040e 93ff      	PUSH R31
00040f 93ef      	PUSH R30
000410 01f8      	MOVW R30,R16
                +
000411 81ae     +LDD R26 , Y + 6
000412 81bf     +LDD R27 , Y + 6 + 1
000413 8588     +LDD R24 , Y + 6 + 2
000414 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
000415 2766      	CLR  R22
000416 2777      	CLR  R23
000417 940e 1329 	CALL __ADDD21
000419 dfb0      	RCALL _ReadFlashByte
00041a 91af      	POP  R26
00041b 91bf      	POP  R27
00041c 93ec      	ST   X,R30
                 ; 0001 0061     }
                +
00041d 5f0f     +SUBI R16 , LOW ( - 1 )
00041e 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00041f cfe4      	RJMP _0x20009
                 _0x2000A:
                 ; 0001 0062     return TRUE;                            // Return TRUE if valid page address
000420 e0e1      	LDI  R30,LOW(1)
000421 8119      	LDD  R17,Y+1
000422 8108      	LDD  R16,Y+0
000423 c39a      	RJMP _0x20C000E
                 ; 0001 0063 }
                 ; .FEND
                 ;unsigned char VerifyFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0001 0064 unsigned char VerifyFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 _VerifyFlashPage:
                 ; .FSTART _VerifyFlashPage
                 ; 0001 0065   unsigned int index;
                 ; 0001 0066   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
000424 940e 114a 	CALL SUBOPT_0xB
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
000426 940e 114f 	CALL SUBOPT_0xC
000428 30e0      	CPI  R30,0
000429 f4f1      	BRNE _0x2000B
                 ; 0001 0067     for(index = 0; index < PAGESIZE; index++){
                +
00042a e000     +LDI R16 , LOW ( 0 )
00042b e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x2000D:
                +
00042c 3000     +CPI R16 , LOW ( 256 )
00042d e0e1     +LDI R30 , HIGH ( 256 )
00042e 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
00042f f4a0      	BRSH _0x2000E
                 ; 0001 0068       if(dataPage[index] != ReadFlashByte(flashStartAdr + index))
000430 01f8      	MOVW R30,R16
000431 81aa      	LDD  R26,Y+2
000432 81bb      	LDD  R27,Y+2+1
000433 0fae      	ADD  R26,R30
000434 1fbf      	ADC  R27,R31
000435 91ec      	LD   R30,X
000436 93ef      	PUSH R30
000437 940e 1154 	CALL SUBOPT_0xD
000439 91af      	POP  R26
00043a 17ea      	CP   R30,R26
00043b f029      	BREQ _0x2000F
                 ; 0001 0069       {
                 ; 0001 006A         PORTC.6=0;
00043c 98ae      	CBI  0x15,6
                 ; 0001 006B         return FALSE;
00043d e0e0      	LDI  R30,LOW(0)
00043e 8119      	LDD  R17,Y+1
00043f 8108      	LDD  R16,Y+0
000440 c4b4      	RJMP _0x20C000B
                 ; 0001 006C       }
                 ; 0001 006D     }
                 _0x2000F:
                +
000441 5f0f     +SUBI R16 , LOW ( - 1 )
000442 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
000443 cfe8      	RJMP _0x2000D
                 _0x2000E:
                 ; 0001 006E     return TRUE;                            // Return TRUE if valid page address
000444 e0e1      	LDI  R30,LOW(1)
000445 8119      	LDD  R17,Y+1
000446 8108      	LDD  R16,Y+0
000447 c4ad      	RJMP _0x20C000B
                 ; 0001 006F   }
                 ; 0001 0070   else{
                 _0x2000B:
                 ; 0001 0071     PORTC.7=0;
000448 98af      	CBI  0x15,7
                 ; 0001 0072     return FALSE;                           // Return FALSE if not valid page address
000449 e0e0      	LDI  R30,LOW(0)
00044a 8119      	LDD  R17,Y+1
00044b 8108      	LDD  R16,Y+0
00044c c4a8      	RJMP _0x20C000B
                 ; 0001 0073   }
                 ; 0001 0074 }
                 ; .FEND
                 ;unsigned char WriteFlashBytes(MyAddressType flashAdr, unsigned char *data, unsigned int length)
                 ; 0001 0076 {
                 _WriteFlashBytes:
                 ; .FSTART _WriteFlashBytes
                 ; 0001 0077     unsigned char tempBuffer[PAGESIZE];
                 ; 0001 0078     MyAddressType flashAdrStart,flashAdrNext;
                 ; 0001 0079     unsigned int lengthStart,lengthIndex;                //length=0x20
                 ; 0001 007A     while(length)
00044d 93ba      	ST   -Y,R27
00044e 93aa      	ST   -Y,R26
00044f 9728      	SBIW R28,8
000450 50d1      	SUBI R29,1
000451 940e 1462 	CALL __SAVELOCR4
                 ;	flashAdr -> Y+272
                 ;	*data -> Y+270
                 ;	length -> Y+268
                 ;	tempBuffer -> Y+12
                 ;	flashAdrStart -> Y+8
                 ;	flashAdrNext -> Y+4
                 ;	lengthStart -> R16,R17
                 ;	lengthIndex -> R18,R19
                 _0x20015:
000453 940e 1169 	CALL SUBOPT_0x10
000455 9730      	SBIW R30,0
000456 f409      	BRNE PC+2
000457 c091      	RJMP _0x20017
                 ; 0001 007B     {
                 ; 0001 007C         flashAdrStart= flashAdr-(flashAdr%PAGESIZE);//0x1F0-(0x1F0%0x100)=0x0100                        //
000458 940e 1170 	CALL SUBOPT_0x11
00045a 940e 117d 	CALL SUBOPT_0x12
00045c 940e 1333 	CALL __SUBD21
                +
00045e 87a8     +STD Y + 8 , R26
00045f 87b9     +STD Y + 8 + 1 , R27
000460 878a     +STD Y + 8 + 2 , R24
000461 879b     +STD Y + 8 + 3 , R25
                 	__PUTD2S 8
                 ; 0001 007D         flashAdrNext = flashAdrStart+PAGESIZE;          //0x0100+0x100=0x200
000462 940e 1186 	CALL SUBOPT_0x13
                +
000464 50e0     +SUBI R30 , LOW ( - 256 )
000465 4fff     +SBCI R31 , HIGH ( - 256 )
000466 4f6f     +SBCI R22 , BYTE3 ( - 256 )
000467 4f7f     +SBCI R23 , BYTE4 ( - 256 )
                 	__ADDD1N 256
000468 940e 118b 	CALL SUBOPT_0x14
                 ; 0001 007E         if((flashAdrNext - flashAdr) >= length)    //enough space case
00046a 940e 117d 	CALL SUBOPT_0x12
00046c 940e 114f 	CALL SUBOPT_0xC
00046e 940e 132e 	CALL __SUBD12
000470 01df      	MOVW R26,R30
000471 01cb      	MOVW R24,R22
000472 940e 1169 	CALL SUBOPT_0x10
000474 2766      	CLR  R22
000475 2777      	CLR  R23
000476 940e 145b 	CALL __CPD21
000478 f060      	BRLO _0x20018
                 ; 0001 007F         {
                 ; 0001 0080            lengthStart=length;
                +
000479 01fe     +MOVW R30 , R28
00047a 5fe4     +SUBI R30 , LOW ( - 268 )
00047b 4ffe     +SBCI R31 , HIGH ( - 268 )
00047c 9101     +LD R16 , Z +
00047d 8110     +LD R17 , Z
                 	__GETWRSX 16,17,268
                 ; 0001 0081            length=0;
00047e e0e0      	LDI  R30,LOW(0)
                +
00047f 01de     +MOVW R26 , R28
000480 5fa4     +SUBI R26 , LOW ( - 268 )
000481 4fbe     +SBCI R27 , HIGH ( - 268 )
000482 93ed     +ST X + , R30
000483 93ec     +ST X , R30
                 	__CLRW1SX 268
                 ; 0001 0082         }
                 ; 0001 0083         else                                   //(0x200-0x1F0)<0x20
000484 c014      	RJMP _0x20019
                 _0x20018:
                 ; 0001 0084         {
                 ; 0001 0085            lengthStart=(flashAdrNext - flashAdr);        //len1=0x200-0x1F0=0x10
                +
000485 01de     +MOVW R26 , R28
000486 5fa0     +SUBI R26 , LOW ( - 272 )
000487 4fbe     +SBCI R27 , HIGH ( - 272 )
000488 900d     +LD R0 , X +
000489 91bc     +LD R27 , X
00048a 2da0     +MOV R26 , R0
                 	__GETW2SX 272
00048b 81ec      	LDD  R30,Y+4
00048c 81fd      	LDD  R31,Y+4+1
00048d 1bea      	SUB  R30,R26
00048e 0bfb      	SBC  R31,R27
00048f 018f      	MOVW R16,R30
                 ; 0001 0086            length-=lengthStart;                         //len2=0x20-0x10=0x10
000490 940e 1169 	CALL SUBOPT_0x10
000492 1be0      	SUB  R30,R16
000493 0bf1      	SBC  R31,R17
                +
000494 01de     +MOVW R26 , R28
000495 5fa4     +SUBI R26 , LOW ( - 268 )
000496 4fbe     +SBCI R27 , HIGH ( - 268 )
000497 93ed     +ST X + , R30
000498 93fc     +ST X , R31
                 	__PUTW1SX 268
                 ; 0001 0087         }
                 _0x20019:
                 ; 0001 0088         if(ReadFlashPage(flashAdrStart,tempBuffer)==FALSE) //read flash page to tempBuffer
000499 940e 1186 	CALL SUBOPT_0x13
00049b 940e 1404 	CALL __PUTPARD1
00049d 01de      	MOVW R26,R28
00049e 9650      	ADIW R26,16
00049f df33      	RCALL _ReadFlashPage
0004a0 30e0      	CPI  R30,0
0004a1 f419      	BRNE _0x2001A
                 ; 0001 0089         {
                 ; 0001 008A             PORTC.3=0;
0004a2 98ab      	CBI  0x15,3
                 ; 0001 008B             return FALSE;
0004a3 e0e0      	LDI  R30,LOW(0)
0004a4 c045      	RJMP _0x20C0012
                 ; 0001 008C         }
                 ; 0001 008D         for(lengthIndex=(flashAdr%PAGESIZE);lengthIndex<((flashAdr%PAGESIZE)+lengthStart);lengthIndex++)
                 _0x2001A:
                +
0004a5 01fe     +MOVW R30 , R28
0004a6 5fe0     +SUBI R30 , LOW ( - 272 )
0004a7 4ffe     +SBCI R31 , HIGH ( - 272 )
0004a8 9001     +LD R0 , Z +
0004a9 81f0     +LD R31 , Z
0004aa 2de0     +MOV R30 , R0
                 	__GETW1SX 272
0004ab 70f0      	ANDI R31,HIGH(0xFF)
0004ac 019f      	MOVW R18,R30
                 _0x2001E:
0004ad 940e 1170 	CALL SUBOPT_0x11
0004af 01df      	MOVW R26,R30
0004b0 01cb      	MOVW R24,R22
0004b1 01f8      	MOVW R30,R16
0004b2 940e 1190 	CALL SUBOPT_0x15
0004b4 01d9      	MOVW R26,R18
0004b5 2788      	CLR  R24
0004b6 2799      	CLR  R25
0004b7 940e 145b 	CALL __CPD21
0004b9 f4a8      	BRSH _0x2001F
                 ; 0001 008E         {
                 ; 0001 008F             tempBuffer[lengthIndex]=*data++;
0004ba 01f9      	MOVW R30,R18
0004bb 01de      	MOVW R26,R28
0004bc 961c      	ADIW R26,12
0004bd 0fea      	ADD  R30,R26
0004be 1ffb      	ADC  R31,R27
0004bf 010f      	MOVW R0,R30
0004c0 01de      	MOVW R26,R28
0004c1 5fa2      	SUBI R26,LOW(-(270))
0004c2 4fbe      	SBCI R27,HIGH(-(270))
0004c3 91ed      	LD   R30,X+
0004c4 91fd      	LD   R31,X+
0004c5 9631      	ADIW R30,1
0004c6 93fe      	ST   -X,R31
0004c7 93ee      	ST   -X,R30
0004c8 9731      	SBIW R30,1
0004c9 81e0      	LD   R30,Z
0004ca 01d0      	MOVW R26,R0
0004cb 93ec      	ST   X,R30
                 ; 0001 0090         }
                +
0004cc 5f2f     +SUBI R18 , LOW ( - 1 )
0004cd 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
0004ce cfde      	RJMP _0x2001E
                 _0x2001F:
                 ; 0001 0091         flashAdr=flashAdrNext;
0004cf 940e 114f 	CALL SUBOPT_0xC
                +
0004d1 01de     +MOVW R26 , R28
0004d2 5fa0     +SUBI R26 , LOW ( - 272 )
0004d3 4fbe     +SBCI R27 , HIGH ( - 272 )
0004d4 93ed     +ST X + , R30
0004d5 93fd     +ST X + , R31
0004d6 936d     +ST X + , R22
0004d7 937c     +ST X , R23
                 	__PUTD1SX 272
                 ; 0001 0092         if(WriteFlashPage(flashAdrStart+ADR_LIMIT_LOW,tempBuffer)==FALSE) //write tempBuffer to flash page
0004d8 940e 1186 	CALL SUBOPT_0x13
                +
0004da 50e0     +SUBI R30 , LOW ( - 57344 )
0004db 42f0     +SBCI R31 , HIGH ( - 57344 )
0004dc 4f6f     +SBCI R22 , BYTE3 ( - 57344 )
0004dd 4f7f     +SBCI R23 , BYTE4 ( - 57344 )
                 	__ADDD1N 57344
0004de 940e 1404 	CALL __PUTPARD1
0004e0 01de      	MOVW R26,R28
0004e1 9650      	ADIW R26,16
0004e2 d00c      	RCALL _WriteFlashPage
0004e3 30e0      	CPI  R30,0
0004e4 f419      	BRNE _0x20020
                 ; 0001 0093         {
                 ; 0001 0094             PORTC.4=0;
0004e5 98ac      	CBI  0x15,4
                 ; 0001 0095             return FALSE;
0004e6 e0e0      	LDI  R30,LOW(0)
0004e7 c002      	RJMP _0x20C0012
                 ; 0001 0096         }
                 ; 0001 0097     }
                 _0x20020:
0004e8 cf6a      	RJMP _0x20015
                 _0x20017:
                 ; 0001 0098     return TRUE;
0004e9 e0e1      	LDI  R30,LOW(1)
                 _0x20C0012:
0004ea 940e 1469 	CALL __LOADLOCR4
0004ec 9664      	ADIW R28,20
0004ed 5fdf      	SUBI R29,-1
0004ee 9508      	RET
                 ; 0001 0099 }
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function writes byte data to Flash address flashAddr. Returns FALSE if
                 ;* input address is not valid Flash byte address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0001 009F unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0001 00A0   MyAddressType  pageAdr;
                 ; 0001 00A1   unsigned char eepromInterruptSettings,saveSREG;
                 ; 0001 00A2   flashAddr+=ADR_LIMIT_LOW;
                 ;	flashAddr -> Y+7
                 ;	data -> Y+6
                 ;	pageAdr -> Y+2
                 ;	eepromInterruptSettings -> R17
                 ;	saveSREG -> R16
                 ; 0001 00A3   if( AddressCheck( flashAddr & ~(PAGESIZE-1) )){
                 ; 0001 00A4 
                 ; 0001 00A5     if(ReadFlashByte(flashAddr)==data)
                 ; 0001 00A6     {
                 ; 0001 00A7         PORTC.4=0;
                 ; 0001 00A8         return TRUE;
                 ; 0001 00A9     }
                 ; 0001 00AA     eepromInterruptSettings= EECR & (1<<EERIE); // Stores EEPROM interrupt mask
                 ; 0001 00AB     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
                 ; 0001 00AC     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 ; 0001 00AD     saveSREG=SREG;
                 ; 0001 00AE     #asm("cli")
                 ; 0001 00AF     pageAdr=flashAddr & ~(PAGESIZE-1);      // Gets Flash page address from byte address
                 ; 0001 00B0 
                 ; 0001 00B1     #ifdef __FLASH_RECOVER
                 ; 0001 00B2     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0001 00B3                                             // not contain data for writing
                 ; 0001 00B4     while(EECR & (1<<EEWE));
                 ; 0001 00B5     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0001 00B6     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0001 00B7     FlashBackup.pageNumber = (unsigned int) (pageAdr/PAGESIZE); // Stores page address
                 ; 0001 00B8                                                        // data should be written to
                 ; 0001 00B9     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0001 00BA                                                // contains unwritten data
                 ; 0001 00BB     while(EECR & (1<<EEWE));
                 ; 0001 00BC     #endif
                 ; 0001 00BD 
                 ; 0001 00BE     if(LpmReplaceSpm(flashAddr, data)!=0)         // Fills Flash write buffer
                 ; 0001 00BF     {
                 ; 0001 00C0         _PAGE_WRITE(pageAdr);
                 ; 0001 00C1         PORTC.1=0;
                 ; 0001 00C2     }
                 ; 0001 00C3     else
                 ; 0001 00C4     {
                 ; 0001 00C5         _PAGE_EW(pageAdr);
                 ; 0001 00C6         PORTC.2=0;
                 ; 0001 00C7     }
                 ; 0001 00C8 
                 ; 0001 00C9     #ifdef __FLASH_RECOVER
                 ; 0001 00CA     FlashBackup.status = 0;                 // Indicates that Flash recovery buffer
                 ; 0001 00CB                                             // does not contain unwritten data
                 ; 0001 00CC     while(EECR & (1<<EEWE));
                 ; 0001 00CD     #endif
                 ; 0001 00CE 
                 ; 0001 00CF     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 ; 0001 00D0     SREG=saveSREG;
                 ; 0001 00D1     return TRUE;                            // Return TRUE if address
                 ; 0001 00D2                                             // valid for writing
                 ; 0001 00D3   }
                 ; 0001 00D4   else
                 ; 0001 00D5     return FALSE;                           // Return FALSE if address not
                 ; 0001 00D6                                             // valid for writing
                 ; 0001 00D7 }
                 ;
                 ;/*!
                 ;* The function writes data from array dataPage[] to Flash page address
                 ;* flashStartAdr. The Number of bytes written is depending upon the Flash page
                 ;* size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
                 ;* page address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage)
                 ; 0001 00E0 {
                 _WriteFlashPage:
                 ; .FSTART _WriteFlashPage
                 ; 0001 00E1   unsigned int index;
                 ; 0001 00E2   unsigned char eepromInterruptSettings,saveSREG;
                 ; 0001 00E3   MyAddressType  pageAdr;
                 ; 0001 00E4   flashStartAdr;//+=ADR_LIMIT_LOW;
0004ef 93ba      	ST   -Y,R27
0004f0 93aa      	ST   -Y,R26
0004f1 9724      	SBIW R28,4
0004f2 940e 1462 	CALL __SAVELOCR4
                 ;	flashStartAdr -> Y+10
                 ;	*dataPage -> Y+8
                 ;	index -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	saveSREG -> R18
                 ;	pageAdr -> Y+4
0004f4 940e 1195 	CALL SUBOPT_0x16
                 ; 0001 00E5   if( AddressCheck(flashStartAdr) ){
0004f6 940e 119a 	CALL SUBOPT_0x17
0004f8 d0a0      	RCALL _AddressCheck
0004f9 30e0      	CPI  R30,0
0004fa f409      	BRNE PC+2
0004fb c05d      	RJMP _0x20031
                 ; 0001 00E6     if(eepromBackup(flashStartAdr,PAGESIZE,dataPage)==0)
0004fc 940e 1195 	CALL SUBOPT_0x16
0004fe 940e 1404 	CALL __PUTPARD1
000500 e0e0      	LDI  R30,LOW(256)
000501 e0f1      	LDI  R31,HIGH(256)
000502 93fa      	ST   -Y,R31
000503 93ea      	ST   -Y,R30
000504 85ae      	LDD  R26,Y+14
000505 85bf      	LDD  R27,Y+14+1
000506 d056      	RCALL _eepromBackup
000507 30e0      	CPI  R30,0
000508 f421      	BRNE _0x20032
                 ; 0001 00E7     {
                 ; 0001 00E8         return FALSE;
000509 e0e0      	LDI  R30,LOW(0)
00050a 940e 1469 	CALL __LOADLOCR4
00050c c376      	RJMP _0x20C000C
                 ; 0001 00E9     }
                 ; 0001 00EA     eepromInterruptSettings = EECR & (1<<EERIE); // Stoes EEPROM interrupt mask
                 _0x20032:
00050d b3ec      	IN   R30,0x1C
00050e 70e8      	ANDI R30,LOW(0x8)
00050f 2f3e      	MOV  R19,R30
                 ; 0001 00EB     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
000510 98e3      	CBI  0x1C,3
                 ; 0001 00EC     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 _0x20033:
000511 99e1      	SBIC 0x1C,1
000512 cffe      	RJMP _0x20033
                 ; 0001 00ED     saveSREG=SREG;                          // Save SREG
000513 b72f      	IN   R18,63
                 ; 0001 00EE     #asm("cli")
000514 94f8      	cli
                 ; 0001 00EF 
                 ; 0001 00F0     #ifdef __FLASH_RECOVER
                 ; 0001 00F1     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0001 00F2                                             // not contain data for writing
                 ; 0001 00F3     while(EECR & (1<<EEWE));
                 ; 0001 00F4 
                 ; 0001 00F5     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                 ; 0001 00F6       _WAIT_FOR_SPM();
                 ; 0001 00F7       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0001 00F8     }
                 ; 0001 00F9 
                 ; 0001 00FA     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0001 00FB     FlashBackup.pageNumber=(unsigned int)(flashStartAdr/PAGESIZE);
                 ; 0001 00FC     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0001 00FD                                            // contains unwritten data
                 ; 0001 00FE     while(EECR & (1<<EEWE));
                 ; 0001 00FF     #endif
                 ; 0001 0100 
                 ; 0001 0101     //debug
                 ; 0001 0102     _PAGE_ERASE(flashStartAdr);
000515 940e 119a 	CALL SUBOPT_0x17
000517 01f4      	MOVW R30,R8
000518 9509      	ICALL
                 ; 0001 0103 
                 ; 0001 0104     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                +
000519 e000     +LDI R16 , LOW ( 0 )
00051a e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x20037:
                +
00051b 3000     +CPI R16 , LOW ( 256 )
00051c e0e1     +LDI R30 , HIGH ( 256 )
00051d 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
00051e f4e0      	BRSH _0x20038
                 ; 0001 0105       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
00051f 01f8      	MOVW R30,R16
000520 2766      	CLR  R22
000521 2777      	CLR  R23
000522 940e 1404 	CALL __PUTPARD1
000524 01f8      	MOVW R30,R16
000525 85ac      	LDD  R26,Y+12
000526 85bd      	LDD  R27,Y+12+1
000527 0fae      	ADD  R26,R30
000528 1fbf      	ADC  R27,R31
000529 900c      	LD   R0,X
00052a 2411      	CLR  R1
00052b 9631      	ADIW R30,1
00052c 85ac      	LDD  R26,Y+12
00052d 85bd      	LDD  R27,Y+12+1
00052e 0fae      	ADD  R26,R30
00052f 1fbf      	ADC  R27,R31
000530 91ec      	LD   R30,X
000531 2ffe      	MOV  R31,R30
000532 e0e0      	LDI  R30,0
000533 01d0      	MOVW R26,R0
000534 0fae      	ADD  R26,R30
000535 1fbf      	ADC  R27,R31
000536 01f2      	MOVW R30,R4
000537 9509      	ICALL
                 ; 0001 0106     }
                +
000538 5f0e     +SUBI R16 , LOW ( - 2 )
000539 4f1f     +SBCI R17 , HIGH ( - 2 )
                 	__ADDWRN 16,17,2
00053a cfe0      	RJMP _0x20037
                 _0x20038:
                 ; 0001 0107     _PAGE_WRITE(flashStartAdr);
00053b 940e 119a 	CALL SUBOPT_0x17
00053d 01f3      	MOVW R30,R6
00053e 9509      	ICALL
                 ; 0001 0108     if(VerifyFlashPage(flashStartAdr,dataPage)==FALSE)
00053f 940e 1195 	CALL SUBOPT_0x16
000541 940e 1404 	CALL __PUTPARD1
000543 85ac      	LDD  R26,Y+12
000544 85bd      	LDD  R27,Y+12+1
000545 dede      	RCALL _VerifyFlashPage
000546 30e0      	CPI  R30,0
000547 f421      	BRNE _0x20039
                 ; 0001 0109     {
                 ; 0001 010A       //PORTC.6=0;
                 ; 0001 010B       return FALSE;
000548 e0e0      	LDI  R30,LOW(0)
000549 940e 1469 	CALL __LOADLOCR4
00054b c337      	RJMP _0x20C000C
                 ; 0001 010C     }
                 ; 0001 010D     #ifdef __FLASH_RECOVER
                 ; 0001 010E       FlashBackup.status=0;                 // Inicate that Flash buffer does
                 ; 0001 010F                                             // not contain data for writing
                 ; 0001 0110       while(EECR & (1<<EEWE));
                 ; 0001 0111     #endif
                 ; 0001 0112 
                 ; 0001 0113     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 _0x20039:
00054c b3ec      	IN   R30,0x1C
00054d 2be3      	OR   R30,R19
00054e bbec      	OUT  0x1C,R30
                 ; 0001 0114     SREG=saveSREG;                          // Restore interrupts to SREG
00054f bf2f      	OUT  0x3F,R18
                 ; 0001 0115     _EepromBackup.status=0;
                +
000550 e1a0     +LDI R26 , LOW ( __EepromBackup + ( 6 ) )
000551 e0b0     +LDI R27 , HIGH ( __EepromBackup + ( 6 ) )
                 	__POINTW2MN __EepromBackup,6
000552 e0e0      	LDI  R30,LOW(0)
000553 940e 1437 	CALL __EEPROMWRB
                 ; 0001 0116     return TRUE;                            // Return TRUE if address                                            // vali ...
000555 e0e1      	LDI  R30,LOW(1)
000556 940e 1469 	CALL __LOADLOCR4
000558 c32a      	RJMP _0x20C000C
                 ; 0001 0117   }
                 ; 0001 0118   else
                 _0x20031:
                 ; 0001 0119     return FALSE;                           // Return FALSE if not address not
000559 e0e0      	LDI  R30,LOW(0)
00055a 940e 1469 	CALL __LOADLOCR4
00055c c326      	RJMP _0x20C000C
                 ; 0001 011A                                             // valid for writing
                 ; 0001 011B }
                 ; .FEND
                 ;
                 ;unsigned char eepromBackup(unsigned long flashStartAdr, unsigned int length, unsigned char *data)
                 ; 0001 011E {
                 _eepromBackup:
                 ; .FSTART _eepromBackup
                 ; 0001 011F     _EepromBackup.flashStartAdr=flashStartAdr;
00055d 93ba      	ST   -Y,R27
00055e 93aa      	ST   -Y,R26
                 ;	flashStartAdr -> Y+4
                 ;	length -> Y+2
                 ;	*data -> Y+0
00055f 940e 114f 	CALL SUBOPT_0xC
000561 e0aa      	LDI  R26,LOW(__EepromBackup)
000562 e0b0      	LDI  R27,HIGH(__EepromBackup)
000563 940e 1427 	CALL __EEPROMWRD
                 ; 0001 0120     _EepromBackup.length=length;
                +
000565 e0ae     +LDI R26 , LOW ( __EepromBackup + ( 4 ) )
000566 e0b0     +LDI R27 , HIGH ( __EepromBackup + ( 4 ) )
                 	__POINTW2MN __EepromBackup,4
000567 81ea      	LDD  R30,Y+2
000568 81fb      	LDD  R31,Y+2+1
000569 940e 142f 	CALL __EEPROMWRW
                 ; 0001 0121     for(;length>0;length--)
                 _0x2003C:
00056b 81aa      	LDD  R26,Y+2
00056c 81bb      	LDD  R27,Y+2+1
00056d 940e 144c 	CALL __CPW02
00056f f518      	BRSH _0x2003D
                 ; 0001 0122     {
                 ; 0001 0123          _EepromBackup.data[length-1]=data[length-1];
                +
000570 e1a1     +LDI R26 , LOW ( __EepromBackup + ( 7 ) )
000571 e0b0     +LDI R27 , HIGH ( __EepromBackup + ( 7 ) )
                 	__POINTW2MN __EepromBackup,7
000572 81ea      	LDD  R30,Y+2
000573 81fb      	LDD  R31,Y+2+1
000574 9731      	SBIW R30,1
000575 0fea      	ADD  R30,R26
000576 1ffb      	ADC  R31,R27
000577 010f      	MOVW R0,R30
000578 940e 119f 	CALL SUBOPT_0x18
00057a 01d0      	MOVW R26,R0
00057b 940e 1437 	CALL __EEPROMWRB
                 ; 0001 0124          if(_EepromBackup.data[length-1]!=data[length-1])
                +
00057d e1a1     +LDI R26 , LOW ( __EepromBackup + ( 7 ) )
00057e e0b0     +LDI R27 , HIGH ( __EepromBackup + ( 7 ) )
                 	__POINTW2MN __EepromBackup,7
00057f 81ea      	LDD  R30,Y+2
000580 81fb      	LDD  R31,Y+2+1
000581 9731      	SBIW R30,1
000582 0fae      	ADD  R26,R30
000583 1fbf      	ADC  R27,R31
000584 940e 141b 	CALL __EEPROMRDB
000586 2e0e      	MOV  R0,R30
000587 940e 119f 	CALL SUBOPT_0x18
000589 15e0      	CP   R30,R0
00058a f011      	BREQ _0x2003E
                 ; 0001 0125          {
                 ; 0001 0126             return FALSE;//error during backup on eeprom
00058b e0e0      	LDI  R30,LOW(0)
00058c c368      	RJMP _0x20C000B
                 ; 0001 0127          }
                 ; 0001 0128     }
                 _0x2003E:
00058d 81ea      	LDD  R30,Y+2
00058e 81fb      	LDD  R31,Y+2+1
00058f 9731      	SBIW R30,1
000590 83ea      	STD  Y+2,R30
000591 83fb      	STD  Y+2+1,R31
000592 cfd8      	RJMP _0x2003C
                 _0x2003D:
                 ; 0001 0129     _EepromBackup.status=1;//1=ready to move to flash
                +
000593 e1a0     +LDI R26 , LOW ( __EepromBackup + ( 6 ) )
000594 e0b0     +LDI R27 , HIGH ( __EepromBackup + ( 6 ) )
                 	__POINTW2MN __EepromBackup,6
000595 e0e1      	LDI  R30,LOW(1)
000596 940e 1437 	CALL __EEPROMWRB
                 ; 0001 012A     return TRUE;
000598 c35c      	RJMP _0x20C000B
                 ; 0001 012B }
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function checks if global variable FlashBackup.status indicates that Flash recovery
                 ;* buffer contains data that needs to be written to Flash. Writes data from
                 ;* Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
                 ;* This function should be called at program startup if FLASH recovery option
                 ;* is enabeled.
                 ;**/
                 ;unsigned char RecoverFlash(){
                 ; 0001 0134 unsigned char RecoverFlash(){
                 ; 0001 0135 #ifdef __FLASH_RECOVER
                 ; 0001 0136   unsigned int index;
                 ; 0001 0137   unsigned long flashStartAdr = (MyAddressType)FlashBackup.pageNumber * PAGESIZE;
                 ; 0001 0138   if(FlashBackup.status == FLASH_BUFFER_FULL_ID){ // Checks if Flash recovery
                 ; 0001 0139                                                   //  buffer contains data
                 ; 0001 013A 
                 ; 0001 013B     for(index=0; index < PAGESIZE; index+=2){     // Writes to Flash write buffer
                 ; 0001 013C         _WAIT_FOR_SPM();
                 ; 0001 013D         _FILL_TEMP_WORD( index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER+index)) );
                 ; 0001 013E     }
                 ; 0001 013F 
                 ; 0001 0140 
                 ; 0001 0141     //WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
                 ; 0001 0142     _WAIT_FOR_SPM();
                 ; 0001 0143     _PAGE_ERASE( flashStartAdr );
                 ; 0001 0144     _WAIT_FOR_SPM();
                 ; 0001 0145     _PAGE_WRITE( flashStartAdr );
                 ; 0001 0146     _WAIT_FOR_SPM();
                 ; 0001 0147     _ENABLE_RWW_SECTION();
                 ; 0001 0148     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0001 0149                                             // not contain data for writing
                 ; 0001 014A     while(EECR & (1<<EEWE));
                 ; 0001 014B     return TRUE;                            // Returns TRUE if recovery has
                 ; 0001 014C                                             // taken place
                 ; 0001 014D   }
                 ; 0001 014E #endif
                 ; 0001 014F   return FALSE;
                 ; 0001 0150 }
                 ;
                 ;
                 ;/*!
                 ;* The function checks if input argument is a valid Flash page address for
                 ;* writing. Returns TRUE only if:
                 ;* - Address points to the beginning of a Flash page
                 ;* - Address is within the limits defined in Self_programming.h
                 ;* - Address is not equal to page address used for buffring by the Flash recovery
                 ;*   functions (if enabled).
                 ;* Returns FALSE else.
                 ;**/
                 ;unsigned char AddressCheck(MyAddressType flashAdr){
                 ; 0001 015C unsigned char AddressCheck(MyAddressType flashAdr){
                 _AddressCheck:
                 ; .FSTART _AddressCheck
                 ; 0001 015D   #ifdef __FLASH_RECOVER
                 ; 0001 015E   // The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
                 ; 0001 015F   if( (flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
                 ; 0001 0160       (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE-1)) )
                 ; 0001 0161     return TRUE;                            // Address is a valid page address
                 ; 0001 0162   else
                 ; 0001 0163     return FALSE;                           // Address is not a valid page address
                 ; 0001 0164   #else
                 ; 0001 0165   if((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE-1) ) )
000599 940e 1409 	CALL __PUTPARD2
                 ;	flashAdr -> Y+0
00059b 940e 13ff 	CALL __GETD2S0
                +
00059d 30a0     +CPI R26 , LOW ( 0xE000 )
00059e eee0     +LDI R30 , HIGH ( 0xE000 )
00059f 07be     +CPC R27 , R30
0005a0 e0e0     +LDI R30 , BYTE3 ( 0xE000 )
0005a1 078e     +CPC R24 , R30
0005a2 e0e0     +LDI R30 , BYTE4 ( 0xE000 )
0005a3 079e     +CPC R25 , R30
                 	__CPD2N 0xE000
0005a4 f060      	BRLO _0x20040
                +
0005a5 30a0     +CPI R26 , LOW ( 0x1E000 )
0005a6 eee0     +LDI R30 , HIGH ( 0x1E000 )
0005a7 07be     +CPC R27 , R30
0005a8 e0e1     +LDI R30 , BYTE3 ( 0x1E000 )
0005a9 078e     +CPC R24 , R30
0005aa e0e0     +LDI R30 , BYTE4 ( 0x1E000 )
0005ab 079e     +CPC R25 , R30
                 	__CPD2N 0x1E000
0005ac f420      	BRSH _0x20040
0005ad 940e 1147 	CALL SUBOPT_0xA
0005af 30e0      	CPI  R30,0
0005b0 f009      	BREQ _0x20041
                 _0x20040:
0005b1 c002      	RJMP _0x2003F
                 _0x20041:
                 ; 0001 0166     return TRUE;                            // Address is a valid page address
0005b2 e0e1      	LDI  R30,LOW(1)
0005b3 c001      	RJMP _0x20C0011
                 ; 0001 0167   else
                 _0x2003F:
                 ; 0001 0168     return FALSE;                           // Address is not a valid page address
0005b4 e0e0      	LDI  R30,LOW(0)
                 ; 0001 0169   #endif
                 ; 0001 016A }
                 _0x20C0011:
0005b5 9624      	ADIW R28,4
0005b6 9508      	RET
                 ; .FEND
                 ;
                 ;
                 ;/*!
                 ;* The function reads Flash page given by flashAddr, replaces one byte given by
                 ;* flashAddr with data, and stores entire page in Flash temporary buffer.
                 ;**/
                 ;unsigned char LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0001 0171 unsigned char LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0001 0172 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0001 0173     unsigned int index, oddByte, pcWord;
                 ; 0001 0174     unsigned char onlyWrite=1;
                 ; 0001 0175     MyAddressType  pageAdr;
                 ; 0001 0176     oddByte=(unsigned char)flashAddr & 1;
                 ;	flashAddr -> Y+12
                 ;	data -> Y+11
                 ;	index -> R16,R17
                 ;	oddByte -> R18,R19
                 ;	pcWord -> R20,R21
                 ;	onlyWrite -> Y+10
                 ;	pageAdr -> Y+6
                 ; 0001 0177     pcWord=(unsigned int)flashAddr & (PAGESIZE-2); // Used when writing FLASH temp buffer
                 ; 0001 0178     pageAdr=flashAddr & ~(PAGESIZE-1);        // Get FLASH page address from byte address
                 ; 0001 0179     //_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0001 017A     for(index=0; index < PAGESIZE; index+=2){
                 ; 0001 017B         if(index==pcWord){
                 ; 0001 017C           if(oddByte){
                 ; 0001 017D             _FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0001 017E           }                                     // Write odd byte in temporary buffer
                 ; 0001 017F           else{
                 ; 0001 0180             _FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0001 0181           }                                     // Write even byte in temporary buffer
                 ; 0001 0182           if(((*((MyFlashCharPointer)flashAddr))&0xFF)!=0xFF)
                 ; 0001 0183                 onlyWrite=0;
                 ; 0001 0184         }
                 ; 0001 0185         else{
                 ; 0001 0186           _FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0001 0187           //if(*((MyFlashIntPointer)(pageAdr+index)) != 0xFFFF)
                 ; 0001 0188                 //onlyWrite=0;
                 ; 0001 0189         }                                       // Write Flash word directly to temporary buffer
                 ; 0001 018A     }
                 ; 0001 018B     return onlyWrite;
                 ; 0001 018C //#pragma diag_default=Pe1053 // Back to default.
                 ; 0001 018D }
                 ;/*----------------------------------------------------------------------------/
                 ;/  Petit FatFs - FAT file system module  R0.02                 (C)ChaN, 2009
                 ;/-----------------------------------------------------------------------------/
                 ;/ Petit FatFs module is an open source software to implement FAT file system to
                 ;/ small embedded systems. This is a free software and is opened for education,
                 ;/ research and commercial developments under license policy of following trems.
                 ;/
                 ;/  Copyright (C) 2009, ChaN, all right reserved.
                 ;/
                 ;/ * The Petit FatFs module is a free software and there is NO WARRANTY.
                 ;/ * No restriction on use. You can use, modify and redistribute it for
                 ;/   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
                 ;/ * Redistributions of source code must retain the above copyright notice.
                 ;/
                 ;/-----------------------------------------------------------------------------/
                 ;/ Jun 15,'09  R0.01a  First release. (Branched from FatFs R0.07b.)
                 ;/
                 ;/ Dec 14,'09  R0.02   Added multiple code page support.
                 ;/                     Added write funciton.
                 ;/                     Changed stream read mode interface.
                 ;/----------------------------------------------------------------------------*/
                 ;
                 ;#include "pff.h"		/* Petit FatFs configurations and declarations */
                 ;#include "diskio.h"		/* Declarations of low level disk I/O functions */
                 ;
                 ;
                 ;/*--------------------------------------------------------------------------
                 ;
                 ;   Private Functions
                 ;
                 ;---------------------------------------------------------------------------*/
                 ;
                 ;static
                 ;FATFS *FatFs;	/* Pointer to the file system object (logical drive) */
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* String functions                                                      */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;/* Fill memory */
                 ;static
                 ;void mem_set (void* dst, int val, int cnt) {
                 ; 0002 002C void mem_set (void* dst, int val, int cnt) {
                 
                 	.CSEG
                 _mem_set_G002:
                 ; .FSTART _mem_set_G002
                 ; 0002 002D 	char *d = (char*)dst;
                 ; 0002 002E 	while (cnt--) *d++ = (char)val;
0005b7 940e 114a 	CALL SUBOPT_0xB
                 ;	*dst -> Y+6
                 ;	val -> Y+4
                 ;	cnt -> Y+2
                 ;	*d -> R16,R17
                +
0005b9 810e     +LDD R16 , Y + 6
0005ba 811f     +LDD R17 , Y + 6 + 1
                 	__GETWRS 16,17,6
                 _0x40003:
0005bb 81ea      	LDD  R30,Y+2
0005bc 81fb      	LDD  R31,Y+2+1
0005bd 9731      	SBIW R30,1
0005be 83ea      	STD  Y+2,R30
0005bf 83fb      	STD  Y+2+1,R31
0005c0 9631      	ADIW R30,1
0005c1 f049      	BREQ _0x40005
0005c2 931f      	PUSH R17
0005c3 930f      	PUSH R16
                +
0005c4 5f0f     +SUBI R16 , LOW ( - 1 )
0005c5 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0005c6 81ec      	LDD  R30,Y+4
0005c7 91af      	POP  R26
0005c8 91bf      	POP  R27
0005c9 93ec      	ST   X,R30
0005ca cff0      	RJMP _0x40003
                 _0x40005:
                 ; 0002 002F }
0005cb 8119      	LDD  R17,Y+1
0005cc 8108      	LDD  R16,Y+0
0005cd c327      	RJMP _0x20C000B
                 ; .FEND
                 ;
                 ;/* Compare memory to memory */
                 ;static
                 ;int mem_cmp (const void* dst, const void* src, int cnt) {
                 ; 0002 0033 int mem_cmp (const void* dst, const void* src, int cnt) {
                 _mem_cmp_G002:
                 ; .FSTART _mem_cmp_G002
                 ; 0002 0034 	const char *d = (const char *)dst, *s = (const char *)src;
                 ; 0002 0035 	int r = 0;
                 ; 0002 0036 	while (cnt-- && (r = *d++ - *s++) == 0) ;
0005ce 93ba      	ST   -Y,R27
0005cf 93aa      	ST   -Y,R26
0005d0 940e 1460 	CALL __SAVELOCR6
                 ;	*dst -> Y+10
                 ;	*src -> Y+8
                 ;	cnt -> Y+6
                 ;	*d -> R16,R17
                 ;	*s -> R18,R19
                 ;	r -> R20,R21
                +
0005d2 850a     +LDD R16 , Y + 10
0005d3 851b     +LDD R17 , Y + 10 + 1
                 	__GETWRS 16,17,10
                +
0005d4 8528     +LDD R18 , Y + 8
0005d5 8539     +LDD R19 , Y + 8 + 1
                 	__GETWRS 18,19,8
                +
0005d6 e040     +LDI R20 , LOW ( 0 )
0005d7 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 _0x40006:
0005d8 81ee      	LDD  R30,Y+6
0005d9 81ff      	LDD  R31,Y+6+1
0005da 9731      	SBIW R30,1
0005db 83ee      	STD  Y+6,R30
0005dc 83ff      	STD  Y+6+1,R31
0005dd 9631      	ADIW R30,1
0005de f081      	BREQ _0x40009
0005df 01d8      	MOVW R26,R16
                +
0005e0 5f0f     +SUBI R16 , LOW ( - 1 )
0005e1 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0005e2 900c      	LD   R0,X
0005e3 2411      	CLR  R1
0005e4 01d9      	MOVW R26,R18
                +
0005e5 5f2f     +SUBI R18 , LOW ( - 1 )
0005e6 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
0005e7 91ac      	LD   R26,X
0005e8 27bb      	CLR  R27
0005e9 01f0      	MOVW R30,R0
0005ea 1bea      	SUB  R30,R26
0005eb 0bfb      	SBC  R31,R27
0005ec 01af      	MOVW R20,R30
0005ed 9730      	SBIW R30,0
0005ee f009      	BREQ _0x4000A
                 _0x40009:
0005ef c001      	RJMP _0x40008
                 _0x4000A:
0005f0 cfe7      	RJMP _0x40006
                 _0x40008:
                 ; 0002 0037 	return r;
0005f1 01fa      	MOVW R30,R20
0005f2 940e 1467 	CALL __LOADLOCR6
0005f4 962c      	ADIW R28,12
0005f5 9508      	RET
                 ; 0002 0038 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* FAT access - Read value of a FAT entry                                */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;CLUST get_fat (	/* 1:IO error, Else:Cluster status */
                 ; 0002 0042 	CLUST clst	/* Cluster# to get the link information */
                 ; 0002 0043 )
                 ; 0002 0044 {
                 _get_fat_G002:
                 ; .FSTART _get_fat_G002
                 ; 0002 0045 	WORD wc, bc, ofs;
                 ; 0002 0046 	BYTE buf[4];
                 ; 0002 0047 	FATFS *fs = FatFs;
                 ; 0002 0048 
                 ; 0002 0049 
                 ; 0002 004A 	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
0005f6 940e 1409 	CALL __PUTPARD2
0005f8 9726      	SBIW R28,6
0005f9 940e 1460 	CALL __SAVELOCR6
                 ;	clst -> Y+12
                 ;	wc -> R16,R17
                 ;	bc -> R18,R19
                 ;	ofs -> R20,R21
                 ;	buf -> Y+8
                 ;	*fs -> Y+6
0005fb 940e 11a8 	CALL SUBOPT_0x19
0005fd 83ee      	STD  Y+6,R30
0005fe 83ff      	STD  Y+6+1,R31
0005ff 940e 11ad 	CALL SUBOPT_0x1A
000601 940e 11b2 	CALL SUBOPT_0x1B
000603 f050      	BRLO _0x4000C
000604 81ae      	LDD  R26,Y+6
000605 81bf      	LDD  R27,Y+6+1
000606 9618      	ADIW R26,8
000607 940e 13d3 	CALL __GETD1P
000609 940e 11ad 	CALL SUBOPT_0x1A
00060b 940e 145b 	CALL __CPD21
00060d f008      	BRLO _0x4000B
                 _0x4000C:
                 ; 0002 004B 		return 1;
00060e c0a2      	RJMP _0x20C0010
                 ; 0002 004C 
                 ; 0002 004D 	switch (fs->fs_type) {
                 _0x4000B:
00060f 81ae      	LDD  R26,Y+6
000610 81bf      	LDD  R27,Y+6+1
000611 91ec      	LD   R30,X
000612 e0f0      	LDI  R31,0
                 ; 0002 004E 	case FS_FAT12 :
000613 30e1      	CPI  R30,LOW(0x1)
000614 e0a0      	LDI  R26,HIGH(0x1)
000615 07fa      	CPC  R31,R26
000616 f009      	BREQ PC+2
000617 c049      	RJMP _0x40011
                 ; 0002 004F 		bc = (WORD)clst; bc += bc / 2;
                +
000618 852c     +LDD R18 , Y + 12
000619 853d     +LDD R19 , Y + 12 + 1
                 	__GETWRS 18,19,12
00061a 01f9      	MOVW R30,R18
00061b 95f6      	LSR  R31
00061c 95e7      	ROR  R30
                +
00061d 0f2e     +ADD R18 , R30
00061e 1f3f     +ADC R19 , R31
                 	__ADDWRR 18,19,30,31
                 ; 0002 0050 		ofs = bc % 512; bc /= 512;
00061f 01f9      	MOVW R30,R18
000620 70f1      	ANDI R31,HIGH(0x1FF)
000621 01af      	MOVW R20,R30
000622 01d9      	MOVW R26,R18
000623 e0e0      	LDI  R30,LOW(512)
000624 e0f2      	LDI  R31,HIGH(512)
000625 940e 1393 	CALL __DIVW21U
000627 019f      	MOVW R18,R30
                 ; 0002 0051 		if (ofs != 511) {
000628 efef      	LDI  R30,LOW(511)
000629 e0f1      	LDI  R31,HIGH(511)
00062a 17e4      	CP   R30,R20
00062b 07f5      	CPC  R31,R21
00062c f059      	BREQ _0x40012
                 ; 0002 0052 			if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
00062d 940e 11ba 	CALL SUBOPT_0x1C
00062f 940e 1404 	CALL __PUTPARD1
000631 935a      	ST   -Y,R21
000632 934a      	ST   -Y,R20
000633 940e 11c6 	CALL SUBOPT_0x1D
000635 f009      	BREQ _0x40013
000636 c07a      	RJMP _0x40010
                 ; 0002 0053 		} else {
                 _0x40013:
000637 c01b      	RJMP _0x40014
                 _0x40012:
                 ; 0002 0054 			if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
000638 940e 11ba 	CALL SUBOPT_0x1C
00063a 940e 1404 	CALL __PUTPARD1
00063c efef      	LDI  R30,LOW(511)
00063d e0f1      	LDI  R31,HIGH(511)
00063e 940e 11cc 	CALL SUBOPT_0x1E
000640 f009      	BREQ _0x40015
000641 c06f      	RJMP _0x40010
                 ; 0002 0055 			if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
                 _0x40015:
000642 01fe      	MOVW R30,R28
000643 9639      	ADIW R30,9
000644 940e 11d4 	CALL SUBOPT_0x1F
000646 01f9      	MOVW R30,R18
000647 940e 1190 	CALL SUBOPT_0x15
000649 940e 11dd 	CALL SUBOPT_0x20
00064b 940e 1404 	CALL __PUTPARD1
00064d e0e0      	LDI  R30,LOW(0)
00064e e0f0      	LDI  R31,HIGH(0)
00064f 940e 11cc 	CALL SUBOPT_0x1E
000651 f009      	BREQ _0x40016
000652 c05e      	RJMP _0x40010
                 ; 0002 0056 		}
                 _0x40016:
                 _0x40014:
                 ; 0002 0057 		wc = LD_WORD(buf);
                +
000653 8508     +LDD R16 , Y + 8
000654 8519     +LDD R17 , Y + 8 + 1
                 	__GETWRS 16,17,8
                 ; 0002 0058 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
000655 85ec      	LDD  R30,Y+12
000656 70e1      	ANDI R30,LOW(0x1)
000657 f021      	BREQ _0x40017
000658 01f8      	MOVW R30,R16
000659 940e 1356 	CALL __LSRW4
00065b c002      	RJMP _0x400E5
                 _0x40017:
00065c 01f8      	MOVW R30,R16
00065d 70ff      	ANDI R31,HIGH(0xFFF)
                 _0x400E5:
00065e 2766      	CLR  R22
00065f 2777      	CLR  R23
000660 c054      	RJMP _0x20C000F
                 ; 0002 0059 
                 ; 0002 005A 	case FS_FAT16 :
                 _0x40011:
000661 30e2      	CPI  R30,LOW(0x2)
000662 e0a0      	LDI  R26,HIGH(0x2)
000663 07fa      	CPC  R31,R26
000664 f509      	BRNE _0x4001A
                 ; 0002 005B 		if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
000665 01fe      	MOVW R30,R28
000666 9638      	ADIW R30,8
000667 940e 11d4 	CALL SUBOPT_0x1F
000669 939f      	PUSH R25
00066a 938f      	PUSH R24
00066b 93bf      	PUSH R27
00066c 93af      	PUSH R26
00066d 940e 11e2 	CALL SUBOPT_0x21
                +
00066f e0e0     +LDI R30 , LOW ( 0x100 )
000670 e0f1     +LDI R31 , HIGH ( 0x100 )
000671 e060     +LDI R22 , BYTE3 ( 0x100 )
000672 e070     +LDI R23 , BYTE4 ( 0x100 )
                 	__GETD1N 0x100
000673 940e 13a6 	CALL __DIVD21U
000675 91af      	POP  R26
000676 91bf      	POP  R27
000677 918f      	POP  R24
000678 919f      	POP  R25
000679 940e 11e7 	CALL SUBOPT_0x22
00067b 70f0      	ANDI R31,HIGH(0xFF)
00067c 0fee      	LSL  R30
00067d 1fff      	ROL  R31
00067e 940e 11ee 	CALL SUBOPT_0x23
000680 f581      	BRNE _0x40010
                 ; 0002 005C 		return LD_WORD(buf);
000681 85e8      	LDD  R30,Y+8
000682 85f9      	LDD  R31,Y+8+1
000683 2766      	CLR  R22
000684 2777      	CLR  R23
000685 c02f      	RJMP _0x20C000F
                 ; 0002 005D #if _FS_FAT32
                 ; 0002 005E 	case FS_FAT32 :
                 _0x4001A:
000686 30e3      	CPI  R30,LOW(0x3)
000687 e0a0      	LDI  R26,HIGH(0x3)
000688 07fa      	CPC  R31,R26
000689 f539      	BRNE _0x40010
                 ; 0002 005F 		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
00068a 01fe      	MOVW R30,R28
00068b 9638      	ADIW R30,8
00068c 940e 11d4 	CALL SUBOPT_0x1F
00068e 939f      	PUSH R25
00068f 938f      	PUSH R24
000690 93bf      	PUSH R27
000691 93af      	PUSH R26
000692 940e 11e2 	CALL SUBOPT_0x21
                +
000694 e8e0     +LDI R30 , LOW ( 0x80 )
000695 e0f0     +LDI R31 , HIGH ( 0x80 )
000696 e060     +LDI R22 , BYTE3 ( 0x80 )
000697 e070     +LDI R23 , BYTE4 ( 0x80 )
                 	__GETD1N 0x80
000698 940e 13a6 	CALL __DIVD21U
00069a 91af      	POP  R26
00069b 91bf      	POP  R27
00069c 918f      	POP  R24
00069d 919f      	POP  R25
00069e 940e 11e7 	CALL SUBOPT_0x22
0006a0 77ef      	ANDI R30,LOW(0x7F)
0006a1 70f0      	ANDI R31,HIGH(0x7F)
0006a2 940e 1351 	CALL __LSLW2
0006a4 93fa      	ST   -Y,R31
0006a5 93ea      	ST   -Y,R30
0006a6 e0a4      	LDI  R26,LOW(4)
0006a7 940e 11f1 	CALL SUBOPT_0x24
0006a9 f439      	BRNE _0x40010
                 ; 0002 0060 		return LD_DWORD(buf) & 0x0FFFFFFF;
0006aa 940e 1186 	CALL SUBOPT_0x13
                +
0006ac 7fef     +ANDI R30 , LOW ( 0xFFFFFFF )
0006ad 7fff     +ANDI R31 , HIGH ( 0xFFFFFFF )
0006ae 7f6f     +ANDI R22 , BYTE3 ( 0xFFFFFFF )
0006af 707f     +ANDI R23 , BYTE4 ( 0xFFFFFFF )
                 	__ANDD1N 0xFFFFFFF
0006b0 c004      	RJMP _0x20C000F
                 ; 0002 0061 #endif
                 ; 0002 0062 	}
                 _0x40010:
                 ; 0002 0063 
                 ; 0002 0064 	return 1;	/* An error occured at the disk I/O layer */
                 _0x20C0010:
                +
0006b1 e0e1     +LDI R30 , LOW ( 0x1 )
0006b2 e0f0     +LDI R31 , HIGH ( 0x1 )
0006b3 e060     +LDI R22 , BYTE3 ( 0x1 )
0006b4 e070     +LDI R23 , BYTE4 ( 0x1 )
                 	__GETD1N 0x1
                 _0x20C000F:
0006b5 940e 1467 	CALL __LOADLOCR6
0006b7 9660      	ADIW R28,16
0006b8 9508      	RET
                 ; 0002 0065 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Get sector# from cluster#                                             */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
                 ; 0002 0070 	CLUST clst		/* Cluster# to be converted */
                 ; 0002 0071 )
                 ; 0002 0072 {
                 _clust2sect_G002:
                 ; .FSTART _clust2sect_G002
                 ; 0002 0073 	FATFS *fs = FatFs;
                 ; 0002 0074 
                 ; 0002 0075 
                 ; 0002 0076 	clst -= 2;
0006b9 940e 1409 	CALL __PUTPARD2
0006bb 940e 11f6 	CALL SUBOPT_0x25
                 ;	clst -> Y+2
                 ;	*fs -> R16,R17
0006bd 940e 11fd 	CALL SUBOPT_0x26
                +
0006bf 50e2     +SUBI R30 , LOW ( 2 )
0006c0 40f0     +SBCI R31 , HIGH ( 2 )
0006c1 4060     +SBCI R22 , BYTE3 ( 2 )
0006c2 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
0006c3 940e 1202 	CALL SUBOPT_0x27
                 ; 0002 0077 	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
0006c5 01f8      	MOVW R30,R16
                +
0006c6 85a0     +LDD R26 , Z + 8
0006c7 85b1     +LDD R27 , Z + 8 + 1
0006c8 8582     +LDD R24 , Z + 8 + 2
0006c9 8593     +LDD R25 , Z + 8 + 3
                 	__GETD2Z 8
                +
0006ca e0e2     +LDI R30 , LOW ( 0x2 )
0006cb e0f0     +LDI R31 , HIGH ( 0x2 )
0006cc e060     +LDI R22 , BYTE3 ( 0x2 )
0006cd e070     +LDI R23 , BYTE4 ( 0x2 )
                 	__GETD1N 0x2
0006ce 940e 140e 	CALL __SWAPD12
0006d0 940e 132e 	CALL __SUBD12
0006d2 940e 1207 	CALL SUBOPT_0x28
0006d4 940e 145b 	CALL __CPD21
0006d6 f028      	BRLO _0x4001E
0006d7 940e 120c 	CALL SUBOPT_0x29
0006d9 8119      	LDD  R17,Y+1
0006da 8108      	LDD  R16,Y+0
0006db c24f      	RJMP _0x20C000A
                 ; 0002 0078 	return (DWORD)clst * fs->csize + fs->database;
                 _0x4001E:
0006dc 01f8      	MOVW R30,R16
0006dd 81e1      	LDD  R30,Z+1
0006de e0f0      	LDI  R31,0
0006df 940e 1207 	CALL SUBOPT_0x28
0006e1 940e 136e 	CALL __CWD1
0006e3 940e 1373 	CALL __MULD12U
0006e5 937f      	PUSH R23
0006e6 936f      	PUSH R22
0006e7 93ff      	PUSH R31
0006e8 93ef      	PUSH R30
0006e9 01d8      	MOVW R26,R16
0006ea 9654      	ADIW R26,20
0006eb 940e 13d3 	CALL __GETD1P
0006ed 91af      	POP  R26
0006ee 91bf      	POP  R27
0006ef 918f      	POP  R24
0006f0 919f      	POP  R25
0006f1 940e 1324 	CALL __ADDD12
0006f3 8119      	LDD  R17,Y+1
0006f4 8108      	LDD  R16,Y+0
0006f5 c235      	RJMP _0x20C000A
                 ; 0002 0079 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Directory handling - Rewind directory index                           */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;FRESULT dir_rewind (
                 ; 0002 0084 	DIR *dj			/* Pointer to directory object */
                 ; 0002 0085 )
                 ; 0002 0086 {
                 _dir_rewind_G002:
                 ; .FSTART _dir_rewind_G002
                 ; 0002 0087 	CLUST clst;
                 ; 0002 0088 	FATFS *fs = FatFs;
                 ; 0002 0089 
                 ; 0002 008A 
                 ; 0002 008B 	dj->index = 0;
0006f6 93ba      	ST   -Y,R27
0006f7 93aa      	ST   -Y,R26
0006f8 9724      	SBIW R28,4
0006f9 940e 11f6 	CALL SUBOPT_0x25
                 ;	*dj -> Y+6
                 ;	clst -> Y+2
                 ;	*fs -> R16,R17
0006fb 81ae      	LDD  R26,Y+6
0006fc 81bf      	LDD  R27,Y+6+1
0006fd 940e 1211 	CALL SUBOPT_0x2A
                 ; 0002 008C 	clst = dj->sclust;
0006ff 81ae      	LDD  R26,Y+6
000700 81bf      	LDD  R27,Y+6+1
000701 9614      	ADIW R26,4
000702 940e 13d3 	CALL __GETD1P
000704 940e 1202 	CALL SUBOPT_0x27
                 ; 0002 008D 	if (clst == 1 || clst >= fs->max_clust)	/* Check start cluster range */
000706 940e 1207 	CALL SUBOPT_0x28
                +
000708 30a1     +CPI R26 , LOW ( 0x1 )
000709 e0e0     +LDI R30 , HIGH ( 0x1 )
00070a 07be     +CPC R27 , R30
00070b e0e0     +LDI R30 , BYTE3 ( 0x1 )
00070c 078e     +CPC R24 , R30
00070d e0e0     +LDI R30 , BYTE4 ( 0x1 )
00070e 079e     +CPC R25 , R30
                 	__CPD2N 0x1
00070f f049      	BREQ _0x40020
000710 01d8      	MOVW R26,R16
000711 9618      	ADIW R26,8
000712 940e 13d3 	CALL __GETD1P
000714 940e 1207 	CALL SUBOPT_0x28
000716 940e 145b 	CALL __CPD21
000718 f020      	BRLO _0x4001F
                 _0x40020:
                 ; 0002 008E 		return FR_DISK_ERR;
000719 e0e1      	LDI  R30,LOW(1)
00071a 8119      	LDD  R17,Y+1
00071b 8108      	LDD  R16,Y+0
00071c c1d8      	RJMP _0x20C000B
                 ; 0002 008F #if _FS_FAT32
                 ; 0002 0090 	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
                 _0x4001F:
00071d 940e 11fd 	CALL SUBOPT_0x26
00071f 940e 1448 	CALL __CPD10
000721 f421      	BRNE _0x40023
000722 01d8      	MOVW R26,R16
000723 91ac      	LD   R26,X
000724 30a3      	CPI  R26,LOW(0x3)
000725 f009      	BREQ _0x40024
                 _0x40023:
000726 c006      	RJMP _0x40022
                 _0x40024:
                 ; 0002 0091 		clst = fs->dirbase;
000727 01d8      	MOVW R26,R16
000728 9650      	ADIW R26,16
000729 940e 13d3 	CALL __GETD1P
00072b 940e 1202 	CALL SUBOPT_0x27
                 ; 0002 0092 #endif
                 ; 0002 0093 	dj->clust = clst;						/* Current cluster */
                 _0x40022:
00072d 940e 11fd 	CALL SUBOPT_0x26
                +
00072f 81ae     +LDD R26 , Y + 6
000730 81bf     +LDD R27 , Y + 6 + 1
000731 9618     +ADIW R26 , 8
000732 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 6,8
                 ; 0002 0094 	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
000734 940e 11fd 	CALL SUBOPT_0x26
000736 940e 1448 	CALL __CPD10
000738 f021      	BREQ _0x40025
000739 940e 1207 	CALL SUBOPT_0x28
00073b df7d      	RCALL _clust2sect_G002
00073c c004      	RJMP _0x40026
                 _0x40025:
00073d 01d8      	MOVW R26,R16
00073e 9650      	ADIW R26,16
00073f 940e 13d3 	CALL __GETD1P
                 _0x40026:
                +
000741 81ae     +LDD R26 , Y + 6
000742 81bf     +LDD R27 , Y + 6 + 1
000743 961c     +ADIW R26 , 12
000744 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 6,12
                 ; 0002 0095 
                 ; 0002 0096 	return FR_OK;	/* Seek succeeded */
000746 e0e0      	LDI  R30,LOW(0)
000747 8119      	LDD  R17,Y+1
000748 8108      	LDD  R16,Y+0
000749 c1ab      	RJMP _0x20C000B
                 ; 0002 0097 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Directory handling - Move directory index next                        */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
                 ; 0002 00A2 	DIR *dj			/* Pointer to directory object */
                 ; 0002 00A3 )
                 ; 0002 00A4 {
                 _dir_next_G002:
                 ; .FSTART _dir_next_G002
                 ; 0002 00A5 	CLUST clst;
                 ; 0002 00A6 	WORD i;
                 ; 0002 00A7 	FATFS *fs = FatFs;
                 ; 0002 00A8 
                 ; 0002 00A9 
                 ; 0002 00AA 	i = dj->index + 1;
00074a 93ba      	ST   -Y,R27
00074b 93aa      	ST   -Y,R26
00074c 9724      	SBIW R28,4
00074d 940e 1216 	CALL SUBOPT_0x2B
                 ;	*dj -> Y+8
                 ;	clst -> Y+4
                 ;	i -> R16,R17
                 ;	*fs -> R18,R19
00074f 85a8      	LDD  R26,Y+8
000750 85b9      	LDD  R27,Y+8+1
000751 940e 13cf 	CALL __GETW1P
000753 9631      	ADIW R30,1
000754 018f      	MOVW R16,R30
                 ; 0002 00AB 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
000755 2e00      	MOV  R0,R16
000756 2a01      	OR   R0,R17
000757 f031      	BREQ _0x40029
000758 961c      	ADIW R26,12
000759 940e 13d3 	CALL __GETD1P
00075b 940e 1448 	CALL __CPD10
00075d f411      	BRNE _0x40028
                 _0x40029:
                 ; 0002 00AC 		return FR_NO_FILE;
00075e e0e3      	LDI  R30,LOW(3)
00075f c05c      	RJMP _0x20C000D
                 ; 0002 00AD 
                 ; 0002 00AE 	if (!(i & (16-1))) {	/* Sector changed? */
                 _0x40028:
000760 01f8      	MOVW R30,R16
000761 70ef      	ANDI R30,LOW(0xF)
000762 f009      	BREQ PC+2
000763 c053      	RJMP _0x4002B
                 ; 0002 00AF 		dj->sect++;			/* Next sector */
000764 85a8      	LDD  R26,Y+8
000765 85b9      	LDD  R27,Y+8+1
000766 961c      	ADIW R26,12
000767 940e 13d9 	CALL __GETD1P_INC
                +
000769 5fef     +SUBI R30 , LOW ( - 1 )
00076a 4fff     +SBCI R31 , HIGH ( - 1 )
00076b 4f6f     +SBCI R22 , BYTE3 ( - 1 )
00076c 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
00076d 940e 13e3 	CALL __PUTDP1_DEC
                 ; 0002 00B0 
                 ; 0002 00B1 		if (dj->clust == 0) {	/* Static table */
00076f 85a8      	LDD  R26,Y+8
000770 85b9      	LDD  R27,Y+8+1
000771 9618      	ADIW R26,8
000772 940e 13d3 	CALL __GETD1P
000774 940e 1448 	CALL __CPD10
000776 f451      	BRNE _0x4002C
                 ; 0002 00B2 			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
000777 01d9      	MOVW R26,R18
000778 9614      	ADIW R26,4
000779 940e 13cf 	CALL __GETW1P
00077b 170e      	CP   R16,R30
00077c 071f      	CPC  R17,R31
00077d f010      	BRLO _0x4002D
                 ; 0002 00B3 				return FR_NO_FILE;
00077e e0e3      	LDI  R30,LOW(3)
00077f c03c      	RJMP _0x20C000D
                 ; 0002 00B4 		}
                 _0x4002D:
                 ; 0002 00B5 		else {					/* Dynamic table */
000780 c036      	RJMP _0x4002E
                 _0x4002C:
                 ; 0002 00B6 			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
000781 01f8      	MOVW R30,R16
000782 940e 1356 	CALL __LSRW4
000784 01df      	MOVW R26,R30
000785 01f9      	MOVW R30,R18
000786 81e1      	LDD  R30,Z+1
000787 e0f0      	LDI  R31,0
000788 9731      	SBIW R30,1
000789 23ea      	AND  R30,R26
00078a 23fb      	AND  R31,R27
00078b 9730      	SBIW R30,0
00078c f551      	BRNE _0x4002F
                 ; 0002 00B7 				clst = get_fat(dj->clust);		/* Get next cluster */
00078d 85e8      	LDD  R30,Y+8
00078e 85f9      	LDD  R31,Y+8+1
                +
00078f 85a0     +LDD R26 , Z + 8
000790 85b1     +LDD R27 , Z + 8 + 1
000791 8582     +LDD R24 , Z + 8 + 2
000792 8593     +LDD R25 , Z + 8 + 3
                 	__GETD2Z 8
000793 de62      	RCALL _get_fat_G002
000794 940e 118b 	CALL SUBOPT_0x14
                 ; 0002 00B8 				if (clst <= 1) return FR_DISK_ERR;
000796 940e 121d 	CALL SUBOPT_0x2C
000798 940e 11b2 	CALL SUBOPT_0x1B
00079a f410      	BRSH _0x40030
00079b e0e1      	LDI  R30,LOW(1)
00079c c01f      	RJMP _0x20C000D
                 ; 0002 00B9 				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
                 _0x40030:
00079d 01d9      	MOVW R26,R18
00079e 9618      	ADIW R26,8
00079f 940e 13d3 	CALL __GETD1P
0007a1 940e 121d 	CALL SUBOPT_0x2C
0007a3 940e 145b 	CALL __CPD21
0007a5 f010      	BRLO _0x40031
                 ; 0002 00BA 					return FR_NO_FILE;			/* Report EOT */
0007a6 e0e3      	LDI  R30,LOW(3)
0007a7 c014      	RJMP _0x20C000D
                 ; 0002 00BB 				dj->clust = clst;				/* Initialize data for new cluster */
                 _0x40031:
0007a8 940e 114f 	CALL SUBOPT_0xC
                +
0007aa 85a8     +LDD R26 , Y + 8
0007ab 85b9     +LDD R27 , Y + 8 + 1
0007ac 9618     +ADIW R26 , 8
0007ad 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 8,8
                 ; 0002 00BC 				dj->sect = clust2sect(clst);
0007af 940e 121d 	CALL SUBOPT_0x2C
0007b1 df07      	RCALL _clust2sect_G002
                +
0007b2 85a8     +LDD R26 , Y + 8
0007b3 85b9     +LDD R27 , Y + 8 + 1
0007b4 961c     +ADIW R26 , 12
0007b5 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 8,12
                 ; 0002 00BD 			}
                 ; 0002 00BE 		}
                 _0x4002F:
                 _0x4002E:
                 ; 0002 00BF 	}
                 ; 0002 00C0 
                 ; 0002 00C1 	dj->index = i;
                 _0x4002B:
0007b7 85a8      	LDD  R26,Y+8
0007b8 85b9      	LDD  R27,Y+8+1
0007b9 930d      	ST   X+,R16
0007ba 931c      	ST   X,R17
                 ; 0002 00C2 
                 ; 0002 00C3 	return FR_OK;
0007bb e0e0      	LDI  R30,LOW(0)
                 _0x20C000D:
0007bc 940e 1469 	CALL __LOADLOCR4
                 _0x20C000E:
0007be 962a      	ADIW R28,10
0007bf 9508      	RET
                 ; 0002 00C4 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Directory handling - Find an object in the directory                  */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;FRESULT dir_find (
                 ; 0002 00CF 	DIR *dj			/* Pointer to the directory object linked to the file name */
                 ; 0002 00D0 )
                 ; 0002 00D1 {
                 _dir_find_G002:
                 ; .FSTART _dir_find_G002
                 ; 0002 00D2 	FRESULT res;
                 ; 0002 00D3 	BYTE c, *dir;
                 ; 0002 00D4 
                 ; 0002 00D5 
                 ; 0002 00D6 	res = dir_rewind(dj);			/* Rewind directory object */
0007c0 940e 1222 	CALL SUBOPT_0x2D
                 ;	*dj -> Y+4
                 ;	res -> R17
                 ;	c -> R16
                 ;	*dir -> R18,R19
0007c2 81ac      	LDD  R26,Y+4
0007c3 81bd      	LDD  R27,Y+4+1
0007c4 df31      	RCALL _dir_rewind_G002
0007c5 2f1e      	MOV  R17,R30
                 ; 0002 00D7 	if (res != FR_OK) return res;
0007c6 3010      	CPI  R17,0
0007c7 f019      	BREQ _0x40032
0007c8 940e 1469 	CALL __LOADLOCR4
0007ca c160      	RJMP _0x20C000A
                 ; 0002 00D8 
                 ; 0002 00D9 	dir = FatFs->buf;
                 _0x40032:
0007cb 940e 1227 	CALL SUBOPT_0x2E
                 ; 0002 00DA 	do {
                 _0x40034:
                 ; 0002 00DB 		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
                 ; 0002 00DC 			? FR_DISK_ERR : FR_OK;
0007cd 933a      	ST   -Y,R19
0007ce 932a      	ST   -Y,R18
0007cf 81ee      	LDD  R30,Y+6
0007d0 81ff      	LDD  R31,Y+6+1
0007d1 940e 122f 	CALL SUBOPT_0x2F
0007d3 940e 1409 	CALL __PUTPARD2
0007d5 85aa      	LDD  R26,Y+10
0007d6 85bb      	LDD  R27,Y+10+1
0007d7 940e 13cf 	CALL __GETW1P
0007d9 70ef      	ANDI R30,LOW(0xF)
0007da 70f0      	ANDI R31,HIGH(0xF)
0007db 0fee      	LSL  R30
0007dc 940e 134d 	CALL __LSLW4
0007de 93fa      	ST   -Y,R31
0007df 93ea      	ST   -Y,R30
0007e0 e2a0      	LDI  R26,LOW(32)
0007e1 940e 11f1 	CALL SUBOPT_0x24
0007e3 f011      	BREQ _0x40036
0007e4 e0e1      	LDI  R30,LOW(1)
0007e5 c001      	RJMP _0x40037
                 _0x40036:
0007e6 e0e0      	LDI  R30,LOW(0)
                 _0x40037:
0007e7 2f1e      	MOV  R17,R30
                 ; 0002 00DD 		if (res != FR_OK) break;
0007e8 3010      	CPI  R17,0
0007e9 f4f9      	BRNE _0x40035
                 ; 0002 00DE 		c = dir[DIR_Name];	/* First character */
0007ea 01d9      	MOVW R26,R18
0007eb 910c      	LD   R16,X
                 ; 0002 00DF 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
0007ec 3000      	CPI  R16,0
0007ed f411      	BRNE _0x4003A
0007ee e013      	LDI  R17,LOW(3)
0007ef c019      	RJMP _0x40035
                 ; 0002 00E0 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
                 _0x4003A:
0007f0 01f9      	MOVW R30,R18
0007f1 85e3      	LDD  R30,Z+11
0007f2 70e8      	ANDI R30,LOW(0x8)
0007f3 f469      	BRNE _0x4003C
0007f4 933a      	ST   -Y,R19
0007f5 932a      	ST   -Y,R18
0007f6 81ee      	LDD  R30,Y+6
0007f7 81ff      	LDD  R31,Y+6+1
0007f8 81a2      	LDD  R26,Z+2
0007f9 81b3      	LDD  R27,Z+3
0007fa 93ba      	ST   -Y,R27
0007fb 93aa      	ST   -Y,R26
0007fc e0ab      	LDI  R26,LOW(11)
0007fd e0b0      	LDI  R27,0
0007fe ddcf      	RCALL _mem_cmp_G002
0007ff 9730      	SBIW R30,0
000800 f009      	BREQ _0x4003D
                 _0x4003C:
000801 c001      	RJMP _0x4003B
                 _0x4003D:
                 ; 0002 00E1 			break;
000802 c006      	RJMP _0x40035
                 ; 0002 00E2 		res = dir_next(dj);							/* Next entry */
                 _0x4003B:
000803 81ac      	LDD  R26,Y+4
000804 81bd      	LDD  R27,Y+4+1
000805 df44      	RCALL _dir_next_G002
000806 2f1e      	MOV  R17,R30
                 ; 0002 00E3 	} while (res == FR_OK);
000807 3010      	CPI  R17,0
000808 f221      	BREQ _0x40034
                 _0x40035:
                 ; 0002 00E4 
                 ; 0002 00E5 	return res;
000809 2fe1      	MOV  R30,R17
00080a 940e 1469 	CALL __LOADLOCR4
00080c c11e      	RJMP _0x20C000A
                 ; 0002 00E6 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Read an object from the directory                                     */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_DIR
                 ;static
                 ;FRESULT dir_read (
                 ; 0002 00F1 	DIR *dj			/* Pointer to the directory object to store read object name */
                 ; 0002 00F2 )
                 ; 0002 00F3 {
                 ; 0002 00F4 	FRESULT res;
                 ; 0002 00F5 	BYTE a, c, *dir;
                 ; 0002 00F6 
                 ; 0002 00F7 
                 ; 0002 00F8 	res = FR_NO_FILE;
                 ;	*dj -> Y+6
                 ;	res -> R17
                 ;	a -> R16
                 ;	c -> R19
                 ;	*dir -> R20,R21
                 ; 0002 00F9 	dir = FatFs->buf;
                 ; 0002 00FA 	while (dj->sect) {
                 ; 0002 00FB 		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
                 ; 0002 00FC 			? FR_DISK_ERR : FR_OK;
                 ; 0002 00FD 		if (res != FR_OK) break;
                 ; 0002 00FE 		c = dir[DIR_Name];
                 ; 0002 00FF 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
                 ; 0002 0100 		a = dir[DIR_Attr] & AM_MASK;
                 ; 0002 0101 		if (c != 0xE5 && c != '.' && !(a & AM_VOL))	/* Is it a valid entry? */
                 ; 0002 0102 			break;
                 ; 0002 0103 		res = dir_next(dj);				/* Next entry */
                 ; 0002 0104 		if (res != FR_OK) break;
                 ; 0002 0105 	}
                 ; 0002 0106 
                 ; 0002 0107 	if (res != FR_OK) dj->sect = 0;
                 ; 0002 0108 
                 ; 0002 0109 	return res;
                 ; 0002 010A }
                 ;#endif
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Pick a segment and create the object name in directory form           */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;#ifdef _EXCVT
                 ;	static const BYTE cvt[] = _EXCVT;
                 ;#endif
                 ;
                 ;static
                 ;FRESULT create_name (
                 ; 0002 0119 	DIR *dj,			/* Pointer to the directory object */
                 ; 0002 011A 	const char **path	/* Pointer to pointer to the segment in the path string */
                 ; 0002 011B )
                 ; 0002 011C {
                 _create_name_G002:
                 ; .FSTART _create_name_G002
                 ; 0002 011D 	BYTE c, d, ni, si, i, *sfn;
                 ; 0002 011E 	const char *p;
                 ; 0002 011F 
                 ; 0002 0120 	/* Create file name in directory form */
                 ; 0002 0121 	sfn = dj->fn;
00080d 93ba      	ST   -Y,R27
00080e 93aa      	ST   -Y,R26
00080f 9724      	SBIW R28,4
000810 940e 1460 	CALL __SAVELOCR6
                 ;	*dj -> Y+12
                 ;	*path -> Y+10
                 ;	c -> R17
                 ;	d -> R16
                 ;	ni -> R19
                 ;	si -> R18
                 ;	i -> R21
                 ;	*sfn -> Y+8
                 ;	*p -> Y+6
000812 85ac      	LDD  R26,Y+12
000813 85bd      	LDD  R27,Y+12+1
000814 9612      	ADIW R26,2
000815 940e 13cf 	CALL __GETW1P
000817 87e8      	STD  Y+8,R30
000818 87f9      	STD  Y+8+1,R31
                 ; 0002 0122 	mem_set(sfn, ' ', 11);
000819 93fa      	ST   -Y,R31
00081a 93ea      	ST   -Y,R30
00081b e2e0      	LDI  R30,LOW(32)
00081c e0f0      	LDI  R31,HIGH(32)
00081d 93fa      	ST   -Y,R31
00081e 93ea      	ST   -Y,R30
00081f e0ab      	LDI  R26,LOW(11)
000820 e0b0      	LDI  R27,0
000821 dd95      	RCALL _mem_set_G002
                 ; 0002 0123 	si = i = 0; ni = 8;
000822 e0e0      	LDI  R30,LOW(0)
000823 2f5e      	MOV  R21,R30
000824 2f2e      	MOV  R18,R30
000825 e038      	LDI  R19,LOW(8)
                 ; 0002 0124 	p = *path;
000826 85aa      	LDD  R26,Y+10
000827 85bb      	LDD  R27,Y+10+1
000828 940e 13cf 	CALL __GETW1P
00082a 83ee      	STD  Y+6,R30
00082b 83ff      	STD  Y+6+1,R31
                 ; 0002 0125 	for (;;) {
                 _0x4004C:
                 ; 0002 0126 		c = p[si++];
00082c 940e 1234 	CALL SUBOPT_0x30
00082e 911c      	LD   R17,X
                 ; 0002 0127 		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
00082f 3211      	CPI  R17,33
000830 f010      	BRLO _0x4004F
000831 321f      	CPI  R17,47
000832 f409      	BRNE _0x4004E
                 _0x4004F:
000833 c039      	RJMP _0x4004D
                 ; 0002 0128 		if (c == '.' || i >= ni) {
                 _0x4004E:
000834 321e      	CPI  R17,46
000835 f011      	BREQ _0x40052
000836 1753      	CP   R21,R19
000837 f040      	BRLO _0x40051
                 _0x40052:
                 ; 0002 0129 			if (ni != 8 || c != '.') break;
000838 3038      	CPI  R19,8
000839 f411      	BRNE _0x40055
00083a 321e      	CPI  R17,46
00083b f009      	BREQ _0x40054
                 _0x40055:
00083c c030      	RJMP _0x4004D
                 ; 0002 012A 			i = 8; ni = 11;
                 _0x40054:
00083d e058      	LDI  R21,LOW(8)
00083e e03b      	LDI  R19,LOW(11)
                 ; 0002 012B 			continue;
00083f c02c      	RJMP _0x4004B
                 ; 0002 012C 		}
                 ; 0002 012D #ifdef _EXCVT
                 ; 0002 012E 		if (c >= 0x80)					/* To upper extended char (SBCS) */
                 _0x40051:
000840 3810      	CPI  R17,128
000841 f058      	BRLO _0x40057
                 ; 0002 012F 			c = cvt[c - 0x80];
000842 2fe1      	MOV  R30,R17
000843 e0f0      	LDI  R31,0
000844 58e0      	SUBI R30,LOW(128)
000845 40f0      	SBCI R31,HIGH(128)
000846 2766      	CLR  R22
000847 2777      	CLR  R23
000848 53e0      	SUBI R30,LOW(-_cvt_G002*2)
000849 4fff      	SBCI R31,HIGH(-_cvt_G002*2)
00084a 4f6f      	SBCI R22,BYTE3(-_cvt_G002*2)
                +
00084b bf6b     +OUT RAMPZ , R22
00084c 9116     +ELPM R17 , Z
                 	__GETBRPF 17
                 ; 0002 0130 #endif
                 ; 0002 0131 		if (IsDBCS1(c) && i >= ni - 1) {	/* DBC 1st byte? */
                 _0x40057:
00084d e0e0      	LDI  R30,LOW(0)
00084e 30e0      	CPI  R30,0
00084f f041      	BREQ _0x40059
000850 2fe3      	MOV  R30,R19
000851 e0f0      	LDI  R31,0
000852 9731      	SBIW R30,1
000853 2fa5      	MOV  R26,R21
000854 e0b0      	LDI  R27,0
000855 17ae      	CP   R26,R30
000856 07bf      	CPC  R27,R31
000857 f40c      	BRGE _0x4005A
                 _0x40059:
000858 c00a      	RJMP _0x40058
                 _0x4005A:
                 ; 0002 0132 			d = p[si++];					/* Get 2nd byte */
000859 940e 1234 	CALL SUBOPT_0x30
00085b 910c      	LD   R16,X
                 ; 0002 0133 			sfn[i++] = c;
00085c 940e 123c 	CALL SUBOPT_0x31
00085e 8310      	ST   Z,R17
                 ; 0002 0134 			sfn[i++] = d;
00085f 940e 123c 	CALL SUBOPT_0x31
000861 8300      	ST   Z,R16
                 ; 0002 0135 		} else {						/* Single byte code */
000862 c009      	RJMP _0x4005B
                 _0x40058:
                 ; 0002 0136 			if (IsLower(c)) c -= 0x20;	/* toupper */
000863 3611      	CPI  R17,97
000864 f010      	BRLO _0x4005D
000865 371b      	CPI  R17,123
000866 f008      	BRLO _0x4005E
                 _0x4005D:
000867 c001      	RJMP _0x4005C
                 _0x4005E:
000868 5210      	SUBI R17,LOW(32)
                 ; 0002 0137 			sfn[i++] = c;
                 _0x4005C:
000869 940e 123c 	CALL SUBOPT_0x31
00086b 8310      	ST   Z,R17
                 ; 0002 0138 		}
                 _0x4005B:
                 ; 0002 0139 	}
                 _0x4004B:
00086c cfbf      	RJMP _0x4004C
                 _0x4004D:
                 ; 0002 013A 	*path = &p[si];						/* Rerurn pointer to the next segment */
00086d 2fe2      	MOV  R30,R18
00086e 81ae      	LDD  R26,Y+6
00086f 81bf      	LDD  R27,Y+6+1
000870 e0f0      	LDI  R31,0
000871 0fea      	ADD  R30,R26
000872 1ffb      	ADC  R31,R27
000873 85aa      	LDD  R26,Y+10
000874 85bb      	LDD  R27,Y+10+1
000875 93ed      	ST   X+,R30
000876 93fc      	ST   X,R31
                 ; 0002 013B 
                 ; 0002 013C 	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
000877 3211      	CPI  R17,33
000878 f410      	BRSH _0x4005F
000879 e0e1      	LDI  R30,LOW(1)
00087a c001      	RJMP _0x40060
                 _0x4005F:
00087b e0e0      	LDI  R30,LOW(0)
                 _0x40060:
                +
00087c 85a8     +LDD R26 , Y + 8
00087d 85b9     +LDD R27 , Y + 8 + 1
00087e 961b     +ADIW R26 , 11
00087f 93ec     +ST X , R30
                 	__PUTB1SNS 8,11
                 ; 0002 013D 
                 ; 0002 013E 	return FR_OK;
000880 e0e0      	LDI  R30,LOW(0)
000881 940e 1467 	CALL __LOADLOCR6
                 _0x20C000C:
000883 962e      	ADIW R28,14
000884 9508      	RET
                 ; 0002 013F }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Get file information from directory entry                             */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_DIR
                 ;static
                 ;void get_fileinfo (		/* No return code */
                 ; 0002 014A 	DIR *dj,			/* Pointer to the directory object */
                 ; 0002 014B 	FILINFO *fno	 	/* Pointer to store the file information */
                 ; 0002 014C )
                 ; 0002 014D {
                 ; 0002 014E 	BYTE i, c, *dir;
                 ; 0002 014F 	char *p;
                 ; 0002 0150 
                 ; 0002 0151 
                 ; 0002 0152 	p = fno->fname;
                 ;	*dj -> Y+8
                 ;	*fno -> Y+6
                 ;	i -> R17
                 ;	c -> R16
                 ;	*dir -> R18,R19
                 ;	*p -> R20,R21
                 ; 0002 0153 	if (dj->sect) {
                 ; 0002 0154 		dir = FatFs->buf;
                 ; 0002 0155 		for (i = 0; i < 8; i++) {	/* Copy file name body */
                 ; 0002 0156 			c = dir[i];
                 ; 0002 0157 			if (c == ' ') break;
                 ; 0002 0158 			if (c == 0x05) c = 0xE5;
                 ; 0002 0159 			*p++ = c;
                 ; 0002 015A 		}
                 ; 0002 015B 		if (dir[8] != ' ') {		/* Copy file name extension */
                 ; 0002 015C 			*p++ = '.';
                 ; 0002 015D 			for (i = 8; i < 11; i++) {
                 ; 0002 015E 				c = dir[i];
                 ; 0002 015F 				if (c == ' ') break;
                 ; 0002 0160 				*p++ = c;
                 ; 0002 0161 			}
                 ; 0002 0162 		}
                 ; 0002 0163 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
                 ; 0002 0164 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
                 ; 0002 0165 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
                 ; 0002 0166 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
                 ; 0002 0167 	}
                 ; 0002 0168 	*p = 0;
                 ; 0002 0169 }
                 ;#endif /* _USE_DIR */
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Follow a file path                                                    */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
                 ; 0002 0174 	DIR *dj,			/* Directory object to return last directory and found object */
                 ; 0002 0175 	const char *path	/* Full-path string to find a file or directory */
                 ; 0002 0176 )
                 ; 0002 0177 {
                 _follow_path_G002:
                 ; .FSTART _follow_path_G002
                 ; 0002 0178 	FRESULT res;
                 ; 0002 0179 	BYTE *dir;
                 ; 0002 017A 
                 ; 0002 017B 
                 ; 0002 017C 	while (*path == ' ') path++;		/* Skip leading spaces */
000885 940e 1222 	CALL SUBOPT_0x2D
                 ;	*dj -> Y+6
                 ;	*path -> Y+4
                 ;	res -> R17
                 ;	*dir -> R18,R19
                 _0x4006D:
000887 81ac      	LDD  R26,Y+4
000888 81bd      	LDD  R27,Y+4+1
000889 91ac      	LD   R26,X
00088a 32a0      	CPI  R26,LOW(0x20)
00088b f431      	BRNE _0x4006F
00088c 81ec      	LDD  R30,Y+4
00088d 81fd      	LDD  R31,Y+4+1
00088e 9631      	ADIW R30,1
00088f 83ec      	STD  Y+4,R30
000890 83fd      	STD  Y+4+1,R31
000891 cff5      	RJMP _0x4006D
                 _0x4006F:
                 ; 0002 017D if (*path == '/') path++;
000892 81ac      	LDD  R26,Y+4
000893 81bd      	LDD  R27,Y+4+1
000894 91ac      	LD   R26,X
000895 32af      	CPI  R26,LOW(0x2F)
000896 f429      	BRNE _0x40070
000897 81ec      	LDD  R30,Y+4
000898 81fd      	LDD  R31,Y+4+1
000899 9631      	ADIW R30,1
00089a 83ec      	STD  Y+4,R30
00089b 83fd      	STD  Y+4+1,R31
                 ; 0002 017E 	dj->sclust = 0;						/* Set start directory (always root dir) */
                 _0x40070:
00089c 81ae      	LDD  R26,Y+6
00089d 81bf      	LDD  R27,Y+6+1
00089e 9614      	ADIW R26,4
00089f 940e 120c 	CALL SUBOPT_0x29
0008a1 940e 13de 	CALL __PUTDP1
                 ; 0002 017F 
                 ; 0002 0180 	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
0008a3 81ac      	LDD  R26,Y+4
0008a4 81bd      	LDD  R27,Y+4+1
0008a5 91ac      	LD   R26,X
0008a6 32a1      	CPI  R26,LOW(0x21)
0008a7 f458      	BRSH _0x40071
                 ; 0002 0181 		res = dir_rewind(dj);
0008a8 81ae      	LDD  R26,Y+6
0008a9 81bf      	LDD  R27,Y+6+1
0008aa de4b      	RCALL _dir_rewind_G002
0008ab 2f1e      	MOV  R17,R30
                 ; 0002 0182 		FatFs->buf[0] = 0;
0008ac 940e 11a8 	CALL SUBOPT_0x19
0008ae 81a6      	LDD  R26,Z+6
0008af 81b7      	LDD  R27,Z+7
0008b0 e0e0      	LDI  R30,LOW(0)
0008b1 93ec      	ST   X,R30
                 ; 0002 0183 
                 ; 0002 0184 	} else {							/* Follow path */
0008b2 c03f      	RJMP _0x40072
                 _0x40071:
                 ; 0002 0185 		for (;;) {
                 _0x40074:
                 ; 0002 0186 			res = create_name(dj, &path);	/* Get a segment */
0008b3 81ee      	LDD  R30,Y+6
0008b4 81ff      	LDD  R31,Y+6+1
0008b5 93fa      	ST   -Y,R31
0008b6 93ea      	ST   -Y,R30
0008b7 01de      	MOVW R26,R28
0008b8 9616      	ADIW R26,6
0008b9 df53      	RCALL _create_name_G002
0008ba 2f1e      	MOV  R17,R30
                 ; 0002 0187 			if (res != FR_OK) break;
0008bb 3010      	CPI  R17,0
0008bc f5a9      	BRNE _0x40075
                 ; 0002 0188 			res = dir_find(dj);				/* Find it */
0008bd 81ae      	LDD  R26,Y+6
0008be 81bf      	LDD  R27,Y+6+1
0008bf df00      	RCALL _dir_find_G002
0008c0 2f1e      	MOV  R17,R30
                 ; 0002 0189 			if (res != FR_OK) {				/* Could not find the object */
0008c1 3010      	CPI  R17,0
0008c2 f041      	BREQ _0x40077
                 ; 0002 018A 				if (res == FR_NO_FILE && !*(dj->fn+11))
0008c3 3013      	CPI  R17,3
0008c4 f419      	BRNE _0x40079
0008c5 940e 1244 	CALL SUBOPT_0x32
0008c7 f009      	BREQ _0x4007A
                 _0x40079:
0008c8 c001      	RJMP _0x40078
                 _0x4007A:
                 ; 0002 018B 					res = FR_NO_PATH;
0008c9 e014      	LDI  R17,LOW(4)
                 ; 0002 018C 				break;
                 _0x40078:
0008ca c027      	RJMP _0x40075
                 ; 0002 018D 			}
                 ; 0002 018E 			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
                 _0x40077:
0008cb 940e 1244 	CALL SUBOPT_0x32
0008cd f521      	BRNE _0x40075
                 ; 0002 018F 			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
0008ce 940e 1227 	CALL SUBOPT_0x2E
                 ; 0002 0190 			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
0008d0 01f9      	MOVW R30,R18
0008d1 85e3      	LDD  R30,Z+11
0008d2 71e0      	ANDI R30,LOW(0x10)
0008d3 f411      	BRNE _0x4007C
                 ; 0002 0191 				res = FR_NO_PATH; break;
0008d4 e014      	LDI  R17,LOW(4)
0008d5 c01c      	RJMP _0x40075
                 ; 0002 0192 			}
                 ; 0002 0193 			dj->sclust =
                 _0x4007C:
                 ; 0002 0194 #if _FS_FAT32
                 ; 0002 0195 				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
                 ; 0002 0196 #endif
                 ; 0002 0197 				LD_WORD(dir+DIR_FstClusLO);
0008d6 01d9      	MOVW R26,R18
0008d7 9654      	ADIW R26,20
0008d8 940e 124c 	CALL SUBOPT_0x33
0008da 940e 1369 	CALL __LSLD16
0008dc 937f      	PUSH R23
0008dd 936f      	PUSH R22
0008de 93ff      	PUSH R31
0008df 93ef      	PUSH R30
0008e0 01d9      	MOVW R26,R18
0008e1 965a      	ADIW R26,26
0008e2 940e 13cf 	CALL __GETW1P
0008e4 91af      	POP  R26
0008e5 91bf      	POP  R27
0008e6 918f      	POP  R24
0008e7 919f      	POP  R25
0008e8 2766      	CLR  R22
0008e9 2777      	CLR  R23
0008ea 940e 1338 	CALL __ORD12
                +
0008ec 81ae     +LDD R26 , Y + 6
0008ed 81bf     +LDD R27 , Y + 6 + 1
0008ee 9614     +ADIW R26 , 4
0008ef 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 6,4
                 ; 0002 0198 		}
0008f1 cfc1      	RJMP _0x40074
                 _0x40075:
                 ; 0002 0199 	}
                 _0x40072:
                 ; 0002 019A 
                 ; 0002 019B 	return res;
0008f2 2fe1      	MOV  R30,R17
0008f3 940e 1469 	CALL __LOADLOCR4
                 _0x20C000B:
0008f5 9628      	ADIW R28,8
0008f6 9508      	RET
                 ; 0002 019C }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Check a sector if it is an FAT boot record                            */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;static
                 ;BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                 ; 0002 01A7 	BYTE *buf,	/* Working buffer */
                 ; 0002 01A8 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
                 ; 0002 01A9 )
                 ; 0002 01AA {
                 _check_fs_G002:
                 ; .FSTART _check_fs_G002
                 ; 0002 01AB 	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
0008f7 940e 1409 	CALL __PUTPARD2
                 ;	*buf -> Y+4
                 ;	sect -> Y+0
0008f9 940e 1251 	CALL SUBOPT_0x34
0008fb efee      	LDI  R30,LOW(510)
0008fc e0f1      	LDI  R31,HIGH(510)
0008fd 940e 11ee 	CALL SUBOPT_0x23
0008ff f011      	BREQ _0x4007D
                 ; 0002 01AC 		return 3;
000900 e0e3      	LDI  R30,LOW(3)
000901 c029      	RJMP _0x20C000A
                 ; 0002 01AD 	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
                 _0x4007D:
000902 940e 1259 	CALL SUBOPT_0x35
000904 35e5      	CPI  R30,LOW(0xAA55)
000905 eaaa      	LDI  R26,HIGH(0xAA55)
000906 07fa      	CPC  R31,R26
000907 f011      	BREQ _0x4007E
                 ; 0002 01AE 		return 2;
000908 e0e2      	LDI  R30,LOW(2)
000909 c021      	RJMP _0x20C000A
                 ; 0002 01AF 
                 ; 0002 01B0 	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
                 _0x4007E:
00090a 940e 1251 	CALL SUBOPT_0x34
00090c e3e6      	LDI  R30,LOW(54)
00090d e0f0      	LDI  R31,HIGH(54)
00090e 940e 11ee 	CALL SUBOPT_0x23
000910 f431      	BRNE _0x40080
000911 940e 1259 	CALL SUBOPT_0x35
000913 34e6      	CPI  R30,LOW(0x4146)
000914 e4a1      	LDI  R26,HIGH(0x4146)
000915 07fa      	CPC  R31,R26
000916 f009      	BREQ _0x40081
                 _0x40080:
000917 c002      	RJMP _0x4007F
                 _0x40081:
                 ; 0002 01B1 		return 0;
000918 e0e0      	LDI  R30,LOW(0)
000919 c011      	RJMP _0x20C000A
                 ; 0002 01B2 #if _FS_FAT32
                 ; 0002 01B3 	if (!disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
                 _0x4007F:
00091a 940e 1251 	CALL SUBOPT_0x34
00091c e5e2      	LDI  R30,LOW(82)
00091d e0f0      	LDI  R31,HIGH(82)
00091e 940e 11ee 	CALL SUBOPT_0x23
000920 f431      	BRNE _0x40083
000921 940e 1259 	CALL SUBOPT_0x35
000923 34e6      	CPI  R30,LOW(0x4146)
000924 e4a1      	LDI  R26,HIGH(0x4146)
000925 07fa      	CPC  R31,R26
000926 f009      	BREQ _0x40084
                 _0x40083:
000927 c002      	RJMP _0x40082
                 _0x40084:
                 ; 0002 01B4 		return 0;
000928 e0e0      	LDI  R30,LOW(0)
000929 c001      	RJMP _0x20C000A
                 ; 0002 01B5 #endif
                 ; 0002 01B6 	return 1;
                 _0x40082:
00092a e0e1      	LDI  R30,LOW(1)
                 _0x20C000A:
00092b 9626      	ADIW R28,6
00092c 9508      	RET
                 ; 0002 01B7 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*--------------------------------------------------------------------------
                 ;
                 ;   Public Functions
                 ;
                 ;--------------------------------------------------------------------------*/
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Mount/Unmount a Locical Drive                                         */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;FRESULT pf_mount (
                 ; 0002 01C9 	FATFS *fs		/* Pointer to new file system object (NULL: Unmount) */
                 ; 0002 01CA )
                 ; 0002 01CB {
                 _pf_mount:
                 ; .FSTART _pf_mount
                 ; 0002 01CC 	BYTE fmt, buf[36];
                 ; 0002 01CD 	DWORD bsect, fsize, tsect, mclst;
                 ; 0002 01CE 
                 ; 0002 01CF 
                 ; 0002 01D0 	FatFs = 0;
00092d 93ba      	ST   -Y,R27
00092e 93aa      	ST   -Y,R26
00092f 97e4      	SBIW R28,52
000930 931a      	ST   -Y,R17
                 ;	*fs -> Y+53
                 ;	fmt -> R17
                 ;	buf -> Y+17
                 ;	bsect -> Y+13
                 ;	fsize -> Y+9
                 ;	tsect -> Y+5
                 ;	mclst -> Y+1
000931 e0e0      	LDI  R30,LOW(0)
000932 93e0 0921 	STS  _FatFs_G002,R30
000934 93e0 0922 	STS  _FatFs_G002+1,R30
                 ; 0002 01D1 	if (!fs) return FR_OK;				/* Unregister fs object */
000936 a9ed      	LDD  R30,Y+53
000937 a9fe      	LDD  R31,Y+53+1
000938 9730      	SBIW R30,0
000939 f409      	BRNE _0x40085
00093a c112      	RJMP _0x20C0009
                 ; 0002 01D2 
                 ; 0002 01D3 	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
                 _0x40085:
00093b 940e 0d1a 	CALL _disk_initialize
00093d 70e1      	ANDI R30,LOW(0x1)
00093e f011      	BREQ _0x40086
                 ; 0002 01D4 		return FR_NOT_READY;
00093f e0e2      	LDI  R30,LOW(2)
000940 c10d      	RJMP _0x20C0008
                 ; 0002 01D5 
                 ; 0002 01D6 	/* Search FAT partition on the drive */
                 ; 0002 01D7 	bsect = 0;
                 _0x40086:
000941 e0e0      	LDI  R30,LOW(0)
                +
000942 87ed     +STD Y + 13 , R30
000943 87ee     +STD Y + 13 + 1 , R30
000944 87ef     +STD Y + 13 + 2 , R30
000945 8be8     +STD Y + 13 + 3 , R30
                 	__CLRD1S 13
                 ; 0002 01D8 	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
000946 940e 125e 	CALL SUBOPT_0x36
000948 940e 1263 	CALL SUBOPT_0x37
                 ; 0002 01D9 	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
00094a 3011      	CPI  R17,1
00094b f4e9      	BRNE _0x40087
                 ; 0002 01DA 		/* Check a partition listed in top of the partition table */
                 ; 0002 01DB 		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
00094c 940e 125e 	CALL SUBOPT_0x36
00094e 940e 126b 	CALL SUBOPT_0x38
000950 ebee      	LDI  R30,LOW(446)
000951 e0f1      	LDI  R31,HIGH(446)
000952 93fa      	ST   -Y,R31
000953 93ea      	ST   -Y,R30
000954 e1a0      	LDI  R26,LOW(16)
000955 940e 11f1 	CALL SUBOPT_0x24
000957 f011      	BREQ _0x40088
                 ; 0002 01DC 			fmt = 3;
000958 e013      	LDI  R17,LOW(3)
                 ; 0002 01DD 		} else {
000959 c00f      	RJMP _0x40089
                 _0x40088:
                 ; 0002 01DE 			if (buf[4]) {					/* Is the partition existing? */
00095a 89ed      	LDD  R30,Y+21
00095b 30e0      	CPI  R30,0
00095c f061      	BREQ _0x4008A
                 ; 0002 01DF 				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
                +
00095d 8de9     +LDD R30 , Y + 25
00095e 8dfa     +LDD R31 , Y + 25 + 1
00095f 8d6b     +LDD R22 , Y + 25 + 2
000960 8d7c     +LDD R23 , Y + 25 + 3
                 	__GETD1S 25
                +
000961 87ed     +STD Y + 13 , R30
000962 87fe     +STD Y + 13 + 1 , R31
000963 876f     +STD Y + 13 + 2 , R22
000964 8b78     +STD Y + 13 + 3 , R23
                 	__PUTD1S 13
                 ; 0002 01E0 				fmt = check_fs(buf, bsect);	/* Check the partition */
000965 940e 125e 	CALL SUBOPT_0x36
000967 940e 1263 	CALL SUBOPT_0x37
                 ; 0002 01E1 			}
                 ; 0002 01E2 		}
                 _0x4008A:
                 _0x40089:
                 ; 0002 01E3 	}
                 ; 0002 01E4 	if (fmt == 3) return FR_DISK_ERR;
                 _0x40087:
000969 3013      	CPI  R17,3
00096a f411      	BRNE _0x4008B
00096b e0e1      	LDI  R30,LOW(1)
00096c c0e1      	RJMP _0x20C0008
                 ; 0002 01E5 	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
                 _0x4008B:
00096d 3010      	CPI  R17,0
00096e f011      	BREQ _0x4008C
00096f e0e7      	LDI  R30,LOW(7)
000970 c0dd      	RJMP _0x20C0008
                 ; 0002 01E6 
                 ; 0002 01E7 	/* Initialize the file system object */
                 ; 0002 01E8 	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
                 _0x4008C:
000971 940e 125e 	CALL SUBOPT_0x36
000973 940e 126b 	CALL SUBOPT_0x38
000975 e0ed      	LDI  R30,LOW(13)
000976 e0f0      	LDI  R31,HIGH(13)
000977 93fa      	ST   -Y,R31
000978 93ea      	ST   -Y,R30
000979 e2a4      	LDI  R26,LOW(36)
00097a 940e 11f1 	CALL SUBOPT_0x24
00097c f011      	BREQ _0x4008D
00097d e0e1      	LDI  R30,LOW(1)
00097e c0cf      	RJMP _0x20C0008
                 ; 0002 01E9 
                 ; 0002 01EA 	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
                 _0x4008D:
00097f 01fe      	MOVW R30,R28
000980 96b7      	ADIW R30,39
000981 973d      	SBIW R30,13
000982 01df      	MOVW R26,R30
000983 940e 124c 	CALL SUBOPT_0x33
000985 940e 1272 	CALL SUBOPT_0x39
                 ; 0002 01EB 	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
000987 940e 1277 	CALL SUBOPT_0x3A
000989 940e 1448 	CALL __CPD10
00098b f441      	BRNE _0x4008E
00098c 01fe      	MOVW R30,R28
00098d 96f5      	ADIW R30,53
00098e 973d      	SBIW R30,13
00098f 01df      	MOVW R26,R30
000990 940e 13d3 	CALL __GETD1P
000992 940e 1272 	CALL SUBOPT_0x39
                 ; 0002 01EC 
                 ; 0002 01ED 	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
                 _0x4008E:
000994 89ec      	LDD  R30,Y+20
000995 e0f0      	LDI  R31,0
000996 940e 127c 	CALL SUBOPT_0x3B
000998 940e 136e 	CALL __CWD1
00099a 940e 1373 	CALL __MULD12U
00099c 940e 1272 	CALL SUBOPT_0x39
                 ; 0002 01EE 	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
00099e 940e 1281 	CALL SUBOPT_0x3C
                +
0009a0 85ad     +LDD R26 , Y + 13
0009a1 85be     +LDD R27 , Y + 13 + 1
0009a2 858f     +LDD R24 , Y + 13 + 2
0009a3 8998     +LDD R25 , Y + 13 + 3
                 	__GETD2S 13
0009a4 940e 1190 	CALL SUBOPT_0x15
                +
0009a6 a9ad     +LDD R26 , Y + 53
0009a7 a9be     +LDD R27 , Y + 53 + 1
0009a8 961c     +ADIW R26 , 12
0009a9 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 53,12
                 ; 0002 01EF 	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
0009ab 89e9      	LDD  R30,Y+17
                +
0009ac a9ad     +LDD R26 , Y + 53
0009ad a9be     +LDD R27 , Y + 53 + 1
0009ae 9611     +ADIW R26 , 1
0009af 93ec     +ST X , R30
                 	__PUTB1SNS 53,1
                 ; 0002 01F0 	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
0009b0 01fe      	MOVW R30,R28
0009b1 96b2      	ADIW R30,34
0009b2 973d      	SBIW R30,13
0009b3 01df      	MOVW R26,R30
0009b4 940e 13cf 	CALL __GETW1P
                +
0009b6 a9ad     +LDD R26 , Y + 53
0009b7 a9be     +LDD R27 , Y + 53 + 1
0009b8 9614     +ADIW R26 , 4
0009b9 93ed     +ST X + , R30
0009ba 93fc     +ST X , R31
                 	__PUTW1SNS 53,4
                 ; 0002 01F1 	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
0009bb 01fe      	MOVW R30,R28
0009bc 96b4      	ADIW R30,36
0009bd 973d      	SBIW R30,13
0009be 01df      	MOVW R26,R30
0009bf 940e 124c 	CALL SUBOPT_0x33
                +
0009c1 83ed     +STD Y + 5 , R30
0009c2 83fe     +STD Y + 5 + 1 , R31
0009c3 836f     +STD Y + 5 + 2 , R22
0009c4 8778     +STD Y + 5 + 3 , R23
                 	__PUTD1S 5
                 ; 0002 01F2 	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
0009c5 940e 1448 	CALL __CPD10
0009c7 f451      	BRNE _0x4008F
0009c8 01fe      	MOVW R30,R28
0009c9 96f1      	ADIW R30,49
0009ca 973d      	SBIW R30,13
0009cb 01df      	MOVW R26,R30
0009cc 940e 13d3 	CALL __GETD1P
                +
0009ce 83ed     +STD Y + 5 , R30
0009cf 83fe     +STD Y + 5 + 1 , R31
0009d0 836f     +STD Y + 5 + 2 , R22
0009d1 8778     +STD Y + 5 + 3 , R23
                 	__PUTD1S 5
                 ; 0002 01F3 	mclst = (tsect						/* Last cluster# + 1 */
                 _0x4008F:
                 ; 0002 01F4 		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
                 ; 0002 01F5 		) / fs->csize + 2;
0009d2 940e 1281 	CALL SUBOPT_0x3C
                +
0009d4 81ad     +LDD R26 , Y + 5
0009d5 81be     +LDD R27 , Y + 5 + 1
0009d6 818f     +LDD R24 , Y + 5 + 2
0009d7 8598     +LDD R25 , Y + 5 + 3
                 	__GETD2S 5
0009d8 2766      	CLR  R22
0009d9 2777      	CLR  R23
0009da 940e 140e 	CALL __SWAPD12
0009dc 940e 132e 	CALL __SUBD12
0009de 940e 127c 	CALL SUBOPT_0x3B
0009e0 940e 132e 	CALL __SUBD12
0009e2 937f      	PUSH R23
0009e3 936f      	PUSH R22
0009e4 93ff      	PUSH R31
0009e5 93ef      	PUSH R30
0009e6 940e 1288 	CALL SUBOPT_0x3D
0009e8 91af      	POP  R26
0009e9 91bf      	POP  R27
0009ea 918f      	POP  R24
0009eb 919f      	POP  R25
0009ec 2766      	CLR  R22
0009ed 2777      	CLR  R23
0009ee 940e 1333 	CALL __SUBD21
0009f0 a9ed      	LDD  R30,Y+53
0009f1 a9fe      	LDD  R31,Y+53+1
0009f2 940e 1290 	CALL SUBOPT_0x3E
0009f4 940e 13a6 	CALL __DIVD21U
                +
0009f6 5fee     +SUBI R30 , LOW ( - 2 )
0009f7 4fff     +SBCI R31 , HIGH ( - 2 )
0009f8 4f6f     +SBCI R22 , BYTE3 ( - 2 )
0009f9 4f7f     +SBCI R23 , BYTE4 ( - 2 )
                 	__ADDD1N 2
                +
0009fa 83e9     +STD Y + 1 , R30
0009fb 83fa     +STD Y + 1 + 1 , R31
0009fc 836b     +STD Y + 1 + 2 , R22
0009fd 837c     +STD Y + 1 + 3 , R23
                 	__PUTD1S 1
                 ; 0002 01F6 	fs->max_clust = (CLUST)mclst;
                +
0009fe a9ad     +LDD R26 , Y + 53
0009ff a9be     +LDD R27 , Y + 53 + 1
000a00 9618     +ADIW R26 , 8
000a01 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 53,8
                 ; 0002 01F7 
                 ; 0002 01F8 	fmt = FS_FAT12;							/* Determine the FAT sub type */
000a03 e011      	LDI  R17,LOW(1)
                 ; 0002 01F9 	if (mclst >= 0xFF7) fmt = FS_FAT16;		/* Number of clusters >= 0xFF5 */
                +
000a04 81a9     +LDD R26 , Y + 1
000a05 81ba     +LDD R27 , Y + 1 + 1
000a06 818b     +LDD R24 , Y + 1 + 2
000a07 819c     +LDD R25 , Y + 1 + 3
                 	__GETD2S 1
                +
000a08 3fa7     +CPI R26 , LOW ( 0xFF7 )
000a09 e0ef     +LDI R30 , HIGH ( 0xFF7 )
000a0a 07be     +CPC R27 , R30
000a0b e0e0     +LDI R30 , BYTE3 ( 0xFF7 )
000a0c 078e     +CPC R24 , R30
000a0d e0e0     +LDI R30 , BYTE4 ( 0xFF7 )
000a0e 079e     +CPC R25 , R30
                 	__CPD2N 0xFF7
000a0f f008      	BRLO _0x40090
000a10 e012      	LDI  R17,LOW(2)
                 ; 0002 01FA 	if (mclst >= 0xFFF7)					/* Number of clusters >= 0xFFF5 */
                 _0x40090:
                +
000a11 81a9     +LDD R26 , Y + 1
000a12 81ba     +LDD R27 , Y + 1 + 1
000a13 818b     +LDD R24 , Y + 1 + 2
000a14 819c     +LDD R25 , Y + 1 + 3
                 	__GETD2S 1
                +
000a15 3fa7     +CPI R26 , LOW ( 0xFFF7 )
000a16 efef     +LDI R30 , HIGH ( 0xFFF7 )
000a17 07be     +CPC R27 , R30
000a18 e0e0     +LDI R30 , BYTE3 ( 0xFFF7 )
000a19 078e     +CPC R24 , R30
000a1a e0e0     +LDI R30 , BYTE4 ( 0xFFF7 )
000a1b 079e     +CPC R25 , R30
                 	__CPD2N 0xFFF7
000a1c f008      	BRLO _0x40091
                 ; 0002 01FB #if _FS_FAT32
                 ; 0002 01FC 		fmt = FS_FAT32;
000a1d e013      	LDI  R17,LOW(3)
                 ; 0002 01FD #else
                 ; 0002 01FE 		return FR_NO_FILESYSTEM;
                 ; 0002 01FF #endif
                 ; 0002 0200 
                 ; 0002 0201 	fs->fs_type = fmt;		/* FAT sub-type */
                 _0x40091:
000a1e a9ad      	LDD  R26,Y+53
000a1f a9be      	LDD  R27,Y+53+1
000a20 931c      	ST   X,R17
                 ; 0002 0202 #if _FS_FAT32
                 ; 0002 0203 	if (fmt == FS_FAT32)
000a21 3013      	CPI  R17,3
000a22 f429      	BRNE _0x40092
                 ; 0002 0204 		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
                +
000a23 a9e8     +LDD R30 , Y + 48
000a24 a9f9     +LDD R31 , Y + 48 + 1
000a25 a96a     +LDD R22 , Y + 48 + 2
000a26 a97b     +LDD R23 , Y + 48 + 3
                 	__GETD1S 48
000a27 c002      	RJMP _0x400E6
                 ; 0002 0205 	else
                 _0x40092:
                 ; 0002 0206 #endif
                 ; 0002 0207 		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
000a28 940e 1295 	CALL SUBOPT_0x3F
                 _0x400E6:
                +
000a2a a9ad     +LDD R26 , Y + 53
000a2b a9be     +LDD R27 , Y + 53 + 1
000a2c 9650     +ADIW R26 , 16
000a2d 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 53,16
                 ; 0002 0208 	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
000a2f 940e 1295 	CALL SUBOPT_0x3F
000a31 937f      	PUSH R23
000a32 936f      	PUSH R22
000a33 93ff      	PUSH R31
000a34 93ef      	PUSH R30
000a35 940e 1288 	CALL SUBOPT_0x3D
000a37 91af      	POP  R26
000a38 91bf      	POP  R27
000a39 918f      	POP  R24
000a3a 919f      	POP  R25
000a3b 940e 1190 	CALL SUBOPT_0x15
                +
000a3d a9ad     +LDD R26 , Y + 53
000a3e a9be     +LDD R27 , Y + 53 + 1
000a3f 9654     +ADIW R26 , 20
000a40 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 53,20
                 ; 0002 0209 
                 ; 0002 020A 	fs->flag = 0;
000a42 a9ad      	LDD  R26,Y+53
000a43 a9be      	LDD  R27,Y+53+1
000a44 9612      	ADIW R26,2
000a45 e0e0      	LDI  R30,LOW(0)
000a46 93ec      	ST   X,R30
                 ; 0002 020B 	FatFs = fs;
000a47 a9ed      	LDD  R30,Y+53
000a48 a9fe      	LDD  R31,Y+53+1
000a49 93e0 0921 	STS  _FatFs_G002,R30
000a4b 93f0 0922 	STS  _FatFs_G002+1,R31
                 ; 0002 020C 
                 ; 0002 020D 	return FR_OK;
                 _0x20C0009:
000a4d e0e0      	LDI  R30,LOW(0)
                 _0x20C0008:
000a4e 8118      	LDD  R17,Y+0
000a4f 96e7      	ADIW R28,55
000a50 9508      	RET
                 ; 0002 020E }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Open or Create a File                                                 */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;FRESULT pf_open (
                 ; 0002 0218 	const char *path	/* Pointer to the file name */
                 ; 0002 0219 )
                 ; 0002 021A {
                 _pf_open:
                 ; .FSTART _pf_open
                 ; 0002 021B 	FRESULT res;
                 ; 0002 021C 	DIR dj;
                 ; 0002 021D 	BYTE sp[12], dir[32];
                 ; 0002 021E 	FATFS *fs = FatFs;
                 ; 0002 021F 
                 ; 0002 0220 
                 ; 0002 0221 	if (!fs)						/* Check file system */
000a51 93ba      	ST   -Y,R27
000a52 93aa      	ST   -Y,R26
000a53 97ec      	SBIW R28,60
000a54 940e 1216 	CALL SUBOPT_0x2B
                 ;	*path -> Y+64
                 ;	res -> R17
                 ;	dj -> Y+48
                 ;	sp -> Y+36
                 ;	dir -> Y+4
                 ;	*fs -> R18,R19
000a56 2e02      	MOV  R0,R18
000a57 2a03      	OR   R0,R19
000a58 f411      	BRNE _0x40094
                 ; 0002 0222 		return FR_NOT_ENABLED;
000a59 e0e6      	LDI  R30,LOW(6)
000a5a c04a      	RJMP _0x20C0007
                 ; 0002 0223 
                 ; 0002 0224 	fs->flag = 0;
                 _0x40094:
000a5b 01d9      	MOVW R26,R18
000a5c 9612      	ADIW R26,2
000a5d e0e0      	LDI  R30,LOW(0)
000a5e 93ec      	ST   X,R30
                 ; 0002 0225 	fs->buf = dir;
000a5f 01fe      	MOVW R30,R28
000a60 9634      	ADIW R30,4
                +
000a61 01d9     +MOVW R26 , R18
000a62 9616     +ADIW R26 , 6
000a63 93ed     +ST X + , R30
000a64 93fc     +ST X , R31
                 	__PUTW1RNS 18,6
                 ; 0002 0226 	dj.fn = sp;
000a65 01fe      	MOVW R30,R28
000a66 96b4      	ADIW R30,36
000a67 abea      	STD  Y+50,R30
000a68 abfb      	STD  Y+50+1,R31
                 ; 0002 0227 	res = follow_path(&dj, path);	/* Follow the file path */
000a69 01fe      	MOVW R30,R28
000a6a 96f0      	ADIW R30,48
000a6b 93fa      	ST   -Y,R31
000a6c 93ea      	ST   -Y,R30
                +
000a6d 01de     +MOVW R26 , R28
000a6e 5bae     +SUBI R26 , LOW ( - 66 )
000a6f 4fbf     +SBCI R27 , HIGH ( - 66 )
000a70 900d     +LD R0 , X +
000a71 91bc     +LD R27 , X
000a72 2da0     +MOV R26 , R0
                 	__GETW2SX 66
000a73 de11      	RCALL _follow_path_G002
000a74 2f1e      	MOV  R17,R30
                 ; 0002 0228 	if (res != FR_OK) return res;	/* Follow failed */
000a75 3010      	CPI  R17,0
000a76 f009      	BREQ _0x40095
000a77 c02d      	RJMP _0x20C0007
                 ; 0002 0229 	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
                 _0x40095:
000a78 81ec      	LDD  R30,Y+4
000a79 30e0      	CPI  R30,0
000a7a f019      	BREQ _0x40097
000a7b 85ef      	LDD  R30,Y+15
000a7c 71e0      	ANDI R30,LOW(0x10)
000a7d f011      	BREQ _0x40096
                 _0x40097:
                 ; 0002 022A 		return FR_NO_FILE;
000a7e e0e3      	LDI  R30,LOW(3)
000a7f c025      	RJMP _0x20C0007
                 ; 0002 022B 
                 ; 0002 022C 	fs->org_clust =						/* File start cluster */
                 _0x40096:
                 ; 0002 022D #if _FS_FAT32
                 ; 0002 022E 		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
                 ; 0002 022F #endif
                 ; 0002 0230 		LD_WORD(dir+DIR_FstClusLO);
000a80 8de8      	LDD  R30,Y+24
000a81 8df9      	LDD  R31,Y+24+1
000a82 2766      	CLR  R22
000a83 2777      	CLR  R23
000a84 940e 1369 	CALL __LSLD16
000a86 01df      	MOVW R26,R30
000a87 01cb      	MOVW R24,R22
000a88 8dee      	LDD  R30,Y+30
000a89 8dff      	LDD  R31,Y+30+1
000a8a 2766      	CLR  R22
000a8b 2777      	CLR  R23
000a8c 940e 1338 	CALL __ORD12
                +
000a8e 01d9     +MOVW R26 , R18
000a8f 9690     +ADIW R26 , 32
000a90 940e 13de+CALL __PUTDP1
                 	__PUTD1RNS 18,32
                 ; 0002 0231 	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
                +
000a92 a1e8     +LDD R30 , Y + 32
000a93 a1f9     +LDD R31 , Y + 32 + 1
000a94 a16a     +LDD R22 , Y + 32 + 2
000a95 a17b     +LDD R23 , Y + 32 + 3
                 	__GETD1S 32
                +
000a96 01d9     +MOVW R26 , R18
000a97 965c     +ADIW R26 , 28
000a98 940e 13de+CALL __PUTDP1
                 	__PUTD1RNS 18,28
                 ; 0002 0232 	fs->fptr = 0;						/* File pointer */
000a9a 01d9      	MOVW R26,R18
000a9b 9658      	ADIW R26,24
000a9c 940e 120c 	CALL SUBOPT_0x29
000a9e 940e 13de 	CALL __PUTDP1
                 ; 0002 0233 	fs->flag = FA_OPENED;
000aa0 01d9      	MOVW R26,R18
000aa1 9612      	ADIW R26,2
000aa2 e0e1      	LDI  R30,LOW(1)
000aa3 93ec      	ST   X,R30
                 ; 0002 0234 
                 ; 0002 0235 	return FR_OK;
000aa4 e0e0      	LDI  R30,LOW(0)
                 _0x20C0007:
000aa5 940e 1469 	CALL __LOADLOCR4
000aa7 96ef      	ADIW R28,63
000aa8 9623      	ADIW R28,3
000aa9 9508      	RET
                 ; 0002 0236 }
                 ; .FEND
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Read File                                                             */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_READ
                 ;
                 ;FRESULT pf_read (
                 ; 0002 0241 	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
                 ; 0002 0242 	WORD btr,		/* Number of bytes to read */
                 ; 0002 0243 	WORD* br		/* Pointer to number of bytes read */
                 ; 0002 0244 )
                 ; 0002 0245 {
                 _pf_read:
                 ; .FSTART _pf_read
                 ; 0002 0246 	DRESULT dr;
                 ; 0002 0247 	CLUST clst;
                 ; 0002 0248 	DWORD sect, remain;
                 ; 0002 0249 	BYTE *rbuff = buff;
                 ; 0002 024A 	WORD rcnt;
                 ; 0002 024B 	FATFS *fs = FatFs;
                 ; 0002 024C 
                 ; 0002 024D 
                 ; 0002 024E 	*br = 0;
000aaa 93ba      	ST   -Y,R27
000aab 93aa      	ST   -Y,R26
000aac 972e      	SBIW R28,14
000aad 940e 1460 	CALL __SAVELOCR6
                 ;	*buff -> Y+24
                 ;	btr -> Y+22
                 ;	*br -> Y+20
                 ;	dr -> R17
                 ;	clst -> Y+16
                 ;	sect -> Y+12
                 ;	remain -> Y+8
                 ;	*rbuff -> R18,R19
                 ;	rcnt -> R20,R21
                 ;	*fs -> Y+6
                +
000aaf 8d28     +LDD R18 , Y + 24
000ab0 8d39     +LDD R19 , Y + 24 + 1
                 	__GETWRS 18,19,24
000ab1 940e 11a8 	CALL SUBOPT_0x19
000ab3 83ee      	STD  Y+6,R30
000ab4 83ff      	STD  Y+6+1,R31
000ab5 89ac      	LDD  R26,Y+20
000ab6 89bd      	LDD  R27,Y+20+1
000ab7 940e 1211 	CALL SUBOPT_0x2A
                 ; 0002 024F 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
000ab9 81ee      	LDD  R30,Y+6
000aba 81ff      	LDD  R31,Y+6+1
000abb 9730      	SBIW R30,0
000abc f411      	BRNE _0x40099
000abd e0e6      	LDI  R30,LOW(6)
000abe c0dd      	RJMP _0x20C0006
                 ; 0002 0250 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
                 _0x40099:
000abf 81ee      	LDD  R30,Y+6
000ac0 81ff      	LDD  R31,Y+6+1
000ac1 81a2      	LDD  R26,Z+2
000ac2 70a1      	ANDI R26,LOW(0x1)
000ac3 f411      	BRNE _0x4009A
                 ; 0002 0251 		return FR_NOT_OPENED;
000ac4 e0e5      	LDI  R30,LOW(5)
000ac5 c0d6      	RJMP _0x20C0006
                 ; 0002 0252 
                 ; 0002 0253 	remain = fs->fsize - fs->fptr;
                 _0x4009A:
000ac6 81ee      	LDD  R30,Y+6
000ac7 81ff      	LDD  R31,Y+6+1
                +
000ac8 8da4     +LDD R26 , Z + 28
000ac9 8db5     +LDD R27 , Z + 28 + 1
000aca 8d86     +LDD R24 , Z + 28 + 2
000acb 8d97     +LDD R25 , Z + 28 + 3
                 	__GETD2Z 28
000acc 939f      	PUSH R25
000acd 938f      	PUSH R24
000ace 93bf      	PUSH R27
000acf 93af      	PUSH R26
000ad0 940e 129c 	CALL SUBOPT_0x40
000ad2 91ef      	POP  R30
000ad3 91ff      	POP  R31
000ad4 916f      	POP  R22
000ad5 917f      	POP  R23
000ad6 940e 132e 	CALL __SUBD12
                +
000ad8 87e8     +STD Y + 8 , R30
000ad9 87f9     +STD Y + 8 + 1 , R31
000ada 876a     +STD Y + 8 + 2 , R22
000adb 877b     +STD Y + 8 + 3 , R23
                 	__PUTD1S 8
                 ; 0002 0254 	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
000adc 940e 1186 	CALL SUBOPT_0x13
000ade 89ae      	LDD  R26,Y+22
000adf 89bf      	LDD  R27,Y+22+1
000ae0 2788      	CLR  R24
000ae1 2799      	CLR  R25
000ae2 940e 1456 	CALL __CPD12
000ae4 f420      	BRSH _0x4009B
000ae5 85e8      	LDD  R30,Y+8
000ae6 85f9      	LDD  R31,Y+8+1
000ae7 8bee      	STD  Y+22,R30
000ae8 8bff      	STD  Y+22+1,R31
                 ; 0002 0255 
                 ; 0002 0256 	while (btr)	{									/* Repeat until all data transferred */
                 _0x4009B:
                 _0x4009C:
000ae9 89ee      	LDD  R30,Y+22
000aea 89ff      	LDD  R31,Y+22+1
000aeb 9730      	SBIW R30,0
000aec f409      	BRNE PC+2
000aed c0a6      	RJMP _0x4009E
                 ; 0002 0257 		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
000aee 940e 129c 	CALL SUBOPT_0x40
000af0 01fd      	MOVW R30,R26
000af1 01bc      	MOVW R22,R24
000af2 70f1      	ANDI R31,HIGH(0x1FF)
000af3 9730      	SBIW R30,0
000af4 f009      	BREQ PC+2
000af5 c04f      	RJMP _0x4009F
                 ; 0002 0258 			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
000af6 940e 129c 	CALL SUBOPT_0x40
000af8 940e 12a3 	CALL SUBOPT_0x41
000afa 81ee      	LDD  R30,Y+6
000afb 81ff      	LDD  R31,Y+6+1
000afc 940e 1290 	CALL SUBOPT_0x3E
000afe 940e 13cb 	CALL __MODD21U
000b00 940e 1448 	CALL __CPD10
000b02 f541      	BRNE _0x400A0
                 ; 0002 0259 				clst = (fs->fptr == 0) ?			/* On the top of the file? */
                 ; 0002 025A 					fs->org_clust : get_fat(fs->curr_clust);
000b03 940e 129c 	CALL SUBOPT_0x40
000b05 940e 1450 	CALL __CPD02
000b07 f431      	BRNE _0x400A1
000b08 81ae      	LDD  R26,Y+6
000b09 81bf      	LDD  R27,Y+6+1
000b0a 9690      	ADIW R26,32
000b0b 940e 13d3 	CALL __GETD1P
000b0d c003      	RJMP _0x400A2
                 _0x400A1:
000b0e 940e 12ac 	CALL SUBOPT_0x42
000b10 dae5      	RCALL _get_fat_G002
                 _0x400A2:
                +
000b11 8be8     +STD Y + 16 , R30
000b12 8bf9     +STD Y + 16 + 1 , R31
000b13 8b6a     +STD Y + 16 + 2 , R22
000b14 8b7b     +STD Y + 16 + 3 , R23
                 	__PUTD1S 16
                 ; 0002 025B 				if (clst <= 1) goto fr_abort;
                +
000b15 89a8     +LDD R26 , Y + 16
000b16 89b9     +LDD R27 , Y + 16 + 1
000b17 898a     +LDD R24 , Y + 16 + 2
000b18 899b     +LDD R25 , Y + 16 + 3
                 	__GETD2S 16
000b19 940e 11b2 	CALL SUBOPT_0x1B
000b1b f408      	BRSH _0x400A4
000b1c c079      	RJMP _0x400A5
                 ; 0002 025C 				fs->curr_clust = clst;				/* Update current cluster */
                 _0x400A4:
                +
000b1d 89e8     +LDD R30 , Y + 16
000b1e 89f9     +LDD R31 , Y + 16 + 1
000b1f 896a     +LDD R22 , Y + 16 + 2
000b20 897b     +LDD R23 , Y + 16 + 3
                 	__GETD1S 16
                +
000b21 81ae     +LDD R26 , Y + 6
000b22 81bf     +LDD R27 , Y + 6 + 1
000b23 9694     +ADIW R26 , 36
000b24 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 6,36
                 ; 0002 025D 				fs->csect = 0;						/* Reset sector offset in the cluster */
000b26 81ae      	LDD  R26,Y+6
000b27 81bf      	LDD  R27,Y+6+1
000b28 9613      	ADIW R26,3
000b29 e0e0      	LDI  R30,LOW(0)
000b2a 93ec      	ST   X,R30
                 ; 0002 025E 			}
                 ; 0002 025F 			sect = clust2sect(fs->curr_clust);		/* Get current sector */
                 _0x400A0:
000b2b 940e 12ac 	CALL SUBOPT_0x42
000b2d db8b      	RCALL _clust2sect_G002
                +
000b2e 87ec     +STD Y + 12 , R30
000b2f 87fd     +STD Y + 12 + 1 , R31
000b30 876e     +STD Y + 12 + 2 , R22
000b31 877f     +STD Y + 12 + 3 , R23
                 	__PUTD1S 12
                 ; 0002 0260 			if (!sect) goto fr_abort;
000b32 940e 1448 	CALL __CPD10
000b34 f409      	BRNE _0x400A6
000b35 c060      	RJMP _0x400A5
                 ; 0002 0261 			fs->dsect = sect + fs->csect++;
                 _0x400A6:
000b36 81ae      	LDD  R26,Y+6
000b37 81bf      	LDD  R27,Y+6+1
000b38 940e 12b3 	CALL SUBOPT_0x43
000b3a 940e 11ad 	CALL SUBOPT_0x1A
000b3c 940e 136e 	CALL __CWD1
000b3e 940e 1324 	CALL __ADDD12
                +
000b40 81ae     +LDD R26 , Y + 6
000b41 81bf     +LDD R27 , Y + 6 + 1
000b42 9698     +ADIW R26 , 40
000b43 940e 13de+CALL __PUTDP1
                 	__PUTD1SNS 6,40
                 ; 0002 0262 		}
                 ; 0002 0263 		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
                 _0x4009F:
000b45 81ee      	LDD  R30,Y+6
000b46 81ff      	LDD  R31,Y+6+1
000b47 940e 12ba 	CALL SUBOPT_0x44
000b49 e0a0      	LDI  R26,LOW(512)
000b4a e0b2      	LDI  R27,HIGH(512)
000b4b 1bae      	SUB  R26,R30
000b4c 0bbf      	SBC  R27,R31
000b4d 01ad      	MOVW R20,R26
                 ; 0002 0264 		if (rcnt > btr) rcnt = btr;
000b4e 89ee      	LDD  R30,Y+22
000b4f 89ff      	LDD  R31,Y+22+1
000b50 17e4      	CP   R30,R20
000b51 07f5      	CPC  R31,R21
000b52 f410      	BRSH _0x400A7
                +
000b53 894e     +LDD R20 , Y + 22
000b54 895f     +LDD R21 , Y + 22 + 1
                 	__GETWRS 20,21,22
                 ; 0002 0265 		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
                 _0x400A7:
000b55 8de8      	LDD  R30,Y+24
000b56 8df9      	LDD  R31,Y+24+1
000b57 9730      	SBIW R30,0
000b58 f419      	BRNE _0x400A8
000b59 e0e0      	LDI  R30,LOW(0)
000b5a e0f0      	LDI  R31,HIGH(0)
000b5b c001      	RJMP _0x400A9
                 _0x400A8:
000b5c 01f9      	MOVW R30,R18
                 _0x400A9:
000b5d 93fa      	ST   -Y,R31
000b5e 93ea      	ST   -Y,R30
000b5f 85e8      	LDD  R30,Y+8
000b60 85f9      	LDD  R31,Y+8+1
                +
000b61 a5a0     +LDD R26 , Z + 40
000b62 a5b1     +LDD R27 , Z + 40 + 1
000b63 a582     +LDD R24 , Z + 40 + 2
000b64 a593     +LDD R25 , Z + 40 + 3
                 	__GETD2Z 40
000b65 940e 1409 	CALL __PUTPARD2
000b67 85ac      	LDD  R26,Y+12
000b68 85bd      	LDD  R27,Y+12+1
000b69 9658      	ADIW R26,24
000b6a 940e 13cf 	CALL __GETW1P
000b6c 70f1      	ANDI R31,HIGH(0x1FF)
000b6d 93fa      	ST   -Y,R31
000b6e 93ea      	ST   -Y,R30
000b6f 01da      	MOVW R26,R20
000b70 d246      	RCALL _disk_readp
000b71 2f1e      	MOV  R17,R30
                 ; 0002 0266 		if (dr) goto fr_abort;
000b72 3010      	CPI  R17,0
000b73 f511      	BRNE _0x400A5
                 ; 0002 0267 		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
000b74 81ee      	LDD  R30,Y+6
000b75 81ff      	LDD  R31,Y+6+1
000b76 9678      	ADIW R30,24
000b77 010f      	MOVW R0,R30
000b78 01df      	MOVW R26,R30
000b79 940e 13d3 	CALL __GETD1P
000b7b 01df      	MOVW R26,R30
000b7c 01cb      	MOVW R24,R22
000b7d 01fa      	MOVW R30,R20
000b7e 940e 1190 	CALL SUBOPT_0x15
000b80 01d0      	MOVW R26,R0
000b81 940e 13de 	CALL __PUTDP1
                +
000b83 0f24     +ADD R18 , R20
000b84 1f35     +ADC R19 , R21
                 	__ADDWRR 18,19,20,21
                 ; 0002 0268 		btr -= rcnt; *br += rcnt;
000b85 89ee      	LDD  R30,Y+22
000b86 89ff      	LDD  R31,Y+22+1
000b87 1be4      	SUB  R30,R20
000b88 0bf5      	SBC  R31,R21
000b89 8bee      	STD  Y+22,R30
000b8a 8bff      	STD  Y+22+1,R31
000b8b 89ac      	LDD  R26,Y+20
000b8c 89bd      	LDD  R27,Y+20+1
000b8d 91ed      	LD   R30,X+
000b8e 91fd      	LD   R31,X+
000b8f 0fe4      	ADD  R30,R20
000b90 1ff5      	ADC  R31,R21
000b91 93fe      	ST   -X,R31
000b92 93ee      	ST   -X,R30
                 ; 0002 0269 	}
000b93 cf55      	RJMP _0x4009C
                 _0x4009E:
                 ; 0002 026A 
                 ; 0002 026B 	return FR_OK;
000b94 e0e0      	LDI  R30,LOW(0)
000b95 c006      	RJMP _0x20C0006
                 ; 0002 026C 
                 ; 0002 026D fr_abort:
                 _0x400A5:
                 ; 0002 026E 	fs->flag = 0;
000b96 81ae      	LDD  R26,Y+6
000b97 81bf      	LDD  R27,Y+6+1
000b98 9612      	ADIW R26,2
000b99 e0e0      	LDI  R30,LOW(0)
000b9a 93ec      	ST   X,R30
                 ; 0002 026F 	return FR_DISK_ERR;
000b9b e0e1      	LDI  R30,LOW(1)
                 _0x20C0006:
000b9c 940e 1467 	CALL __LOADLOCR6
000b9e 966a      	ADIW R28,26
000b9f 9508      	RET
                 ; 0002 0270 }
                 ; .FEND
                 ;#endif
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Write File                                                            */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_WRITE
                 ;
                 ;FRESULT pf_write (
                 ; 0002 027B 	const void* buff,	/* Pointer to the data to be written */
                 ; 0002 027C 	WORD btw,			/* Number of bytes to write (0:Finalize the current write operation) */
                 ; 0002 027D 	WORD* bw			/* Pointer to number of bytes written */
                 ; 0002 027E )
                 ; 0002 027F {
                 _pf_write:
                 ; .FSTART _pf_write
                 ; 0002 0280 	CLUST clst;
                 ; 0002 0281 	DWORD sect, remain;
                 ; 0002 0282 	const BYTE *p = buff;
                 ; 0002 0283 	WORD wcnt;
                 ; 0002 0284 	FATFS *fs = FatFs;
                 ; 0002 0285 
                 ; 0002 0286 
                 ; 0002 0287 	*bw = 0;
000ba0 93ba      	ST   -Y,R27
000ba1 93aa      	ST   -Y,R26
000ba2 972c      	SBIW R28,12
000ba3 940e 1460 	CALL __SAVELOCR6
                 ;	*buff -> Y+22
                 ;	btw -> Y+20
                 ;	*bw -> Y+18
                 ;	clst -> Y+14
                 ;	sect -> Y+10
                 ;	remain -> Y+6
                 ;	*p -> R16,R17
                 ;	wcnt -> R18,R19
                 ;	*fs -> R20,R21
                +
000ba5 890e     +LDD R16 , Y + 22
000ba6 891f     +LDD R17 , Y + 22 + 1
                 	__GETWRS 16,17,22
                +
000ba7 9140 0921+LDS R20 , 0 + ( _FatFs_G002 )
000ba9 9150 0922+LDS R21 , 0 + ( _FatFs_G002 ) + 1
                 	__GETWRMN 20,21,0,_FatFs_G002
000bab 89aa      	LDD  R26,Y+18
000bac 89bb      	LDD  R27,Y+18+1
000bad 940e 1211 	CALL SUBOPT_0x2A
                 ; 0002 0288 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
000baf 2e04      	MOV  R0,R20
000bb0 2a05      	OR   R0,R21
000bb1 f419      	BRNE _0x400AC
000bb2 e0e6      	LDI  R30,LOW(6)
000bb3 940c 0feb 	JMP  _0x20C0003
                 ; 0002 0289 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
                 _0x400AC:
000bb5 01fa      	MOVW R30,R20
000bb6 81a2      	LDD  R26,Z+2
000bb7 70a1      	ANDI R26,LOW(0x1)
000bb8 f419      	BRNE _0x400AD
                 ; 0002 028A 		return FR_NOT_OPENED;
000bb9 e0e5      	LDI  R30,LOW(5)
000bba 940c 0feb 	JMP  _0x20C0003
                 ; 0002 028B 
                 ; 0002 028C 	if (!btw) {		/* Finalize request */
                 _0x400AD:
000bbc 89ec      	LDD  R30,Y+20
000bbd 89fd      	LDD  R31,Y+20+1
000bbe 9730      	SBIW R30,0
000bbf f499      	BRNE _0x400AE
                 ; 0002 028D 		if ((fs->flag & FA__WIP) && disk_writep(0, 0)) goto fw_abort;
000bc0 01fa      	MOVW R30,R20
000bc1 81a2      	LDD  R26,Z+2
000bc2 74a0      	ANDI R26,LOW(0x40)
000bc3 f029      	BREQ _0x400B0
000bc4 940e 12bf 	CALL SUBOPT_0x45
000bc6 940e 12c4 	CALL SUBOPT_0x46
000bc8 f409      	BRNE _0x400B1
                 _0x400B0:
000bc9 c001      	RJMP _0x400AF
                 _0x400B1:
000bca c0e6      	RJMP _0x400B2
                 ; 0002 028E 		fs->flag &= ~FA__WIP;
                 _0x400AF:
000bcb 01da      	MOVW R26,R20
000bcc 9612      	ADIW R26,2
000bcd 91ec      	LD   R30,X
000bce 7bef      	ANDI R30,0xBF
000bcf 93ec      	ST   X,R30
                 ; 0002 028F 		return FR_OK;
000bd0 e0e0      	LDI  R30,LOW(0)
000bd1 940c 0feb 	JMP  _0x20C0003
                 ; 0002 0290 	} else {		/* Write data request */
                 _0x400AE:
                 ; 0002 0291 		if (!(fs->flag & FA__WIP))		/* Round down fptr to the sector boundary */
000bd3 01fa      	MOVW R30,R20
000bd4 81a2      	LDD  R26,Z+2
000bd5 74a0      	ANDI R26,LOW(0x40)
000bd6 f441      	BRNE _0x400B4
                 ; 0002 0292 			fs->fptr &= 0xFFFFFE00;
000bd7 01da      	MOVW R26,R20
000bd8 9658      	ADIW R26,24
000bd9 91ed      	LD   R30,X+
000bda 91fd      	LD   R31,X+
000bdb 70e0      	ANDI R30,LOW(0xFFFFFE00)
000bdc 7ffe      	ANDI R31,HIGH(0xFFFFFE00)
000bdd 93fe      	ST   -X,R31
000bde 93ee      	ST   -X,R30
                 ; 0002 0293 	}
                 _0x400B4:
                 ; 0002 0294 	remain = fs->fsize - fs->fptr;
000bdf 01fa      	MOVW R30,R20
                +
000be0 8da4     +LDD R26 , Z + 28
000be1 8db5     +LDD R27 , Z + 28 + 1
000be2 8d86     +LDD R24 , Z + 28 + 2
000be3 8d97     +LDD R25 , Z + 28 + 3
                 	__GETD2Z 28
000be4 939f      	PUSH R25
000be5 938f      	PUSH R24
000be6 93bf      	PUSH R27
000be7 93af      	PUSH R26
000be8 940e 12cc 	CALL SUBOPT_0x47
000bea 91ef      	POP  R30
000beb 91ff      	POP  R31
000bec 916f      	POP  R22
000bed 917f      	POP  R23
000bee 940e 132e 	CALL __SUBD12
000bf0 940e 1164 	CALL SUBOPT_0xF
                 ; 0002 0295 	if (btw > remain) btw = (WORD)remain;			/* Truncate btw by remaining bytes */
000bf2 940e 115f 	CALL SUBOPT_0xE
000bf4 89ac      	LDD  R26,Y+20
000bf5 89bd      	LDD  R27,Y+20+1
000bf6 2788      	CLR  R24
000bf7 2799      	CLR  R25
000bf8 940e 1456 	CALL __CPD12
000bfa f420      	BRSH _0x400B5
000bfb 81ee      	LDD  R30,Y+6
000bfc 81ff      	LDD  R31,Y+6+1
000bfd 8bec      	STD  Y+20,R30
000bfe 8bfd      	STD  Y+20+1,R31
                 ; 0002 0296 
                 ; 0002 0297 	while (btw)	{									/* Repeat until all data transferred */
                 _0x400B5:
                 _0x400B6:
000bff 89ec      	LDD  R30,Y+20
000c00 89fd      	LDD  R31,Y+20+1
000c01 9730      	SBIW R30,0
000c02 f409      	BRNE PC+2
000c03 c0aa      	RJMP _0x400B8
                 ; 0002 0298 		if (((WORD)fs->fptr % 512) == 0) {				/* On the sector boundary? */
000c04 01fa      	MOVW R30,R20
000c05 940e 12ba 	CALL SUBOPT_0x44
000c07 9730      	SBIW R30,0
000c08 f009      	BREQ PC+2
000c09 c05f      	RJMP _0x400B9
                 ; 0002 0299 			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
000c0a 940e 12cc 	CALL SUBOPT_0x47
000c0c 940e 12a3 	CALL SUBOPT_0x41
000c0e 01fa      	MOVW R30,R20
000c0f 940e 1290 	CALL SUBOPT_0x3E
000c11 940e 13cb 	CALL __MODD21U
000c13 940e 1448 	CALL __CPD10
000c15 f531      	BRNE _0x400BA
                 ; 0002 029A 				clst = (fs->fptr == 0) ?			/* On the top of the file? */
                 ; 0002 029B 					fs->org_clust : get_fat(fs->curr_clust);
000c16 940e 12cc 	CALL SUBOPT_0x47
000c18 940e 1450 	CALL __CPD02
000c1a f429      	BRNE _0x400BB
000c1b 01da      	MOVW R26,R20
000c1c 9690      	ADIW R26,32
000c1d 940e 13d3 	CALL __GETD1P
000c1f c006      	RJMP _0x400BC
                 _0x400BB:
000c20 01fa      	MOVW R30,R20
                +
000c21 a1a4     +LDD R26 , Z + 36
000c22 a1b5     +LDD R27 , Z + 36 + 1
000c23 a186     +LDD R24 , Z + 36 + 2
000c24 a197     +LDD R25 , Z + 36 + 3
                 	__GETD2Z 36
000c25 d9d0      	RCALL _get_fat_G002
                 _0x400BC:
                +
000c26 87ee     +STD Y + 14 , R30
000c27 87ff     +STD Y + 14 + 1 , R31
000c28 8b68     +STD Y + 14 + 2 , R22
000c29 8b79     +STD Y + 14 + 3 , R23
                 	__PUTD1S 14
                 ; 0002 029C 				if (clst <= 1) goto fw_abort;
000c2a 940e 11e2 	CALL SUBOPT_0x21
000c2c 940e 11b2 	CALL SUBOPT_0x1B
000c2e f408      	BRSH _0x400BE
000c2f c081      	RJMP _0x400B2
                 ; 0002 029D 				fs->curr_clust = clst;				/* Update current cluster */
                 _0x400BE:
                +
000c30 85ee     +LDD R30 , Y + 14
000c31 85ff     +LDD R31 , Y + 14 + 1
000c32 8968     +LDD R22 , Y + 14 + 2
000c33 8979     +LDD R23 , Y + 14 + 3
                 	__GETD1S 14
                +
000c34 01da     +MOVW R26 , R20
000c35 9694     +ADIW R26 , 36
000c36 940e 13de+CALL __PUTDP1
                 	__PUTD1RNS 20,36
                 ; 0002 029E 				fs->csect = 0;						/* Reset sector offset in the cluster */
000c38 01da      	MOVW R26,R20
000c39 9613      	ADIW R26,3
000c3a e0e0      	LDI  R30,LOW(0)
000c3b 93ec      	ST   X,R30
                 ; 0002 029F 			}
                 ; 0002 02A0 			sect = clust2sect(fs->curr_clust);		/* Get current sector */
                 _0x400BA:
000c3c 01fa      	MOVW R30,R20
                +
000c3d a1a4     +LDD R26 , Z + 36
000c3e a1b5     +LDD R27 , Z + 36 + 1
000c3f a186     +LDD R24 , Z + 36 + 2
000c40 a197     +LDD R25 , Z + 36 + 3
                 	__GETD2Z 36
000c41 da77      	RCALL _clust2sect_G002
                +
000c42 87ea     +STD Y + 10 , R30
000c43 87fb     +STD Y + 10 + 1 , R31
000c44 876c     +STD Y + 10 + 2 , R22
000c45 877d     +STD Y + 10 + 3 , R23
                 	__PUTD1S 10
                 ; 0002 02A1 			if (!sect) goto fw_abort;
000c46 940e 1195 	CALL SUBOPT_0x16
000c48 940e 1448 	CALL __CPD10
000c4a f409      	BRNE _0x400BF
000c4b c065      	RJMP _0x400B2
                 ; 0002 02A2 			fs->dsect = sect + fs->csect++;
                 _0x400BF:
000c4c 01da      	MOVW R26,R20
000c4d 940e 12b3 	CALL SUBOPT_0x43
000c4f 940e 119a 	CALL SUBOPT_0x17
000c51 940e 136e 	CALL __CWD1
000c53 940e 1324 	CALL __ADDD12
                +
000c55 01da     +MOVW R26 , R20
000c56 9698     +ADIW R26 , 40
000c57 940e 13de+CALL __PUTDP1
                 	__PUTD1RNS 20,40
                 ; 0002 02A3 			if (disk_writep(0, fs->dsect)) goto fw_abort;	/* Initiate a sector write operation */
000c59 940e 12bf 	CALL SUBOPT_0x45
000c5b 01fa      	MOVW R30,R20
                +
000c5c a5a0     +LDD R26 , Z + 40
000c5d a5b1     +LDD R27 , Z + 40 + 1
000c5e a582     +LDD R24 , Z + 40 + 2
000c5f a593     +LDD R25 , Z + 40 + 3
                 	__GETD2Z 40
000c60 d1bc      	RCALL _disk_writep
000c61 30e0      	CPI  R30,0
000c62 f009      	BREQ _0x400C0
000c63 c04d      	RJMP _0x400B2
                 ; 0002 02A4 			fs->flag |= FA__WIP;
                 _0x400C0:
000c64 01da      	MOVW R26,R20
000c65 9612      	ADIW R26,2
000c66 91ec      	LD   R30,X
000c67 64e0      	ORI  R30,0x40
000c68 93ec      	ST   X,R30
                 ; 0002 02A5 		}
                 ; 0002 02A6 		wcnt = 512 - ((WORD)fs->fptr % 512);		/* Number of bytes to write to the sector */
                 _0x400B9:
000c69 01fa      	MOVW R30,R20
000c6a 940e 12ba 	CALL SUBOPT_0x44
000c6c e0a0      	LDI  R26,LOW(512)
000c6d e0b2      	LDI  R27,HIGH(512)
000c6e 1bae      	SUB  R26,R30
000c6f 0bbf      	SBC  R27,R31
000c70 019d      	MOVW R18,R26
                 ; 0002 02A7 		if (wcnt > btw) wcnt = btw;
000c71 89ec      	LDD  R30,Y+20
000c72 89fd      	LDD  R31,Y+20+1
000c73 17e2      	CP   R30,R18
000c74 07f3      	CPC  R31,R19
000c75 f410      	BRSH _0x400C1
                +
000c76 892c     +LDD R18 , Y + 20
000c77 893d     +LDD R19 , Y + 20 + 1
                 	__GETWRS 18,19,20
                 ; 0002 02A8 		if (disk_writep(p, wcnt)) goto fw_abort;	/* Send data to the sector */
                 _0x400C1:
000c78 931a      	ST   -Y,R17
000c79 930a      	ST   -Y,R16
000c7a 01d9      	MOVW R26,R18
000c7b 2788      	CLR  R24
000c7c 2799      	CLR  R25
000c7d d19f      	RCALL _disk_writep
000c7e 30e0      	CPI  R30,0
000c7f f589      	BRNE _0x400B2
                 ; 0002 02A9 		fs->fptr += wcnt; p += wcnt;				/* Update pointers and counters */
000c80 01fa      	MOVW R30,R20
000c81 9678      	ADIW R30,24
000c82 010f      	MOVW R0,R30
000c83 01df      	MOVW R26,R30
000c84 940e 13d3 	CALL __GETD1P
000c86 01df      	MOVW R26,R30
000c87 01cb      	MOVW R24,R22
000c88 01f9      	MOVW R30,R18
000c89 940e 1190 	CALL SUBOPT_0x15
000c8b 01d0      	MOVW R26,R0
000c8c 940e 13de 	CALL __PUTDP1
                +
000c8e 0f02     +ADD R16 , R18
000c8f 1f13     +ADC R17 , R19
                 	__ADDWRR 16,17,18,19
                 ; 0002 02AA 		btw -= wcnt; *bw += wcnt;
000c90 89ec      	LDD  R30,Y+20
000c91 89fd      	LDD  R31,Y+20+1
000c92 1be2      	SUB  R30,R18
000c93 0bf3      	SBC  R31,R19
000c94 8bec      	STD  Y+20,R30
000c95 8bfd      	STD  Y+20+1,R31
000c96 89aa      	LDD  R26,Y+18
000c97 89bb      	LDD  R27,Y+18+1
000c98 91ed      	LD   R30,X+
000c99 91fd      	LD   R31,X+
000c9a 0fe2      	ADD  R30,R18
000c9b 1ff3      	ADC  R31,R19
000c9c 93fe      	ST   -X,R31
000c9d 93ee      	ST   -X,R30
                 ; 0002 02AB 		if (((WORD)fs->fptr % 512) == 0) {
000c9e 01fa      	MOVW R30,R20
000c9f 940e 12ba 	CALL SUBOPT_0x44
000ca1 9730      	SBIW R30,0
000ca2 f451      	BRNE _0x400C3
                 ; 0002 02AC 			if (disk_writep(0, 0)) goto fw_abort;	/* Finalize the currtent secter write operation */
000ca3 940e 12bf 	CALL SUBOPT_0x45
000ca5 940e 12c4 	CALL SUBOPT_0x46
000ca7 f449      	BRNE _0x400B2
                 ; 0002 02AD 			fs->flag &= ~FA__WIP;
000ca8 01da      	MOVW R26,R20
000ca9 9612      	ADIW R26,2
000caa 91ec      	LD   R30,X
000cab 7bef      	ANDI R30,0xBF
000cac 93ec      	ST   X,R30
                 ; 0002 02AE 		}
                 ; 0002 02AF 	}
                 _0x400C3:
000cad cf51      	RJMP _0x400B6
                 _0x400B8:
                 ; 0002 02B0 
                 ; 0002 02B1 	return FR_OK;
000cae e0e0      	LDI  R30,LOW(0)
000caf 940c 0feb 	JMP  _0x20C0003
                 ; 0002 02B2 
                 ; 0002 02B3 fw_abort:
                 _0x400B2:
                 ; 0002 02B4 	fs->flag = 0;
000cb1 01da      	MOVW R26,R20
000cb2 9612      	ADIW R26,2
000cb3 e0e0      	LDI  R30,LOW(0)
000cb4 93ec      	ST   X,R30
                 ; 0002 02B5 	return FR_DISK_ERR;
000cb5 e0e1      	LDI  R30,LOW(1)
000cb6 940c 0feb 	JMP  _0x20C0003
                 ; 0002 02B6 }
                 ; .FEND
                 ;#endif
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Seek File R/W Pointer                                                 */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_LSEEK
                 ;
                 ;FRESULT pf_lseek (
                 ; 0002 02C1 	DWORD ofs		/* File pointer from top of file */
                 ; 0002 02C2 )
                 ; 0002 02C3 {
                 ; 0002 02C4 	CLUST clst;
                 ; 0002 02C5 	DWORD bcs, sect, ifptr;
                 ; 0002 02C6 	FATFS *fs = FatFs;
                 ; 0002 02C7 
                 ; 0002 02C8 
                 ; 0002 02C9 	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
                 ;	ofs -> Y+18
                 ;	clst -> Y+14
                 ;	bcs -> Y+10
                 ;	sect -> Y+6
                 ;	ifptr -> Y+2
                 ;	*fs -> R16,R17
                 ; 0002 02CA 	if (!(fs->flag & FA_OPENED))		/* Check if opened */
                 ; 0002 02CB 			return FR_NOT_OPENED;
                 ; 0002 02CC 
                 ; 0002 02CD 	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
                 ; 0002 02CE 	ifptr = fs->fptr;
                 ; 0002 02CF 	fs->fptr = 0;
                 ; 0002 02D0 	if (ofs > 0) {
                 ; 0002 02D1 		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
                 ; 0002 02D2 		if (ifptr > 0 &&
                 ; 0002 02D3 			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
                 ; 0002 02D4 			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
                 ; 0002 02D5 			ofs -= fs->fptr;
                 ; 0002 02D6 			clst = fs->curr_clust;
                 ; 0002 02D7 		} else {							/* When seek to back cluster, */
                 ; 0002 02D8 			clst = fs->org_clust;			/* start from the first cluster */
                 ; 0002 02D9 			fs->curr_clust = clst;
                 ; 0002 02DA 		}
                 ; 0002 02DB 		while (ofs > bcs) {				/* Cluster following loop */
                 ; 0002 02DC 			clst = get_fat(clst);		/* Follow cluster chain */
                 ; 0002 02DD 			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
                 ; 0002 02DE 			fs->curr_clust = clst;
                 ; 0002 02DF 			fs->fptr += bcs;
                 ; 0002 02E0 			ofs -= bcs;
                 ; 0002 02E1 		}
                 ; 0002 02E2 		fs->fptr += ofs;
                 ; 0002 02E3 		sect = clust2sect(clst);		/* Current sector */
                 ; 0002 02E4 		if (!sect) goto fe_abort;
                 ; 0002 02E5 		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
                 ; 0002 02E6 		if (ofs % 512)
                 ; 0002 02E7 			fs->dsect = sect + fs->csect++;
                 ; 0002 02E8 	}
                 ; 0002 02E9 
                 ; 0002 02EA 	return FR_OK;
                 ; 0002 02EB 
                 ; 0002 02EC fe_abort:
                 ; 0002 02ED 	fs->flag = 0;
                 ; 0002 02EE 	return FR_DISK_ERR;
                 ; 0002 02EF }
                 ;#endif
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Create a Directroy Object                                             */
                 ;/*-----------------------------------------------------------------------*/
                 ;#if _USE_DIR
                 ;
                 ;FRESULT pf_opendir (
                 ; 0002 02FA 	DIR *dj,			/* Pointer to directory object to create */
                 ; 0002 02FB 	const char *path	/* Pointer to the directory path */
                 ; 0002 02FC )
                 ; 0002 02FD {
                 ; 0002 02FE 	FRESULT res;
                 ; 0002 02FF 	BYTE sp[12], dir[32];
                 ; 0002 0300 	FATFS *fs = FatFs;
                 ; 0002 0301 
                 ; 0002 0302 
                 ; 0002 0303 	if (!fs) {				/* Check file system */
                 ;	*dj -> Y+50
                 ;	*path -> Y+48
                 ;	res -> R17
                 ;	sp -> Y+36
                 ;	dir -> Y+4
                 ;	*fs -> R18,R19
                 ; 0002 0304 		res = FR_NOT_ENABLED;
                 ; 0002 0305 	} else {
                 ; 0002 0306 		fs->buf = dir;
                 ; 0002 0307 		dj->fn = sp;
                 ; 0002 0308 		res = follow_path(dj, path);			/* Follow the path to the directory */
                 ; 0002 0309 		if (res == FR_OK) {						/* Follow completed */
                 ; 0002 030A 			if (dir[0]) {						/* It is not the root dir */
                 ; 0002 030B 				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
                 ; 0002 030C 					dj->sclust =
                 ; 0002 030D #if _FS_FAT32
                 ; 0002 030E 					((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
                 ; 0002 030F #endif
                 ; 0002 0310 					LD_WORD(dir+DIR_FstClusLO);
                 ; 0002 0311 				} else {						/* The object is not a directory */
                 ; 0002 0312 					res = FR_NO_PATH;
                 ; 0002 0313 				}
                 ; 0002 0314 			}
                 ; 0002 0315 			if (res == FR_OK)
                 ; 0002 0316 				res = dir_rewind(dj);			/* Rewind dir */
                 ; 0002 0317 		}
                 ; 0002 0318 		if (res == FR_NO_FILE) res = FR_NO_PATH;
                 ; 0002 0319 	}
                 ; 0002 031A 
                 ; 0002 031B 	return res;
                 ; 0002 031C }
                 ;
                 ;
                 ;
                 ;
                 ;/*-----------------------------------------------------------------------*/
                 ;/* Read Directory Entry in Sequense                                      */
                 ;/*-----------------------------------------------------------------------*/
                 ;
                 ;FRESULT pf_readdir (
                 ; 0002 0326 	DIR *dj,			/* Pointer to the open directory object */
                 ; 0002 0327 	FILINFO *fno		/* Pointer to file information to return */
                 ; 0002 0328 )
                 ; 0002 0329 {
                 ; 0002 032A 	FRESULT res;
                 ; 0002 032B 	BYTE sp[12], dir[32];
                 ; 0002 032C 	FATFS *fs = FatFs;
                 ; 0002 032D 
                 ; 0002 032E 
                 ; 0002 032F 	if (!fs) {				/* Check file system */
                 ;	*dj -> Y+50
                 ;	*fno -> Y+48
                 ;	res -> R17
                 ;	sp -> Y+36
                 ;	dir -> Y+4
                 ;	*fs -> R18,R19
                 ; 0002 0330 		res = FR_NOT_ENABLED;
                 ; 0002 0331 	} else {
                 ; 0002 0332 		fs->buf = dir;
                 ; 0002 0333 		dj->fn = sp;
                 ; 0002 0334 		if (!fno) {
                 ; 0002 0335 			res = dir_rewind(dj);
                 ; 0002 0336 		} else {
                 ; 0002 0337 			res = dir_read(dj);
                 ; 0002 0338 			if (res == FR_NO_FILE) {
                 ; 0002 0339 				dj->sect = 0;
                 ; 0002 033A 				res = FR_OK;
                 ; 0002 033B 			}
                 ; 0002 033C 			if (res == FR_OK) {				/* A valid entry is found */
                 ; 0002 033D 				get_fileinfo(dj, fno);		/* Get the object information */
                 ; 0002 033E 				res = dir_next(dj);			/* Increment index for next */
                 ; 0002 033F 				if (res == FR_NO_FILE) {
                 ; 0002 0340 					dj->sect = 0;
                 ; 0002 0341 					res = FR_OK;
                 ; 0002 0342 				}
                 ; 0002 0343 			}
                 ; 0002 0344 		}
                 ; 0002 0345 	}
                 ; 0002 0346 
                 ; 0002 0347 	return res;
                 ; 0002 0348 }
                 ;
                 ;#endif /* _USE_DIR */
                 ;
                 ;//-----------------------------------------------------------------------
                 ;// PFF - Low level disk control module for ATmega32
                 ;//-----------------------------------------------------------------------
                 ;#define _WRITE_FUNC	1			//allow write operations
                 ;
                 ;//#include "common.h"
                 ;#include "diskio.h"
                 ;#include "mmc.h"
                 ;#include <mega128.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;// Definitions for MMC/SDC connection
                 ;
                 ;//#define SD_INS  6
                 ;//#define SD_WP   7
                 ;
                 ;// Definitions for MMC/SDC command
                 ;#define CMD0	(0x40+0)	// GO_IDLE_STATE
                 ;#define CMD1	(0x40+1)	// SEND_OP_COND (MMC)
                 ;#define	ACMD41	(0xC0+41)	// SEND_OP_COND (SDC)
                 ;#define CMD8	(0x40+8)	// SEND_IF_COND
                 ;#define CMD16	(0x40+16)	// SET_BLOCKLEN
                 ;#define CMD17	(0x40+17)	// READ_SINGLE_BLOCK
                 ;#define CMD24	(0x40+24)	// WRITE_BLOCK
                 ;#define CMD55	(0x40+55)	// APP_CMD
                 ;#define CMD58	(0x40+58)	// READ_OCR
                 ;
                 ;//-----------------------------------------------------------------------
                 ;// SPI functions
                 ;//-----------------------------------------------------------------------
                 ;#define hardware_spi //  ,  spi 
                 ;
                 ;#define SPI_PORTX PORTB
                 ;#define SPI_DDRX DDRB
                 ;
                 ;#define SPI_MISO SD_DO
                 ;#define SPI_MOSI SD_DI
                 ;#define SPI_SCK SD_CLK
                 ;#define SPI_SS SD_CS
                 ;
                 ;void INIT_SPI(void) {
                 ; 0003 0027 void INIT_SPI(void) {
                 
                 	.CSEG
                 _INIT_SPI:
                 ; .FSTART _INIT_SPI
                 ; 0003 0028 #ifdef hardware_spi
                 ; 0003 0029 	/*  -
                 ; 0003 002A 	  ,  MISO */
                 ; 0003 002B 	SPI_DDRX |= (1 << SPI_MOSI) | (1 << SPI_SCK) | (1 << SPI_SS) | (0 << SPI_MISO);
000cb8 b3e7      	IN   R30,0x17
000cb9 60e7      	ORI  R30,LOW(0x7)
000cba bbe7      	OUT  0x17,R30
                 ; 0003 002C 	SPI_PORTX |= (1 << SPI_MOSI) | (1 << SPI_SCK) | (1 << SPI_SS) | (1 << SPI_MISO);
000cbb b3e8      	IN   R30,0x18
000cbc 60ef      	ORI  R30,LOW(0xF)
000cbd bbe8      	OUT  0x18,R30
                 ; 0003 002D 
                 ; 0003 002E 	/* spi,  ,,  0*/
                 ; 0003 002F 	SPCR = (1 << SPE) | (0 << DORD) | (1 << MSTR) | (0 << CPOL) | (0 << CPHA) | (0 << SPR1) | (0 << SPR0);
000cbe e5e0      	LDI  R30,LOW(80)
000cbf b9ed      	OUT  0xD,R30
                 ; 0003 0030 	SPSR = (1 << SPI2X);
000cc0 e0e1      	LDI  R30,LOW(1)
000cc1 b9ee      	OUT  0xE,R30
                 ; 0003 0031 #else
                 ; 0003 0032 	PORTB |= (1<<SD_CS) | (1<<SD_DO) | (1<<SD_DI)/* | (1<<SD_WP) | (1<<SD_INS)*/;
                 ; 0003 0033 	DDRB |=(1<<SD_CS) | (1<<SD_DI) | (1<<SD_CLK);
                 ; 0003 0034 #endif
                 ; 0003 0035 }
000cc2 9508      	RET
                 ; .FEND
                 ;
                 ;void xmit_spi(BYTE data) {		// Send a byte
                 ; 0003 0037 void xmit_spi(BYTE data) {
                 _xmit_spi:
                 ; .FSTART _xmit_spi
                 ; 0003 0038 #ifdef hardware_spi
                 ; 0003 0039 	SPDR = data;
000cc3 93aa      	ST   -Y,R26
                 ;	data -> Y+0
000cc4 81e8      	LD   R30,Y
000cc5 b9ef      	OUT  0xF,R30
                 ; 0003 003A 	while (!(SPSR & (1 << SPIF)));
                 _0x60003:
000cc6 9b77      	SBIS 0xE,7
000cc7 cffe      	RJMP _0x60003
                 ; 0003 003B #else
                 ; 0003 003C 	BYTE i;
                 ; 0003 003D 
                 ; 0003 003E 	for (i = 0; i < 8; i++) {
                 ; 0003 003F 		if ((data & 0x80) == 0x00)
                 ; 0003 0040 			PORTB &= ~(1<<SD_DI);
                 ; 0003 0041 		else
                 ; 0003 0042 			PORTB |= (1<<SD_DI);
                 ; 0003 0043 		data = data << 1;
                 ; 0003 0044 		PORTB |= (1<<SD_CLK);
                 ; 0003 0045 		#asm("nop")
                 ; 0003 0046 		PORTB &= ~(1<<SD_CLK);
                 ; 0003 0047 	}
                 ; 0003 0048 #endif
                 ; 0003 0049 }
000cc8 940c 10fe 	JMP  _0x20C0001
                 ; .FEND
                 ;
                 ;BYTE rcv_spi(void) {				// Send 0xFF and receive a byte
                 ; 0003 004B BYTE rcv_spi(void) {
                 _rcv_spi:
                 ; .FSTART _rcv_spi
                 ; 0003 004C #ifdef hardware_spi
                 ; 0003 004D 	unsigned char data;
                 ; 0003 004E 	SPDR = 0xFF;
000cca 931a      	ST   -Y,R17
                 ;	data -> R17
000ccb efef      	LDI  R30,LOW(255)
000ccc b9ef      	OUT  0xF,R30
                 ; 0003 004F 	while (!(SPSR & (1 << SPIF)));
                 _0x60006:
000ccd 9b77      	SBIS 0xE,7
000cce cffe      	RJMP _0x60006
                 ; 0003 0050 	data = SPDR;
000ccf b11f      	IN   R17,15
                 ; 0003 0051 	return data;
000cd0 2fe1      	MOV  R30,R17
000cd1 9119      	LD   R17,Y+
000cd2 9508      	RET
                 ; 0003 0052 #else
                 ; 0003 0053 	BYTE i, res = 0;
                 ; 0003 0054 
                 ; 0003 0055 	PORTB |= (1<<SD_DI);
                 ; 0003 0056 
                 ; 0003 0057 	for (i = 0; i < 8; i++) {
                 ; 0003 0058 		PORTB |= (1<<SD_CLK);
                 ; 0003 0059 		res = res << 1;
                 ; 0003 005A 		if ((PINB & (1<<SD_DO))!=0x00)
                 ; 0003 005B 		res = res | 0x01;
                 ; 0003 005C 		PORTB &= ~(1<<SD_CLK);
                 ; 0003 005D 		#asm("nop")
                 ; 0003 005E 	}
                 ; 0003 005F 	return res;
                 ; 0003 0060 #endif
                 ; 0003 0061 } /* Send 0xFF and receive a byte */
                 ; .FEND
                 ;//-----------------------------------------------------------------------
                 ;
                 ;
                 ;
                 ;//-----------------------------------------------------------------------
                 ;//   Module Private Function
                 ;//-----------------------------------------------------------------------
                 ;static BYTE CardType;
                 ;
                 ;//-----------------------------------------------------------------------
                 ;// Deselect the card and release SPI bus
                 ;//-----------------------------------------------------------------------
                 ;static
                 ;void release_spi (void)
                 ; 0003 0070 {
                 _release_spi_G003:
                 ; .FSTART _release_spi_G003
                 ; 0003 0071 	rcv_spi();
000cd3 dff6      	RCALL _rcv_spi
                 ; 0003 0072 }
000cd4 9508      	RET
                 ; .FEND
                 ;
                 ;//-----------------------------------------------------------------------
                 ;// Send a command packet to MMC
                 ;//-----------------------------------------------------------------------
                 ;static
                 ;BYTE send_cmd (
                 ; 0003 0079 	BYTE cmd,		// Command byte
                 ; 0003 007A 	DWORD arg		// Argument
                 ; 0003 007B )
                 ; 0003 007C {
                 _send_cmd_G003:
                 ; .FSTART _send_cmd_G003
                 ; 0003 007D 	BYTE n, res;
                 ; 0003 007E 
                 ; 0003 007F 
                 ; 0003 0080 	if (cmd & 0x80) {	// ACMD<n> is the command sequense of CMD55-CMD<n>
000cd5 940e 1409 	CALL __PUTPARD2
000cd7 931a      	ST   -Y,R17
000cd8 930a      	ST   -Y,R16
                 ;	cmd -> Y+6
                 ;	arg -> Y+2
                 ;	n -> R17
                 ;	res -> R16
000cd9 81ee      	LDD  R30,Y+6
000cda 78e0      	ANDI R30,LOW(0x80)
000cdb f049      	BREQ _0x60009
                 ; 0003 0081 		cmd &= 0x7F;
000cdc 81ee      	LDD  R30,Y+6
000cdd 77ef      	ANDI R30,0x7F
000cde 83ee      	STD  Y+6,R30
                 ; 0003 0082 		res = send_cmd(CMD55, 0);
000cdf e7e7      	LDI  R30,LOW(119)
000ce0 940e 12d2 	CALL SUBOPT_0x48
000ce2 2f0e      	MOV  R16,R30
                 ; 0003 0083 		if (res > 1) return res;
000ce3 3002      	CPI  R16,2
000ce4 f580      	BRSH _0x20C0005
                 ; 0003 0084 	}
                 ; 0003 0085 
                 ; 0003 0086 	// Select the card
                 ; 0003 0087 	DESELECT();
                 _0x60009:
000ce5 9ac0      	SBI  0x18,0
                 ; 0003 0088 	rcv_spi();
000ce6 dfe3      	RCALL _rcv_spi
                 ; 0003 0089 	SELECT();
000ce7 98c0      	CBI  0x18,0
                 ; 0003 008A 	rcv_spi();
000ce8 dfe1      	RCALL _rcv_spi
                 ; 0003 008B 
                 ; 0003 008C 	// Send a command packet
                 ; 0003 008D 	xmit_spi(cmd);						// Start + Command index
000ce9 81ae      	LDD  R26,Y+6
000cea dfd8      	RCALL _xmit_spi
                 ; 0003 008E 	xmit_spi((BYTE)(arg >> 24));		// Argument[31..24]
000ceb 940e 1207 	CALL SUBOPT_0x28
000ced e1e8      	LDI  R30,LOW(24)
000cee 940e 1341 	CALL __LSRD12
000cf0 2fae      	MOV  R26,R30
000cf1 dfd1      	RCALL _xmit_spi
                 ; 0003 008F 	xmit_spi((BYTE)(arg >> 16));		// Argument[23..16]
000cf2 940e 11fd 	CALL SUBOPT_0x26
000cf4 940e 1364 	CALL __LSRD16
000cf6 2fae      	MOV  R26,R30
000cf7 dfcb      	RCALL _xmit_spi
                 ; 0003 0090 	xmit_spi((BYTE)(arg >> 8));			// Argument[15..8]
000cf8 940e 1207 	CALL SUBOPT_0x28
000cfa e0e8      	LDI  R30,LOW(8)
000cfb 940e 1341 	CALL __LSRD12
000cfd 2fae      	MOV  R26,R30
000cfe dfc4      	RCALL _xmit_spi
                 ; 0003 0091 	xmit_spi((BYTE)arg);				// Argument[7..0]
000cff 81aa      	LDD  R26,Y+2
000d00 dfc2      	RCALL _xmit_spi
                 ; 0003 0092 	n = 0x01;							// Dummy CRC + Stop
000d01 e011      	LDI  R17,LOW(1)
                 ; 0003 0093 	if (cmd == CMD0) n = 0x95;			// Valid CRC for CMD0(0)
000d02 81ae      	LDD  R26,Y+6
000d03 34a0      	CPI  R26,LOW(0x40)
000d04 f409      	BRNE _0x6000B
000d05 e915      	LDI  R17,LOW(149)
                 ; 0003 0094 	if (cmd == CMD8) n = 0x87;			// Valid CRC for CMD8(0x1AA)
                 _0x6000B:
000d06 81ae      	LDD  R26,Y+6
000d07 34a8      	CPI  R26,LOW(0x48)
000d08 f409      	BRNE _0x6000C
000d09 e817      	LDI  R17,LOW(135)
                 ; 0003 0095 	xmit_spi(n);
                 _0x6000C:
000d0a 2fa1      	MOV  R26,R17
000d0b dfb7      	RCALL _xmit_spi
                 ; 0003 0096 
                 ; 0003 0097 	// Receive a command response
                 ; 0003 0098 	n = 10;								// Wait for a valid response in timeout of 10 attempts
000d0c e01a      	LDI  R17,LOW(10)
                 ; 0003 0099 	do {
                 _0x6000E:
                 ; 0003 009A 		res = rcv_spi();
000d0d dfbc      	RCALL _rcv_spi
000d0e 2f0e      	MOV  R16,R30
                 ; 0003 009B 	} while ((res & 0x80) && --n);
000d0f ff07      	SBRS R16,7
000d10 c002      	RJMP _0x60010
000d11 5011      	SUBI R17,LOW(1)
000d12 f409      	BRNE _0x60011
                 _0x60010:
000d13 c001      	RJMP _0x6000F
                 _0x60011:
000d14 cff8      	RJMP _0x6000E
                 _0x6000F:
                 ; 0003 009C 
                 ; 0003 009D 	return res;			// Return with the response value
                 _0x20C0005:
000d15 2fe0      	MOV  R30,R16
000d16 8119      	LDD  R17,Y+1
000d17 8108      	LDD  R16,Y+0
000d18 9627      	ADIW R28,7
000d19 9508      	RET
                 ; 0003 009E }
                 ; .FEND
                 ;
                 ;//--------------------------------------------------------------------------
                 ;//
                 ;//   Public Functions
                 ;//
                 ;//--------------------------------------------------------------------------
                 ;
                 ;//--------------------------------------------------------------------------
                 ;// Initialize Disk Drive
                 ;//--------------------------------------------------------------------------
                 ;DSTATUS disk_initialize (void)
                 ; 0003 00AA {
                 _disk_initialize:
                 ; .FSTART _disk_initialize
                 ; 0003 00AB 	BYTE n, cmd, ty, ocr[4];
                 ; 0003 00AC 	WORD tmr;
                 ; 0003 00AD 
                 ; 0003 00AE 
                 ; 0003 00AF 	INIT_SPI();
000d1a 9724      	SBIW R28,4
000d1b 940e 1460 	CALL __SAVELOCR6
                 ;	n -> R17
                 ;	cmd -> R16
                 ;	ty -> R19
                 ;	ocr -> Y+6
                 ;	tmr -> R20,R21
000d1d df9a      	RCALL _INIT_SPI
                 ; 0003 00B0 
                 ; 0003 00B1 //	if ((PINB&_BV(SD_INS))!=0x00) return STA_NOINIT;
                 ; 0003 00B2 
                 ; 0003 00B3 #if _WRITE_FUNC
                 ; 0003 00B4 	if (MMC_SEL) disk_writep(0, 0);		// Finalize write process if it is in progress
000d1e 99c0      	SBIC 0x18,0
000d1f c007      	RJMP _0x60012
000d20 940e 12bf 	CALL SUBOPT_0x45
                +
000d22 e0a0     +LDI R26 , LOW ( 0x0 )
000d23 e0b0     +LDI R27 , HIGH ( 0x0 )
000d24 e080     +LDI R24 , BYTE3 ( 0x0 )
000d25 e090     +LDI R25 , BYTE4 ( 0x0 )
                 	__GETD2N 0x0
000d26 d0f6      	RCALL _disk_writep
                 ; 0003 00B5 #endif
                 ; 0003 00B6 	for (n = 100; n; n--) rcv_spi();	// Dummy clocks
                 _0x60012:
000d27 e614      	LDI  R17,LOW(100)
                 _0x60014:
000d28 3010      	CPI  R17,0
000d29 f019      	BREQ _0x60015
000d2a df9f      	RCALL _rcv_spi
000d2b 5011      	SUBI R17,1
000d2c cffb      	RJMP _0x60014
                 _0x60015:
                 ; 0003 00B8 ty = 0;
000d2d e030      	LDI  R19,LOW(0)
                 ; 0003 00B9 	if (send_cmd(CMD0, 0) == 1) {			// Enter Idle state
000d2e e4e0      	LDI  R30,LOW(64)
000d2f 940e 12d2 	CALL SUBOPT_0x48
000d31 30e1      	CPI  R30,LOW(0x1)
000d32 f009      	BREQ PC+2
000d33 c074      	RJMP _0x60016
                 ; 0003 00BA 		if (send_cmd(CMD8, 0x1AA) == 1) {	// SDv2
000d34 e4e8      	LDI  R30,LOW(72)
000d35 93ea      	ST   -Y,R30
                +
000d36 eaaa     +LDI R26 , LOW ( 0x1AA )
000d37 e0b1     +LDI R27 , HIGH ( 0x1AA )
000d38 e080     +LDI R24 , BYTE3 ( 0x1AA )
000d39 e090     +LDI R25 , BYTE4 ( 0x1AA )
                 	__GETD2N 0x1AA
000d3a df9a      	RCALL _send_cmd_G003
000d3b 30e1      	CPI  R30,LOW(0x1)
000d3c f009      	BREQ PC+2
000d3d c044      	RJMP _0x60017
                 ; 0003 00BB 			for (n = 0; n < 4; n++) ocr[n] = rcv_spi();		// Get trailing return value of R7 resp
000d3e e010      	LDI  R17,LOW(0)
                 _0x60019:
000d3f 3014      	CPI  R17,4
000d40 f450      	BRSH _0x6001A
000d41 940e 12d9 	CALL SUBOPT_0x49
000d43 93ff      	PUSH R31
000d44 93ef      	PUSH R30
000d45 df84      	RCALL _rcv_spi
000d46 91af      	POP  R26
000d47 91bf      	POP  R27
000d48 93ec      	ST   X,R30
000d49 5f1f      	SUBI R17,-1
000d4a cff4      	RJMP _0x60019
                 _0x6001A:
                 ; 0003 00BC if (ocr[2] == 0x01 && ocr[3] == 0xAA) {
000d4b 85a8      	LDD  R26,Y+8
000d4c 30a1      	CPI  R26,LOW(0x1)
000d4d f419      	BRNE _0x6001C
000d4e 85a9      	LDD  R26,Y+9
000d4f 3aaa      	CPI  R26,LOW(0xAA)
000d50 f009      	BREQ _0x6001D
                 _0x6001C:
000d51 c02f      	RJMP _0x6001B
                 _0x6001D:
                 ; 0003 00BD 				for (tmr = 12000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) ;	// Wait for leaving idle state (ACMD41 with HCS bit)
                +
000d52 ee40     +LDI R20 , LOW ( 12000 )
000d53 e25e     +LDI R21 , HIGH ( 12000 )
                 	__GETWRN 20,21,12000
                 _0x6001F:
000d54 2e04      	MOV  R0,R20
000d55 2a05      	OR   R0,R21
000d56 f049      	BREQ _0x60021
000d57 eee9      	LDI  R30,LOW(233)
000d58 93ea      	ST   -Y,R30
                +
000d59 e0a0     +LDI R26 , LOW ( 0x40000000 )
000d5a e0b0     +LDI R27 , HIGH ( 0x40000000 )
000d5b e080     +LDI R24 , BYTE3 ( 0x40000000 )
000d5c e490     +LDI R25 , BYTE4 ( 0x40000000 )
                 	__GETD2N 0x40000000
000d5d df77      	RCALL _send_cmd_G003
000d5e 30e0      	CPI  R30,0
000d5f f409      	BRNE _0x60022
                 _0x60021:
000d60 c003      	RJMP _0x60020
                 _0x60022:
                +
000d61 5041     +SUBI R20 , LOW ( 1 )
000d62 4050     +SBCI R21 , HIGH ( 1 )
                 	__SUBWRN 20,21,1
000d63 cff0      	RJMP _0x6001F
                 _0x60020:
                 ; 0003 00BE 				if (tmr && send_cmd(CMD58, 0) == 0) {		// Check CCS bit in the OCR
000d64 2e04      	MOV  R0,R20
000d65 2a05      	OR   R0,R21
000d66 f029      	BREQ _0x60024
000d67 e7ea      	LDI  R30,LOW(122)
000d68 940e 12d2 	CALL SUBOPT_0x48
000d6a 30e0      	CPI  R30,0
000d6b f009      	BREQ _0x60025
                 _0x60024:
000d6c c014      	RJMP _0x60023
                 _0x60025:
                 ; 0003 00BF 					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
000d6d e010      	LDI  R17,LOW(0)
                 _0x60027:
000d6e 3014      	CPI  R17,4
000d6f f450      	BRSH _0x60028
000d70 940e 12d9 	CALL SUBOPT_0x49
000d72 93ff      	PUSH R31
000d73 93ef      	PUSH R30
000d74 df55      	RCALL _rcv_spi
000d75 91af      	POP  R26
000d76 91bf      	POP  R27
000d77 93ec      	ST   X,R30
000d78 5f1f      	SUBI R17,-1
000d79 cff4      	RJMP _0x60027
                 _0x60028:
                 ; 0003 00C0 ty = (ocr[0] & 0x40) ? 0x04	 | 0x08	 : 0x04	;
000d7a 81ee      	LDD  R30,Y+6
000d7b 74e0      	ANDI R30,LOW(0x40)
000d7c f011      	BREQ _0x60029
000d7d e0ec      	LDI  R30,LOW(12)
000d7e c001      	RJMP _0x6002A
                 _0x60029:
000d7f e0e4      	LDI  R30,LOW(4)
                 _0x6002A:
000d80 2f3e      	MOV  R19,R30
                 ; 0003 00C1 				}
                 ; 0003 00C2 			}
                 _0x60023:
                 ; 0003 00C3 		} else {							// SDv1 or MMCv3
                 _0x6001B:
000d81 c026      	RJMP _0x6002C
                 _0x60017:
                 ; 0003 00C4 			if (send_cmd(ACMD41, 0) <= 1) 	{
000d82 eee9      	LDI  R30,LOW(233)
000d83 940e 12d2 	CALL SUBOPT_0x48
000d85 30e2      	CPI  R30,LOW(0x2)
000d86 f418      	BRSH _0x6002D
                 ; 0003 00C5 				ty = CT_SD1; cmd = ACMD41;	// SDv1
000d87 e032      	LDI  R19,LOW(2)
000d88 ee09      	LDI  R16,LOW(233)
                 ; 0003 00C6 			} else {
000d89 c002      	RJMP _0x6002E
                 _0x6002D:
                 ; 0003 00C7 				ty = CT_MMC; cmd = CMD1;	// MMCv3
000d8a e031      	LDI  R19,LOW(1)
000d8b e401      	LDI  R16,LOW(65)
                 ; 0003 00C8 			}
                 _0x6002E:
                 ; 0003 00C9 			for (tmr = 25000; tmr && send_cmd(cmd, 0); tmr--) ;	// Wait for leaving idle state
                +
000d8c ea48     +LDI R20 , LOW ( 25000 )
000d8d e651     +LDI R21 , HIGH ( 25000 )
                 	__GETWRN 20,21,25000
                 _0x60030:
000d8e 2e04      	MOV  R0,R20
000d8f 2a05      	OR   R0,R21
000d90 f041      	BREQ _0x60032
000d91 930a      	ST   -Y,R16
                +
000d92 e0a0     +LDI R26 , LOW ( 0x0 )
000d93 e0b0     +LDI R27 , HIGH ( 0x0 )
000d94 e080     +LDI R24 , BYTE3 ( 0x0 )
000d95 e090     +LDI R25 , BYTE4 ( 0x0 )
                 	__GETD2N 0x0
000d96 df3e      	RCALL _send_cmd_G003
000d97 30e0      	CPI  R30,0
000d98 f409      	BRNE _0x60033
                 _0x60032:
000d99 c003      	RJMP _0x60031
                 _0x60033:
                +
000d9a 5041     +SUBI R20 , LOW ( 1 )
000d9b 4050     +SBCI R21 , HIGH ( 1 )
                 	__SUBWRN 20,21,1
000d9c cff1      	RJMP _0x60030
                 _0x60031:
                 ; 0003 00CA 			if (!tmr || send_cmd(CMD16, 512) != 0)			// Set R/W block length to 512
000d9d 2e04      	MOV  R0,R20
000d9e 2a05      	OR   R0,R21
000d9f f039      	BREQ _0x60035
000da0 e5e0      	LDI  R30,LOW(80)
000da1 93ea      	ST   -Y,R30
000da2 940e 12e0 	CALL SUBOPT_0x4A
000da4 df30      	RCALL _send_cmd_G003
000da5 30e0      	CPI  R30,0
000da6 f009      	BREQ _0x60034
                 _0x60035:
                 ; 0003 00CB 				ty = 0;
000da7 e030      	LDI  R19,LOW(0)
                 ; 0003 00CC 		}
                 _0x60034:
                 _0x6002C:
                 ; 0003 00CD 	}
                 ; 0003 00CE 	CardType = ty;
                 _0x60016:
000da8 9330 0923 	STS  _CardType_G003,R19
                 ; 0003 00CF 	release_spi();
000daa df28      	RCALL _release_spi_G003
                 ; 0003 00D0 
                 ; 0003 00D1 #ifdef hardware_spi
                 ; 0003 00D2 	//  SPI!!!--------------------------------------------
                 ; 0003 00D3 	SPCR &= ~((1 << SPR1) | (1 << SPR0)); //  
000dab b1ed      	IN   R30,0xD
000dac 7fec      	ANDI R30,LOW(0xFC)
000dad b9ed      	OUT  0xD,R30
                 ; 0003 00D4 	SPSR |= (1 << SPI2X); //  
000dae 9a70      	SBI  0xE,0
                 ; 0003 00D5 	//------------------------------------------------------------------
                 ; 0003 00D6 #endif
                 ; 0003 00D7 
                 ; 0003 00D8 	return ty ? 0 : STA_NOINIT;
000daf 3030      	CPI  R19,0
000db0 f011      	BREQ _0x60037
000db1 e0e0      	LDI  R30,LOW(0)
000db2 c001      	RJMP _0x60038
                 _0x60037:
000db3 e0e1      	LDI  R30,LOW(1)
                 _0x60038:
000db4 940e 1467 	CALL __LOADLOCR6
000db6 c0da      	RJMP _0x20C0004
                 ; 0003 00D9 }
                 ; .FEND
                 ;//-----------------------------------------------------------------------
                 ;// Read partial sector
                 ;//-----------------------------------------------------------------------
                 ;
                 ;DRESULT disk_readp (
                 ; 0003 00DF 	BYTE *buff,		// Pointer to the read buffer (NULL:Read bytes are forwarded to the stream)
                 ; 0003 00E0 	DWORD lba,		// Sector number (LBA)
                 ; 0003 00E1 	WORD ofs,		// Byte offset to read from (0..511)
                 ; 0003 00E2 	WORD cnt		// Number of bytes to read (ofs + cnt mus be <= 512)
                 ; 0003 00E3 )
                 ; 0003 00E4 {
                 _disk_readp:
                 ; .FSTART _disk_readp
                 ; 0003 00E5 	DRESULT res;
                 ; 0003 00E6 	BYTE rc;
                 ; 0003 00E7 	WORD bc;
                 ; 0003 00E8 
                 ; 0003 00E9 //	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
                 ; 0003 00EA 
                 ; 0003 00EB 	if (!(CardType & CT_BLOCK)) lba *= 512;		// Convert to byte address if needed
000db7 940e 1222 	CALL SUBOPT_0x2D
                 ;	*buff -> Y+12
                 ;	lba -> Y+8
                 ;	ofs -> Y+6
                 ;	cnt -> Y+4
                 ;	res -> R17
                 ;	rc -> R16
                 ;	bc -> R18,R19
000db9 91e0 0923 	LDS  R30,_CardType_G003
000dbb 70e8      	ANDI R30,LOW(0x8)
000dbc f451      	BRNE _0x6003A
000dbd 940e 1186 	CALL SUBOPT_0x13
000dbf 940e 12e0 	CALL SUBOPT_0x4A
000dc1 940e 1373 	CALL __MULD12U
                +
000dc3 87e8     +STD Y + 8 , R30
000dc4 87f9     +STD Y + 8 + 1 , R31
000dc5 876a     +STD Y + 8 + 2 , R22
000dc6 877b     +STD Y + 8 + 3 , R23
                 	__PUTD1S 8
                 ; 0003 00EC 
                 ; 0003 00ED 	res = RES_ERROR;
                 _0x6003A:
000dc7 e011      	LDI  R17,LOW(1)
                 ; 0003 00EE 	if (send_cmd(CMD17, lba) == 0) {		// READ_SINGLE_BLOCK
000dc8 e5e1      	LDI  R30,LOW(81)
000dc9 93ea      	ST   -Y,R30
000dca 940e 127c 	CALL SUBOPT_0x3B
000dcc df08      	RCALL _send_cmd_G003
000dcd 30e0      	CPI  R30,0
000dce f009      	BREQ PC+2
000dcf c047      	RJMP _0x6003B
                 ; 0003 00EF 
                 ; 0003 00F0 		bc = 30000;
                +
000dd0 e320     +LDI R18 , LOW ( 30000 )
000dd1 e735     +LDI R19 , HIGH ( 30000 )
                 	__GETWRN 18,19,30000
                 ; 0003 00F1 		do {							// Wait for data packet in timeout of 100ms
                 _0x6003D:
                 ; 0003 00F2 			rc = rcv_spi();
000dd2 def7      	RCALL _rcv_spi
000dd3 2f0e      	MOV  R16,R30
                 ; 0003 00F3 		} while (rc == 0xFF && --bc);
000dd4 3f0f      	CPI  R16,255
000dd5 f419      	BRNE _0x6003F
                +
000dd6 5021     +SUBI R18 , LOW ( 1 )
000dd7 4030     +SBCI R19 , HIGH ( 1 )
                 	__SUBWRN 18,19,1
000dd8 f409      	BRNE _0x60040
                 _0x6003F:
000dd9 c001      	RJMP _0x6003E
                 _0x60040:
000dda cff7      	RJMP _0x6003D
                 _0x6003E:
                 ; 0003 00F4 
                 ; 0003 00F5 		if (rc == 0xFE) {				// A data packet arrived
000ddb 3f0e      	CPI  R16,254
000ddc f5d1      	BRNE _0x60041
                 ; 0003 00F6 			bc = 514 - ofs - cnt;
000ddd 81ae      	LDD  R26,Y+6
000dde 81bf      	LDD  R27,Y+6+1
000ddf e0e2      	LDI  R30,LOW(514)
000de0 e0f2      	LDI  R31,HIGH(514)
000de1 1bea      	SUB  R30,R26
000de2 0bfb      	SBC  R31,R27
000de3 01df      	MOVW R26,R30
000de4 81ec      	LDD  R30,Y+4
000de5 81fd      	LDD  R31,Y+4+1
000de6 1bae      	SUB  R26,R30
000de7 0bbf      	SBC  R27,R31
000de8 019d      	MOVW R18,R26
                 ; 0003 00F7 
                 ; 0003 00F8 			// Skip leading bytes
                 ; 0003 00F9 			if (ofs) {
000de9 81ee      	LDD  R30,Y+6
000dea 81ff      	LDD  R31,Y+6+1
000deb 9730      	SBIW R30,0
000dec f039      	BREQ _0x60042
                 ; 0003 00FA 				do rcv_spi(); while (--ofs);
                 _0x60044:
000ded dedc      	RCALL _rcv_spi
000dee 81ee      	LDD  R30,Y+6
000def 81ff      	LDD  R31,Y+6+1
000df0 9731      	SBIW R30,1
000df1 83ee      	STD  Y+6,R30
000df2 83ff      	STD  Y+6+1,R31
000df3 f7c9      	BRNE _0x60044
                 ; 0003 00FB 			}
                 ; 0003 00FC 
                 ; 0003 00FD 			// Receive a part of the sector
                 ; 0003 00FE 			if (buff) {	// Store data to the memory
                 _0x60042:
000df4 85ec      	LDD  R30,Y+12
000df5 85fd      	LDD  R31,Y+12+1
000df6 9730      	SBIW R30,0
000df7 f099      	BREQ _0x60046
                 ; 0003 00FF 				do
                 _0x60048:
                 ; 0003 0100 					*buff++ = rcv_spi();
000df8 85ec      	LDD  R30,Y+12
000df9 85fd      	LDD  R31,Y+12+1
000dfa 9631      	ADIW R30,1
000dfb 87ec      	STD  Y+12,R30
000dfc 87fd      	STD  Y+12+1,R31
000dfd 9731      	SBIW R30,1
000dfe 93ff      	PUSH R31
000dff 93ef      	PUSH R30
000e00 dec9      	RCALL _rcv_spi
000e01 91af      	POP  R26
000e02 91bf      	POP  R27
000e03 93ec      	ST   X,R30
                 ; 0003 0101 				while (--cnt);
000e04 81ec      	LDD  R30,Y+4
000e05 81fd      	LDD  R31,Y+4+1
000e06 9731      	SBIW R30,1
000e07 83ec      	STD  Y+4,R30
000e08 83fd      	STD  Y+4+1,R31
000e09 f771      	BRNE _0x60048
                 ; 0003 0102 			} else {	// Forward data to the outgoing stream (depends on the project)
000e0a c006      	RJMP _0x6004A
                 _0x60046:
                 ; 0003 0103 				do
                 _0x6004C:
                 ; 0003 0104                 ;//uart_transmit(rcv_spi());		// (Console output)
                 ; 0003 0105 				while (--cnt);
000e0b 81ec      	LDD  R30,Y+4
000e0c 81fd      	LDD  R31,Y+4+1
000e0d 9731      	SBIW R30,1
000e0e 83ec      	STD  Y+4,R30
000e0f 83fd      	STD  Y+4+1,R31
000e10 f7d1      	BRNE _0x6004C
                 ; 0003 0106 			}
                 _0x6004A:
                 ; 0003 0107 
                 ; 0003 0108 			// Skip trailing bytes and CRC
                 ; 0003 0109 			do rcv_spi(); while (--bc);
                 _0x6004F:
000e11 deb8      	RCALL _rcv_spi
000e12 01f9      	MOVW R30,R18
000e13 9731      	SBIW R30,1
000e14 019f      	MOVW R18,R30
000e15 f7d9      	BRNE _0x6004F
                 ; 0003 010A 
                 ; 0003 010B 			res = RES_OK;
000e16 e010      	LDI  R17,LOW(0)
                 ; 0003 010C 		}
                 ; 0003 010D 	}
                 _0x60041:
                 ; 0003 010E 
                 ; 0003 010F 	release_spi();
                 _0x6003B:
000e17 debb      	RCALL _release_spi_G003
                 ; 0003 0110 
                 ; 0003 0111 	return res;
000e18 2fe1      	MOV  R30,R17
000e19 940e 1469 	CALL __LOADLOCR4
000e1b 962e      	ADIW R28,14
000e1c 9508      	RET
                 ; 0003 0112 }
                 ; .FEND
                 ;
                 ;//-----------------------------------------------------------------------
                 ;// Write partial sector
                 ;//-----------------------------------------------------------------------
                 ;#if _WRITE_FUNC
                 ;
                 ;DRESULT disk_writep (
                 ; 0003 011A 	const BYTE *buff,	// Pointer to the bytes to be written (NULL:Initiate/Finalize sector write)
                 ; 0003 011B 	DWORD sa			// Number of bytes to send, Sector number (LBA) or zero
                 ; 0003 011C )
                 ; 0003 011D {
                 _disk_writep:
                 ; .FSTART _disk_writep
                 ; 0003 011E 	DRESULT res;
                 ; 0003 011F 	WORD bc;
                 ; 0003 0120 	static WORD wc;
                 ; 0003 0121 
                 ; 0003 0122 //	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
                 ; 0003 0123 //	if ((PINB&_BV(SD_WP))!=0x00) return RES_ERROR;
                 ; 0003 0124 
                 ; 0003 0125 	res = RES_ERROR;
000e1d 940e 1409 	CALL __PUTPARD2
000e1f 940e 1462 	CALL __SAVELOCR4
                 ;	*buff -> Y+8
                 ;	sa -> Y+4
                 ;	res -> R17
                 ;	bc -> R18,R19
000e21 e011      	LDI  R17,LOW(1)
                 ; 0003 0126 
                 ; 0003 0127 	if (buff) {		// Send data bytes
000e22 85e8      	LDD  R30,Y+8
000e23 85f9      	LDD  R31,Y+8+1
000e24 9730      	SBIW R30,0
000e25 f0f9      	BREQ _0x60051
                 ; 0003 0128 		bc = (WORD)sa;
                +
000e26 812c     +LDD R18 , Y + 4
000e27 813d     +LDD R19 , Y + 4 + 1
                 	__GETWRS 18,19,4
                 ; 0003 0129 		while (bc && wc) {		// Send data bytes to the card
                 _0x60052:
000e28 2e02      	MOV  R0,R18
000e29 2a03      	OR   R0,R19
000e2a f031      	BREQ _0x60055
000e2b 91e0 0924 	LDS  R30,_wc_S0030007000
000e2d 91f0 0925 	LDS  R31,_wc_S0030007000+1
000e2f 9730      	SBIW R30,0
000e30 f409      	BRNE _0x60056
                 _0x60055:
000e31 c011      	RJMP _0x60054
                 _0x60056:
                 ; 0003 012A 			xmit_spi(*buff++);
000e32 85a8      	LDD  R26,Y+8
000e33 85b9      	LDD  R27,Y+8+1
000e34 91ed      	LD   R30,X+
000e35 87a8      	STD  Y+8,R26
000e36 87b9      	STD  Y+8+1,R27
000e37 2fae      	MOV  R26,R30
000e38 de8a      	RCALL _xmit_spi
                 ; 0003 012B 			wc--; bc--;
000e39 e2a4      	LDI  R26,LOW(_wc_S0030007000)
000e3a e0b9      	LDI  R27,HIGH(_wc_S0030007000)
000e3b 91ed      	LD   R30,X+
000e3c 91fd      	LD   R31,X+
000e3d 9731      	SBIW R30,1
000e3e 93fe      	ST   -X,R31
000e3f 93ee      	ST   -X,R30
                +
000e40 5021     +SUBI R18 , LOW ( 1 )
000e41 4030     +SBCI R19 , HIGH ( 1 )
                 	__SUBWRN 18,19,1
                 ; 0003 012C 		}
000e42 cfe5      	RJMP _0x60052
                 _0x60054:
                 ; 0003 012D 		res = RES_OK;
000e43 e010      	LDI  R17,LOW(0)
                 ; 0003 012E 	} else {
000e44 c049      	RJMP _0x60057
                 _0x60051:
                 ; 0003 012F 		if (sa) {	// Initiate sector write process
000e45 940e 114f 	CALL SUBOPT_0xC
000e47 940e 1448 	CALL __CPD10
000e49 f109      	BREQ _0x60058
                 ; 0003 0130 			if (!(CardType & CT_BLOCK)) sa *= 512;	// Convert to byte address if needed
000e4a 91e0 0923 	LDS  R30,_CardType_G003
000e4c 70e8      	ANDI R30,LOW(0x8)
000e4d f441      	BRNE _0x60059
000e4e 940e 114f 	CALL SUBOPT_0xC
000e50 940e 12e0 	CALL SUBOPT_0x4A
000e52 940e 1373 	CALL __MULD12U
000e54 940e 118b 	CALL SUBOPT_0x14
                 ; 0003 0131 			if (send_cmd(CMD24, sa) == 0) {			// WRITE_SINGLE_BLOCK
                 _0x60059:
000e56 e5e8      	LDI  R30,LOW(88)
000e57 93ea      	ST   -Y,R30
                +
000e58 81ad     +LDD R26 , Y + 5
000e59 81be     +LDD R27 , Y + 5 + 1
000e5a 818f     +LDD R24 , Y + 5 + 2
000e5b 8598     +LDD R25 , Y + 5 + 3
                 	__GETD2S 5
000e5c de78      	RCALL _send_cmd_G003
000e5d 30e0      	CPI  R30,0
000e5e f459      	BRNE _0x6005A
                 ; 0003 0132 				xmit_spi(0xFF); xmit_spi(0xFE);		// Data block header
000e5f efaf      	LDI  R26,LOW(255)
000e60 de62      	RCALL _xmit_spi
000e61 efae      	LDI  R26,LOW(254)
000e62 de60      	RCALL _xmit_spi
                 ; 0003 0133 				wc = 512;							// Set byte counter
000e63 e0e0      	LDI  R30,LOW(512)
000e64 e0f2      	LDI  R31,HIGH(512)
000e65 93e0 0924 	STS  _wc_S0030007000,R30
000e67 93f0 0925 	STS  _wc_S0030007000+1,R31
                 ; 0003 0134 				res = RES_OK;
000e69 e010      	LDI  R17,LOW(0)
                 ; 0003 0135 			}
                 ; 0003 0136 		} else {	// Finalize sector write process
                 _0x6005A:
000e6a c023      	RJMP _0x6005B
                 _0x60058:
                 ; 0003 0137 			bc = wc + 2;
000e6b 91e0 0924 	LDS  R30,_wc_S0030007000
000e6d 91f0 0925 	LDS  R31,_wc_S0030007000+1
000e6f 9632      	ADIW R30,2
000e70 019f      	MOVW R18,R30
                 ; 0003 0138 			while (bc--) xmit_spi(0);	// Fill left bytes and CRC with zeros
                 _0x6005C:
000e71 01f9      	MOVW R30,R18
                +
000e72 5021     +SUBI R18 , LOW ( 1 )
000e73 4030     +SBCI R19 , HIGH ( 1 )
                 	__SUBWRN 18,19,1
000e74 9730      	SBIW R30,0
000e75 f019      	BREQ _0x6005E
000e76 e0a0      	LDI  R26,LOW(0)
000e77 de4b      	RCALL _xmit_spi
000e78 cff8      	RJMP _0x6005C
                 _0x6005E:
                 ; 0003 0139 if ((rcv_spi() & 0x1F) == 0x05) {
000e79 de50      	RCALL _rcv_spi
000e7a 71ef      	ANDI R30,LOW(0x1F)
000e7b 30e5      	CPI  R30,LOW(0x5)
000e7c f481      	BRNE _0x6005F
                 ; 0003 013A 				for (bc = 65000; rcv_spi() != 0xFF && bc; bc--) ;	// Wait ready
                +
000e7d ee28     +LDI R18 , LOW ( - 536 )
000e7e ef3d     +LDI R19 , HIGH ( - 536 )
                 	__GETWRN 18,19,-536
                 _0x60061:
000e7f de4a      	RCALL _rcv_spi
000e80 3fef      	CPI  R30,LOW(0xFF)
000e81 f019      	BREQ _0x60063
000e82 2e02      	MOV  R0,R18
000e83 2a03      	OR   R0,R19
000e84 f409      	BRNE _0x60064
                 _0x60063:
000e85 c003      	RJMP _0x60062
                 _0x60064:
                +
000e86 5021     +SUBI R18 , LOW ( 1 )
000e87 4030     +SBCI R19 , HIGH ( 1 )
                 	__SUBWRN 18,19,1
000e88 cff6      	RJMP _0x60061
                 _0x60062:
                 ; 0003 013B 				if (bc) res = RES_OK;
000e89 2e02      	MOV  R0,R18
000e8a 2a03      	OR   R0,R19
000e8b f009      	BREQ _0x60065
000e8c e010      	LDI  R17,LOW(0)
                 ; 0003 013C 			}
                 _0x60065:
                 ; 0003 013D 			release_spi();
                 _0x6005F:
000e8d de45      	RCALL _release_spi_G003
                 ; 0003 013E 		}
                 _0x6005B:
                 ; 0003 013F 	}
                 _0x60057:
                 ; 0003 0140 
                 ; 0003 0141 	return res;
000e8e 2fe1      	MOV  R30,R17
000e8f 940e 1469 	CALL __LOADLOCR4
                 _0x20C0004:
000e91 962a      	ADIW R28,10
000e92 9508      	RET
                 ; 0003 0142 }
                 ; .FEND
                 ;#endif
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 
                 	.CSEG
                 _putchar:
                 ; .FSTART _putchar
000e93 93aa      	ST   -Y,R26
                 putchar0:
000e94 9b5d           sbis usr,udre
000e95 cffe           rjmp putchar0
000e96 81e8           ld   r30,y
000e97 b9ec           out  udr,r30
000e98 940c 10fe 	JMP  _0x20C0001
                 ; .FEND
                 _put_usart_G100:
                 ; .FSTART _put_usart_G100
000e9a 93ba      	ST   -Y,R27
000e9b 93aa      	ST   -Y,R26
000e9c 81aa      	LDD  R26,Y+2
000e9d dff5      	RCALL _putchar
000e9e 81a8      	LD   R26,Y
000e9f 81b9      	LDD  R27,Y+1
000ea0 91ed      	LD   R30,X+
000ea1 91fd      	LD   R31,X+
000ea2 9631      	ADIW R30,1
000ea3 93fe      	ST   -X,R31
000ea4 93ee      	ST   -X,R30
000ea5 940c 10bd 	JMP  _0x20C0002
                 ; .FEND
                 __print_G100:
                 ; .FSTART __print_G100
000ea7 93ba      	ST   -Y,R27
000ea8 93aa      	ST   -Y,R26
000ea9 9728      	SBIW R28,8
000eaa 940e 1460 	CALL __SAVELOCR6
000eac e010      	LDI  R17,0
000ead 85ae      	LDD  R26,Y+14
000eae 85bf      	LDD  R27,Y+14+1
000eaf 940e 1211 	CALL SUBOPT_0x2A
                 _0x2000016:
000eb1 01de      	MOVW R26,R28
000eb2 9654      	ADIW R26,20
000eb3 940e 12e5 	CALL SUBOPT_0x4B
                +
000eb5 bf6b     +OUT RAMPZ , R22
000eb6 91e6     +ELPM R30 , Z
                 	__GETBRPF 30
000eb7 2f2e      	MOV  R18,R30
000eb8 30e0      	CPI  R30,0
000eb9 f409      	BRNE PC+2
000eba c12c      	RJMP _0x2000018
000ebb 2fe1      	MOV  R30,R17
000ebc 30e0      	CPI  R30,0
000ebd f439      	BRNE _0x200001C
000ebe 3225      	CPI  R18,37
000ebf f411      	BRNE _0x200001D
000ec0 e011      	LDI  R17,LOW(1)
000ec1 c002      	RJMP _0x200001E
                 _0x200001D:
000ec2 940e 12ef 	CALL SUBOPT_0x4C
                 _0x200001E:
000ec4 c121      	RJMP _0x200001B
                 _0x200001C:
000ec5 30e1      	CPI  R30,LOW(0x1)
000ec6 f4a9      	BRNE _0x200001F
000ec7 3225      	CPI  R18,37
000ec8 f419      	BRNE _0x2000020
000ec9 940e 12ef 	CALL SUBOPT_0x4C
000ecb c119      	RJMP _0x20000CC
                 _0x2000020:
000ecc e012      	LDI  R17,LOW(2)
000ecd e040      	LDI  R20,LOW(0)
000ece e000      	LDI  R16,LOW(0)
000ecf 322d      	CPI  R18,45
000ed0 f411      	BRNE _0x2000021
000ed1 e001      	LDI  R16,LOW(1)
000ed2 c113      	RJMP _0x200001B
                 _0x2000021:
000ed3 322b      	CPI  R18,43
000ed4 f411      	BRNE _0x2000022
000ed5 e24b      	LDI  R20,LOW(43)
000ed6 c10f      	RJMP _0x200001B
                 _0x2000022:
000ed7 3220      	CPI  R18,32
000ed8 f411      	BRNE _0x2000023
000ed9 e240      	LDI  R20,LOW(32)
000eda c10b      	RJMP _0x200001B
                 _0x2000023:
000edb c002      	RJMP _0x2000024
                 _0x200001F:
000edc 30e2      	CPI  R30,LOW(0x2)
000edd f439      	BRNE _0x2000025
                 _0x2000024:
000ede e050      	LDI  R21,LOW(0)
000edf e013      	LDI  R17,LOW(3)
000ee0 3320      	CPI  R18,48
000ee1 f411      	BRNE _0x2000026
000ee2 6800      	ORI  R16,LOW(128)
000ee3 c102      	RJMP _0x200001B
                 _0x2000026:
000ee4 c003      	RJMP _0x2000027
                 _0x2000025:
000ee5 30e3      	CPI  R30,LOW(0x3)
000ee6 f009      	BREQ PC+2
000ee7 c0fe      	RJMP _0x200001B
                 _0x2000027:
000ee8 3320      	CPI  R18,48
000ee9 f010      	BRLO _0x200002A
000eea 332a      	CPI  R18,58
000eeb f008      	BRLO _0x200002B
                 _0x200002A:
000eec c007      	RJMP _0x2000029
                 _0x200002B:
000eed e0aa      	LDI  R26,LOW(10)
000eee 9f5a      	MUL  R21,R26
000eef 2d50      	MOV  R21,R0
000ef0 2fe2      	MOV  R30,R18
000ef1 53e0      	SUBI R30,LOW(48)
000ef2 0f5e      	ADD  R21,R30
000ef3 c0f2      	RJMP _0x200001B
                 _0x2000029:
000ef4 2fe2      	MOV  R30,R18
000ef5 36e3      	CPI  R30,LOW(0x63)
000ef6 f449      	BRNE _0x200002F
000ef7 940e 12f6 	CALL SUBOPT_0x4D
000ef9 89ea      	LDD  R30,Y+18
000efa 89fb      	LDD  R31,Y+18+1
000efb 81a4      	LDD  R26,Z+4
000efc 93aa      	ST   -Y,R26
000efd 940e 12fc 	CALL SUBOPT_0x4E
000eff c0e5      	RJMP _0x2000030
                 _0x200002F:
000f00 37e3      	CPI  R30,LOW(0x73)
000f01 f461      	BRNE _0x2000032
000f02 940e 12f6 	CALL SUBOPT_0x4D
000f04 940e 1302 	CALL SUBOPT_0x4F
000f06 83ee      	STD  Y+6,R30
000f07 83ff      	STD  Y+6+1,R31
000f08 81ae      	LDD  R26,Y+6
000f09 81bf      	LDD  R27,Y+6+1
000f0a 940e 1042 	CALL _strlen
000f0c 2f1e      	MOV  R17,R30
000f0d c013      	RJMP _0x2000033
                 _0x2000032:
000f0e 37e0      	CPI  R30,LOW(0x70)
000f0f f4a9      	BRNE _0x2000035
000f10 940e 12f6 	CALL SUBOPT_0x4D
000f12 89aa      	LDD  R26,Y+18
000f13 89bb      	LDD  R27,Y+18+1
000f14 9614      	ADIW R26,4
000f15 940e 13d3 	CALL __GETD1P
000f17 940e 1164 	CALL SUBOPT_0xF
                +
000f19 81ae     +LDD R26 , Y + 6
000f1a 81bf     +LDD R27 , Y + 6 + 1
000f1b 8588     +LDD R24 , Y + 6 + 2
000f1c 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
000f1d 940e 104e 	CALL _strlenf
000f1f 2f1e      	MOV  R17,R30
000f20 6008      	ORI  R16,LOW(8)
                 _0x2000033:
000f21 6002      	ORI  R16,LOW(2)
000f22 770f      	ANDI R16,LOW(127)
000f23 e030      	LDI  R19,LOW(0)
000f24 c03a      	RJMP _0x2000036
                 _0x2000035:
000f25 36e4      	CPI  R30,LOW(0x64)
000f26 f011      	BREQ _0x2000039
000f27 36e9      	CPI  R30,LOW(0x69)
000f28 f411      	BRNE _0x200003A
                 _0x2000039:
000f29 6004      	ORI  R16,LOW(4)
000f2a c002      	RJMP _0x200003B
                 _0x200003A:
000f2b 37e5      	CPI  R30,LOW(0x75)
000f2c f441      	BRNE _0x200003C
                 _0x200003B:
                +
000f2d e5e0     +LDI R30 , LOW ( 2 * _tbl10_G100 + ( 0 ) )
000f2e e0f1     +LDI R31 , HIGH ( 2 * _tbl10_G100 + ( 0 ) )
000f2f e060     +LDI R22 , BYTE3 ( 2 * _tbl10_G100 + ( 0 ) )
000f30 e070     +LDI R23 , BYTE4 ( 2 * _tbl10_G100 + ( 0 ) )
                 	__POINTD1FN _tbl10_G100,0
000f31 940e 1164 	CALL SUBOPT_0xF
000f33 e015      	LDI  R17,LOW(5)
000f34 c00e      	RJMP _0x200003D
                 _0x200003C:
000f35 35e8      	CPI  R30,LOW(0x58)
000f36 f411      	BRNE _0x200003F
000f37 6008      	ORI  R16,LOW(8)
000f38 c003      	RJMP _0x2000040
                 _0x200003F:
000f39 37e8      	CPI  R30,LOW(0x78)
000f3a f009      	BREQ PC+2
000f3b c0a9      	RJMP _0x2000071
                 _0x2000040:
                +
000f3c e5ea     +LDI R30 , LOW ( 2 * _tbl16_G100 + ( 0 ) )
000f3d e0f1     +LDI R31 , HIGH ( 2 * _tbl16_G100 + ( 0 ) )
000f3e e060     +LDI R22 , BYTE3 ( 2 * _tbl16_G100 + ( 0 ) )
000f3f e070     +LDI R23 , BYTE4 ( 2 * _tbl16_G100 + ( 0 ) )
                 	__POINTD1FN _tbl16_G100,0
000f40 940e 1164 	CALL SUBOPT_0xF
000f42 e014      	LDI  R17,LOW(4)
                 _0x200003D:
000f43 ff02      	SBRS R16,2
000f44 c014      	RJMP _0x2000042
000f45 940e 12f6 	CALL SUBOPT_0x4D
000f47 940e 1302 	CALL SUBOPT_0x4F
000f49 87ec      	STD  Y+12,R30
000f4a 87fd      	STD  Y+12+1,R31
000f4b 85ad      	LDD  R26,Y+13
000f4c 23aa      	TST  R26
000f4d f42a      	BRPL _0x2000043
000f4e 940e 133d 	CALL __ANEGW1
000f50 87ec      	STD  Y+12,R30
000f51 87fd      	STD  Y+12+1,R31
000f52 e24d      	LDI  R20,LOW(45)
                 _0x2000043:
000f53 3040      	CPI  R20,0
000f54 f011      	BREQ _0x2000044
000f55 5f1f      	SUBI R17,-LOW(1)
000f56 c001      	RJMP _0x2000045
                 _0x2000044:
000f57 7f0b      	ANDI R16,LOW(251)
                 _0x2000045:
000f58 c006      	RJMP _0x2000046
                 _0x2000042:
000f59 940e 12f6 	CALL SUBOPT_0x4D
000f5b 940e 1302 	CALL SUBOPT_0x4F
000f5d 87ec      	STD  Y+12,R30
000f5e 87fd      	STD  Y+12+1,R31
                 _0x2000046:
                 _0x2000036:
000f5f fd00      	SBRC R16,0
000f60 c011      	RJMP _0x2000047
                 _0x2000048:
000f61 1715      	CP   R17,R21
000f62 f478      	BRSH _0x200004A
000f63 ff07      	SBRS R16,7
000f64 c008      	RJMP _0x200004B
000f65 ff02      	SBRS R16,2
000f66 c004      	RJMP _0x200004C
000f67 7f0b      	ANDI R16,LOW(251)
000f68 2f24      	MOV  R18,R20
000f69 5011      	SUBI R17,LOW(1)
000f6a c001      	RJMP _0x200004D
                 _0x200004C:
000f6b e320      	LDI  R18,LOW(48)
                 _0x200004D:
000f6c c001      	RJMP _0x200004E
                 _0x200004B:
000f6d e220      	LDI  R18,LOW(32)
                 _0x200004E:
000f6e 940e 12ef 	CALL SUBOPT_0x4C
000f70 5051      	SUBI R21,LOW(1)
000f71 cfef      	RJMP _0x2000048
                 _0x200004A:
                 _0x2000047:
000f72 2f31      	MOV  R19,R17
000f73 ff01      	SBRS R16,1
000f74 c018      	RJMP _0x200004F
                 _0x2000050:
000f75 3030      	CPI  R19,0
000f76 f0a9      	BREQ _0x2000052
000f77 ff03      	SBRS R16,3
000f78 c007      	RJMP _0x2000053
000f79 01de      	MOVW R26,R28
000f7a 9616      	ADIW R26,6
000f7b 940e 12e5 	CALL SUBOPT_0x4B
                +
000f7d bf6b     +OUT RAMPZ , R22
000f7e 9126     +ELPM R18 , Z
                 	__GETBRPF 18
000f7f c005      	RJMP _0x2000054
                 _0x2000053:
000f80 81ae      	LDD  R26,Y+6
000f81 81bf      	LDD  R27,Y+6+1
000f82 912d      	LD   R18,X+
000f83 83ae      	STD  Y+6,R26
000f84 83bf      	STD  Y+6+1,R27
                 _0x2000054:
000f85 940e 12ef 	CALL SUBOPT_0x4C
000f87 3050      	CPI  R21,0
000f88 f009      	BREQ _0x2000055
000f89 5051      	SUBI R21,LOW(1)
                 _0x2000055:
000f8a 5031      	SUBI R19,LOW(1)
000f8b cfe9      	RJMP _0x2000050
                 _0x2000052:
000f8c c04e      	RJMP _0x2000056
                 _0x200004F:
                 _0x2000058:
000f8d e320      	LDI  R18,LOW(48)
000f8e 940e 115f 	CALL SUBOPT_0xE
000f90 940e 13e8 	CALL __GETW1PF
000f92 87ea      	STD  Y+10,R30
000f93 87fb      	STD  Y+10+1,R31
000f94 940e 115f 	CALL SUBOPT_0xE
                +
000f96 5fee     +SUBI R30 , LOW ( - 2 )
000f97 4fff     +SBCI R31 , HIGH ( - 2 )
000f98 4f6f     +SBCI R22 , BYTE3 ( - 2 )
000f99 4f7f     +SBCI R23 , BYTE4 ( - 2 )
                 	__ADDD1N 2
000f9a 940e 1164 	CALL SUBOPT_0xF
                 _0x200005A:
000f9c 85ea      	LDD  R30,Y+10
000f9d 85fb      	LDD  R31,Y+10+1
000f9e 85ac      	LDD  R26,Y+12
000f9f 85bd      	LDD  R27,Y+12+1
000fa0 17ae      	CP   R26,R30
000fa1 07bf      	CPC  R27,R31
000fa2 f050      	BRLO _0x200005C
000fa3 5f2f      	SUBI R18,-LOW(1)
000fa4 85aa      	LDD  R26,Y+10
000fa5 85bb      	LDD  R27,Y+10+1
000fa6 85ec      	LDD  R30,Y+12
000fa7 85fd      	LDD  R31,Y+12+1
000fa8 1bea      	SUB  R30,R26
000fa9 0bfb      	SBC  R31,R27
000faa 87ec      	STD  Y+12,R30
000fab 87fd      	STD  Y+12+1,R31
000fac cfef      	RJMP _0x200005A
                 _0x200005C:
000fad 332a      	CPI  R18,58
000fae f028      	BRLO _0x200005D
000faf ff03      	SBRS R16,3
000fb0 c002      	RJMP _0x200005E
000fb1 5f29      	SUBI R18,-LOW(7)
000fb2 c001      	RJMP _0x200005F
                 _0x200005E:
000fb3 5d29      	SUBI R18,-LOW(39)
                 _0x200005F:
                 _0x200005D:
000fb4 fd04      	SBRC R16,4
000fb5 c01a      	RJMP _0x2000061
000fb6 3321      	CPI  R18,49
000fb7 f420      	BRSH _0x2000063
000fb8 85aa      	LDD  R26,Y+10
000fb9 85bb      	LDD  R27,Y+10+1
000fba 9711      	SBIW R26,1
000fbb f409      	BRNE _0x2000062
                 _0x2000063:
000fbc c009      	RJMP _0x20000CD
                 _0x2000062:
000fbd 1753      	CP   R21,R19
000fbe f010      	BRLO _0x2000067
000fbf ff00      	SBRS R16,0
000fc0 c001      	RJMP _0x2000068
                 _0x2000067:
000fc1 c013      	RJMP _0x2000066
                 _0x2000068:
000fc2 e220      	LDI  R18,LOW(32)
000fc3 ff07      	SBRS R16,7
000fc4 c00b      	RJMP _0x2000069
000fc5 e320      	LDI  R18,LOW(48)
                 _0x20000CD:
000fc6 6100      	ORI  R16,LOW(16)
000fc7 ff02      	SBRS R16,2
000fc8 c007      	RJMP _0x200006A
000fc9 7f0b      	ANDI R16,LOW(251)
000fca 934a      	ST   -Y,R20
000fcb 940e 12fc 	CALL SUBOPT_0x4E
000fcd 3050      	CPI  R21,0
000fce f009      	BREQ _0x200006B
000fcf 5051      	SUBI R21,LOW(1)
                 _0x200006B:
                 _0x200006A:
                 _0x2000069:
                 _0x2000061:
000fd0 940e 12ef 	CALL SUBOPT_0x4C
000fd2 3050      	CPI  R21,0
000fd3 f009      	BREQ _0x200006C
000fd4 5051      	SUBI R21,LOW(1)
                 _0x200006C:
                 _0x2000066:
000fd5 5031      	SUBI R19,LOW(1)
000fd6 85aa      	LDD  R26,Y+10
000fd7 85bb      	LDD  R27,Y+10+1
000fd8 9712      	SBIW R26,2
000fd9 f008      	BRLO _0x2000059
000fda cfb2      	RJMP _0x2000058
                 _0x2000059:
                 _0x2000056:
000fdb ff00      	SBRS R16,0
000fdc c008      	RJMP _0x200006D
                 _0x200006E:
000fdd 3050      	CPI  R21,0
000fde f031      	BREQ _0x2000070
000fdf 5051      	SUBI R21,LOW(1)
000fe0 e2e0      	LDI  R30,LOW(32)
000fe1 93ea      	ST   -Y,R30
000fe2 940e 12fc 	CALL SUBOPT_0x4E
000fe4 cff8      	RJMP _0x200006E
                 _0x2000070:
                 _0x200006D:
                 _0x2000071:
                 _0x2000030:
                 _0x20000CC:
000fe5 e010      	LDI  R17,LOW(0)
                 _0x200001B:
000fe6 ceca      	RJMP _0x2000016
                 _0x2000018:
000fe7 85ae      	LDD  R26,Y+14
000fe8 85bf      	LDD  R27,Y+14+1
000fe9 940e 13cf 	CALL __GETW1P
                 _0x20C0003:
000feb 940e 1467 	CALL __LOADLOCR6
000fed 9668      	ADIW R28,24
000fee 9508      	RET
                 ; .FEND
                 _printf:
                 ; .FSTART _printf
000fef 92ff      	PUSH R15
000ff0 2ef8      	MOV  R15,R24
000ff1 9726      	SBIW R28,6
000ff2 931a      	ST   -Y,R17
000ff3 930a      	ST   -Y,R16
000ff4 01de      	MOVW R26,R28
000ff5 9614      	ADIW R26,4
000ff6 940e 1320 	CALL __ADDW2R15
000ff8 018d      	MOVW R16,R26
000ff9 e0e0      	LDI  R30,LOW(0)
000ffa 83ec      	STD  Y+4,R30
000ffb 83ed      	STD  Y+4+1,R30
000ffc 83ee      	STD  Y+6,R30
000ffd 83ef      	STD  Y+6+1,R30
000ffe 01de      	MOVW R26,R28
000fff 9618      	ADIW R26,8
001000 940e 1320 	CALL __ADDW2R15
001002 940e 13d3 	CALL __GETD1P
001004 940e 1404 	CALL __PUTPARD1
001006 931a      	ST   -Y,R17
001007 930a      	ST   -Y,R16
001008 e9ea      	LDI  R30,LOW(_put_usart_G100)
001009 e0fe      	LDI  R31,HIGH(_put_usart_G100)
00100a 93fa      	ST   -Y,R31
00100b 93ea      	ST   -Y,R30
00100c 01de      	MOVW R26,R28
00100d 961a      	ADIW R26,10
00100e de98      	RCALL __print_G100
00100f 8119      	LDD  R17,Y+1
001010 8108      	LDD  R16,Y+0
001011 9628      	ADIW R28,8
001012 90ff      	POP  R15
001013 9508      	RET
                 ; .FEND
                 
                 	.CSEG
                 _itoa:
                 ; .FSTART _itoa
001014 93ba      	ST   -Y,R27
001015 93aa      	ST   -Y,R26
001016 91a9          ld   r26,y+
001017 91b9          ld   r27,y+
001018 91e9          ld   r30,y+
001019 91f9          ld   r31,y+
00101a 9630          adiw r30,0
00101b f42a          brpl __itoa0
00101c 95e0          com  r30
00101d 95f0          com  r31
00101e 9631          adiw r30,1
00101f e26d          ldi  r22,'-'
001020 936d          st   x+,r22
                 __itoa0:
001021 94e8          clt
001022 e180          ldi  r24,low(10000)
001023 e297          ldi  r25,high(10000)
001024 d00d          rcall __itoa1
001025 ee88          ldi  r24,low(1000)
001026 e093          ldi  r25,high(1000)
001027 d00a          rcall __itoa1
001028 e684          ldi  r24,100
001029 2799          clr  r25
00102a d007          rcall __itoa1
00102b e08a          ldi  r24,10
00102c d005          rcall __itoa1
00102d 2f6e          mov  r22,r30
00102e d010          rcall __itoa5
00102f 2766          clr  r22
001030 936c          st   x,r22
001031 9508          ret
                 
                 __itoa1:
001032 2766          clr	 r22
                 __itoa2:
001033 17e8          cp   r30,r24
001034 07f9          cpc  r31,r25
001035 f020          brlo __itoa3
001036 9563          inc  r22
001037 1be8          sub  r30,r24
001038 0bf9          sbc  r31,r25
001039 f7c9          brne __itoa2
                 __itoa3:
00103a 2366          tst  r22
00103b f411          brne __itoa4
00103c f016          brts __itoa5
00103d 9508          ret
                 __itoa4:
00103e 9468          set
                 __itoa5:
00103f 5d60          subi r22,-0x30
001040 936d          st   x+,r22
001041 9508          ret
                 ; .FEND
                 
                 	.DSEG
                 
                 	.CSEG
                 
                 	.CSEG
                 _strlen:
                 ; .FSTART _strlen
001042 93ba      	ST   -Y,R27
001043 93aa      	ST   -Y,R26
001044 91a9          ld   r26,y+
001045 91b9          ld   r27,y+
001046 27ee          clr  r30
001047 27ff          clr  r31
                 strlen0:
001048 916d          ld   r22,x+
001049 2366          tst  r22
00104a f011          breq strlen1
00104b 9631          adiw r30,1
00104c cffb          rjmp strlen0
                 strlen1:
00104d 9508          ret
                 ; .FEND
                 _strlenf:
                 ; .FSTART _strlenf
00104e 940e 1409 	CALL __PUTPARD2
001050 27aa          clr  r26
001051 27bb          clr  r27
001052 91e9          ld   r30,y+
001053 91f9          ld   r31,y+
001054 9169          ld   r22,y+
001055 9179          ld   r23,y+
001056 bf6b          out  rampz,r22
                 strlenf0:
001057 9007          elpm r0,z+
001058 2000          tst  r0
001059 f011          breq strlenf1
00105a 9611          adiw r26,1
00105b cffb          rjmp strlenf0
                 strlenf1:
00105c 01fd          movw r30,r26
00105d 9508          ret
                 ; .FEND
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 
                 	.DSEG
                 
                 	.CSEG
                 __lcd_write_nibble_G103:
                 ; .FSTART __lcd_write_nibble_G103
00105e 93aa      	ST   -Y,R26
00105f b3e5      	IN   R30,0x15
001060 70ef      	ANDI R30,LOW(0xF)
001061 2fae      	MOV  R26,R30
001062 81e8      	LD   R30,Y
001063 7fe0      	ANDI R30,LOW(0xF0)
001064 2bea      	OR   R30,R26
001065 bbe5      	OUT  0x15,R30
                +
001066 e181     +LDI R24 , LOW ( 17 )
                +__DELAY_USB_LOOP :
001067 958a     +DEC R24
001068 f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 17
001069 9aa9      	SBI  0x15,1
                +
00106a e181     +LDI R24 , LOW ( 17 )
                +__DELAY_USB_LOOP :
00106b 958a     +DEC R24
00106c f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 17
00106d 98a9      	CBI  0x15,1
                +
00106e e181     +LDI R24 , LOW ( 17 )
                +__DELAY_USB_LOOP :
00106f 958a     +DEC R24
001070 f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 17
001071 c08c      	RJMP _0x20C0001
                 ; .FEND
                 __lcd_write_data:
                 ; .FSTART __lcd_write_data
001072 93aa      	ST   -Y,R26
001073 81a8      	LD   R26,Y
001074 dfe9      	RCALL __lcd_write_nibble_G103
001075 81e8          ld    r30,y
001076 95e2          swap  r30
001077 83e8          st    y,r30
001078 81a8      	LD   R26,Y
001079 dfe4      	RCALL __lcd_write_nibble_G103
                +
00107a ea87     +LDI R24 , LOW ( 167 )
                +__DELAY_USB_LOOP :
00107b 958a     +DEC R24
00107c f7f1     +BRNE __DELAY_USB_LOOP
                 	__DELAY_USB 167
00107d c080      	RJMP _0x20C0001
                 ; .FEND
                 _lcd_gotoxy:
                 ; .FSTART _lcd_gotoxy
00107e 93aa      	ST   -Y,R26
00107f 81e8      	LD   R30,Y
001080 e0f0      	LDI  R31,0
001081 5de6      	SUBI R30,LOW(-__base_y_G103)
001082 4ff6      	SBCI R31,HIGH(-__base_y_G103)
001083 81e0      	LD   R30,Z
001084 81a9      	LDD  R26,Y+1
001085 0fae      	ADD  R26,R30
001086 dfeb      	RCALL __lcd_write_data
001087 80d9      	LDD  R13,Y+1
001088 80c8      	LDD  R12,Y+0
001089 9622      	ADIW R28,2
00108a 9508      	RET
                 ; .FEND
                 _lcd_clear:
                 ; .FSTART _lcd_clear
00108b e0a2      	LDI  R26,LOW(2)
00108c 940e 1308 	CALL SUBOPT_0x50
00108e e0ac      	LDI  R26,LOW(12)
00108f dfe2      	RCALL __lcd_write_data
001090 e0a1      	LDI  R26,LOW(1)
001091 940e 1308 	CALL SUBOPT_0x50
001093 e0e0      	LDI  R30,LOW(0)
001094 2ece      	MOV  R12,R30
001095 2ede      	MOV  R13,R30
001096 9508      	RET
                 ; .FEND
                 _lcd_putchar:
                 ; .FSTART _lcd_putchar
001097 93aa      	ST   -Y,R26
001098 81a8      	LD   R26,Y
001099 30aa      	CPI  R26,LOW(0xA)
00109a f021      	BREQ _0x2060005
00109b 91e0 092e 	LDS  R30,__lcd_maxx
00109d 16de      	CP   R13,R30
00109e f048      	BRLO _0x2060004
                 _0x2060005:
00109f e0e0      	LDI  R30,LOW(0)
0010a0 93ea      	ST   -Y,R30
0010a1 94c3      	INC  R12
0010a2 2dac      	MOV  R26,R12
0010a3 dfda      	RCALL _lcd_gotoxy
0010a4 81a8      	LD   R26,Y
0010a5 30aa      	CPI  R26,LOW(0xA)
0010a6 f409      	BRNE _0x2060007
0010a7 c056      	RJMP _0x20C0001
                 _0x2060007:
                 _0x2060004:
0010a8 94d3      	INC  R13
0010a9 9aaa      	SBI  0x15,2
0010aa 81a8      	LD   R26,Y
0010ab dfc6      	RCALL __lcd_write_data
0010ac 98aa      	CBI  0x15,2
0010ad c050      	RJMP _0x20C0001
                 ; .FEND
                 _lcd_puts:
                 ; .FSTART _lcd_puts
0010ae 93ba      	ST   -Y,R27
0010af 93aa      	ST   -Y,R26
0010b0 931a      	ST   -Y,R17
                 _0x2060008:
0010b1 81a9      	LDD  R26,Y+1
0010b2 81ba      	LDD  R27,Y+1+1
0010b3 91ed      	LD   R30,X+
0010b4 83a9      	STD  Y+1,R26
0010b5 83ba      	STD  Y+1+1,R27
0010b6 2f1e      	MOV  R17,R30
0010b7 30e0      	CPI  R30,0
0010b8 f019      	BREQ _0x206000A
0010b9 2fa1      	MOV  R26,R17
0010ba dfdc      	RCALL _lcd_putchar
0010bb cff5      	RJMP _0x2060008
                 _0x206000A:
0010bc 8118      	LDD  R17,Y+0
                 _0x20C0002:
0010bd 9623      	ADIW R28,3
0010be 9508      	RET
                 ; .FEND
                 _lcd_putsf:
                 ; .FSTART _lcd_putsf
0010bf 940e 1409 	CALL __PUTPARD2
0010c1 931a      	ST   -Y,R17
                 _0x206000B:
0010c2 01de      	MOVW R26,R28
0010c3 9611      	ADIW R26,1
0010c4 940e 12e5 	CALL SUBOPT_0x4B
                +
0010c6 bf6b     +OUT RAMPZ , R22
0010c7 91e6     +ELPM R30 , Z
                 	__GETBRPF 30
0010c8 2f1e      	MOV  R17,R30
0010c9 30e0      	CPI  R30,0
0010ca f019      	BREQ _0x206000D
0010cb 2fa1      	MOV  R26,R17
0010cc dfca      	RCALL _lcd_putchar
0010cd cff4      	RJMP _0x206000B
                 _0x206000D:
0010ce 8118      	LDD  R17,Y+0
0010cf 9625      	ADIW R28,5
0010d0 9508      	RET
                 ; .FEND
                 _lcd_init:
                 ; .FSTART _lcd_init
0010d1 93aa      	ST   -Y,R26
0010d2 b3e4      	IN   R30,0x14
0010d3 6fe0      	ORI  R30,LOW(0xF0)
0010d4 bbe4      	OUT  0x14,R30
0010d5 9aa1      	SBI  0x14,1
0010d6 9aa2      	SBI  0x14,2
0010d7 9aa3      	SBI  0x14,3
0010d8 98a9      	CBI  0x15,1
0010d9 98aa      	CBI  0x15,2
0010da 98ab      	CBI  0x15,3
0010db 81e8      	LD   R30,Y
0010dc 93e0 092e 	STS  __lcd_maxx,R30
0010de 58e0      	SUBI R30,-LOW(128)
                +
0010df 93e0 092c+STS __base_y_G103 + ( 2 ) , R30
                 	__PUTB1MN __base_y_G103,2
0010e1 81e8      	LD   R30,Y
0010e2 54e0      	SUBI R30,-LOW(192)
                +
0010e3 93e0 092d+STS __base_y_G103 + ( 3 ) , R30
                 	__PUTB1MN __base_y_G103,3
0010e5 e1a4      	LDI  R26,LOW(20)
0010e6 e0b0      	LDI  R27,0
0010e7 940e 1316 	CALL _delay_ms
0010e9 940e 130e 	CALL SUBOPT_0x51
0010eb 940e 130e 	CALL SUBOPT_0x51
0010ed 940e 130e 	CALL SUBOPT_0x51
0010ef e2a0      	LDI  R26,LOW(32)
0010f0 df6d      	RCALL __lcd_write_nibble_G103
                +
0010f1 ef8a     +LDI R24 , LOW ( 250 )
0010f2 e090     +LDI R25 , HIGH ( 250 )
                +__DELAY_USW_LOOP :
0010f3 9701     +SBIW R24 , 1
0010f4 f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 250
0010f5 e2a8      	LDI  R26,LOW(40)
0010f6 df7b      	RCALL __lcd_write_data
0010f7 e0a4      	LDI  R26,LOW(4)
0010f8 df79      	RCALL __lcd_write_data
0010f9 e8a5      	LDI  R26,LOW(133)
0010fa df77      	RCALL __lcd_write_data
0010fb e0a6      	LDI  R26,LOW(6)
0010fc df75      	RCALL __lcd_write_data
0010fd df8d      	RCALL _lcd_clear
                 _0x20C0001:
0010fe 9621      	ADIW R28,1
0010ff 9508      	RET
                 ; .FEND
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.DSEG
                 _testChar_S0000003000:
000920           	.BYTE 0x1
                 
                 	.ESEG
                 
                 	.ORG 0xA
                 __EepromBackup:
00000a           	.BYTE 0x107
                 
                 	.ORG 0x0
                 
                 	.DSEG
                 _FatFs_G002:
000921           	.BYTE 0x2
                 _CardType_G003:
000923           	.BYTE 0x1
                 _wc_S0030007000:
000924           	.BYTE 0x2
                 __seed_G101:
000926           	.BYTE 0x4
                 __base_y_G103:
00092a           	.BYTE 0x4
                 __lcd_maxx:
00092e           	.BYTE 0x1
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
001100 e0f0      	LDI  R31,0
001101 93fa      	ST   -Y,R31
001102 93ea      	ST   -Y,R30
001103 01d8      	MOVW R26,R16
001104 940c 1014 	JMP  _itoa
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x1:
001106 e8ac      	LDI  R26,LOW(_error_msg*2)
001107 e0b0      	LDI  R27,HIGH(_error_msg*2)
001108 e080      	LDI  R24,BYTE3(_error_msg*2)
001109 27ff      	CLR  R31
00110a 2766      	CLR  R22
00110b 2777      	CLR  R23
00110c 940e 135f 	CALL __LSLD1
00110e 940e 135f 	CALL __LSLD1
001110 940e 1324 	CALL __ADDD12
001112 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
                 SUBOPT_0x2:
001113 940e 1404 	CALL __PUTPARD1
001115 e084      	LDI  R24,4
001116 940e 0fef 	CALL _printf
001118 9628      	ADIW R28,8
001119 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x3:
00111a 940e 1404 	CALL __PUTPARD1
00111c 01fe      	MOVW R30,R28
00111d 5eec      	SUBI R30,LOW(-(276))
00111e 4ffe      	SBCI R31,HIGH(-(276))
00111f 2766      	CLR  R22
001120 2777      	CLR  R23
001121 cff1      	RJMP SUBOPT_0x2
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x4:
001122 01de      	MOVW R26,R28
001123 5fa0      	SUBI R26,LOW(-(272))
001124 4fbe      	SBCI R27,HIGH(-(272))
001125 940e 0a51 	CALL _pf_open
001127 2f1e      	MOV  R17,R30
001128 30e0      	CPI  R30,0
001129 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x5:
00112a 98a9      	CBI  0x15,1
00112b efa4      	LDI  R26,LOW(500)
00112c e0b1      	LDI  R27,HIGH(500)
00112d 940e 1316 	CALL _delay_ms
00112f 9aa9      	SBI  0x15,1
001130 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x6:
001131 efa4      	LDI  R26,LOW(500)
001132 e0b1      	LDI  R27,HIGH(500)
001133 940c 1316 	JMP  _delay_ms
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x7:
                +
001135 e0e2     +LDI R30 , LOW ( 0x2 )
001136 e0f0     +LDI R31 , HIGH ( 0x2 )
001137 e060     +LDI R22 , BYTE3 ( 0x2 )
001138 e070     +LDI R23 , BYTE4 ( 0x2 )
                 	__GETD1N 0x2
001139 940e 1404 	CALL __PUTPARD1
00113b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x8:
00113c e2e0      	LDI  R30,LOW(_testChar_S0000003000)
00113d e0f9      	LDI  R31,HIGH(_testChar_S0000003000)
00113e 93fa      	ST   -Y,R31
00113f 93ea      	ST   -Y,R30
001140 e0a1      	LDI  R26,LOW(1)
001141 e0b0      	LDI  R27,0
001142 940c 03f8 	JMP  _ReadFlashBytes
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x9:
001144 940e 1404 	CALL __PUTPARD1
001146 cff5      	RJMP SUBOPT_0x8
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xA:
001147 940e 13fa 	CALL __GETD1S0
001149 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xB:
00114a 93ba      	ST   -Y,R27
00114b 93aa      	ST   -Y,R26
00114c 931a      	ST   -Y,R17
00114d 930a      	ST   -Y,R16
00114e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xC:
                +
00114f 81ec     +LDD R30 , Y + 4
001150 81fd     +LDD R31 , Y + 4 + 1
001151 816e     +LDD R22 , Y + 4 + 2
001152 817f     +LDD R23 , Y + 4 + 3
                 	__GETD1S 4
001153 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0xD:
001154 01f8      	MOVW R30,R16
                +
001155 81ac     +LDD R26 , Y + 4
001156 81bd     +LDD R27 , Y + 4 + 1
001157 818e     +LDD R24 , Y + 4 + 2
001158 819f     +LDD R25 , Y + 4 + 3
                 	__GETD2S 4
001159 2766      	CLR  R22
00115a 2777      	CLR  R23
00115b 940e 1329 	CALL __ADDD21
00115d 940c 03ca 	JMP  _ReadFlashByte
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xE:
                +
00115f 81ee     +LDD R30 , Y + 6
001160 81ff     +LDD R31 , Y + 6 + 1
001161 8568     +LDD R22 , Y + 6 + 2
001162 8579     +LDD R23 , Y + 6 + 3
                 	__GETD1S 6
001163 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0xF:
                +
001164 83ee     +STD Y + 6 , R30
001165 83ff     +STD Y + 6 + 1 , R31
001166 8768     +STD Y + 6 + 2 , R22
001167 8779     +STD Y + 6 + 3 , R23
                 	__PUTD1S 6
001168 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x10:
                +
001169 01fe     +MOVW R30 , R28
00116a 5fe4     +SUBI R30 , LOW ( - 268 )
00116b 4ffe     +SBCI R31 , HIGH ( - 268 )
00116c 9001     +LD R0 , Z +
00116d 81f0     +LD R31 , Z
00116e 2de0     +MOV R30 , R0
                 	__GETW1SX 268
00116f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x11:
                +
001170 01fe     +MOVW R30 , R28
001171 5fe0     +SUBI R30 , LOW ( - 272 )
001172 4ffe     +SBCI R31 , HIGH ( - 272 )
001173 9001     +LD R0 , Z +
001174 9011     +LD R1 , Z +
001175 9161     +LD R22 , Z +
001176 8170     +LD R23 , Z
001177 01f0     +MOVW R30 , R0
                 	__GETD1SX 272
                +
001178 7fef     +ANDI R30 , LOW ( 0xFF )
001179 70f0     +ANDI R31 , HIGH ( 0xFF )
00117a 7060     +ANDI R22 , BYTE3 ( 0xFF )
00117b 7070     +ANDI R23 , BYTE4 ( 0xFF )
                 	__ANDD1N 0xFF
00117c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x12:
                +
00117d 01de     +MOVW R26 , R28
00117e 5fa0     +SUBI R26 , LOW ( - 272 )
00117f 4fbe     +SBCI R27 , HIGH ( - 272 )
001180 900d     +LD R0 , X +
001181 901d     +LD R1 , X +
001182 918d     +LD R24 , X +
001183 919c     +LD R25 , X
001184 01d0     +MOVW R26 , R0
                 	__GETD2SX 272
001185 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x13:
                +
001186 85e8     +LDD R30 , Y + 8
001187 85f9     +LDD R31 , Y + 8 + 1
001188 856a     +LDD R22 , Y + 8 + 2
001189 857b     +LDD R23 , Y + 8 + 3
                 	__GETD1S 8
00118a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x14:
                +
00118b 83ec     +STD Y + 4 , R30
00118c 83fd     +STD Y + 4 + 1 , R31
00118d 836e     +STD Y + 4 + 2 , R22
00118e 837f     +STD Y + 4 + 3 , R23
                 	__PUTD1S 4
00118f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x15:
001190 2766      	CLR  R22
001191 2777      	CLR  R23
001192 940e 1324 	CALL __ADDD12
001194 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x16:
                +
001195 85ea     +LDD R30 , Y + 10
001196 85fb     +LDD R31 , Y + 10 + 1
001197 856c     +LDD R22 , Y + 10 + 2
001198 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
001199 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x17:
                +
00119a 85aa     +LDD R26 , Y + 10
00119b 85bb     +LDD R27 , Y + 10 + 1
00119c 858c     +LDD R24 , Y + 10 + 2
00119d 859d     +LDD R25 , Y + 10 + 3
                 	__GETD2S 10
00119e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x18:
00119f 81ea      	LDD  R30,Y+2
0011a0 81fb      	LDD  R31,Y+2+1
0011a1 9731      	SBIW R30,1
0011a2 81a8      	LD   R26,Y
0011a3 81b9      	LDD  R27,Y+1
0011a4 0fae      	ADD  R26,R30
0011a5 1fbf      	ADC  R27,R31
0011a6 91ec      	LD   R30,X
0011a7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x19:
0011a8 91e0 0921 	LDS  R30,_FatFs_G002
0011aa 91f0 0922 	LDS  R31,_FatFs_G002+1
0011ac 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1A:
                +
0011ad 85ac     +LDD R26 , Y + 12
0011ae 85bd     +LDD R27 , Y + 12 + 1
0011af 858e     +LDD R24 , Y + 12 + 2
0011b0 859f     +LDD R25 , Y + 12 + 3
                 	__GETD2S 12
0011b1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x1B:
                +
0011b2 30a2     +CPI R26 , LOW ( 0x2 )
0011b3 e0e0     +LDI R30 , HIGH ( 0x2 )
0011b4 07be     +CPC R27 , R30
0011b5 e0e0     +LDI R30 , BYTE3 ( 0x2 )
0011b6 078e     +CPC R24 , R30
0011b7 e0e0     +LDI R30 , BYTE4 ( 0x2 )
0011b8 079e     +CPC R25 , R30
                 	__CPD2N 0x2
0011b9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x1C:
0011ba 01fe      	MOVW R30,R28
0011bb 9638      	ADIW R30,8
0011bc 93fa      	ST   -Y,R31
0011bd 93ea      	ST   -Y,R30
0011be 85e8      	LDD  R30,Y+8
0011bf 85f9      	LDD  R31,Y+8+1
                +
0011c0 85a4     +LDD R26 , Z + 12
0011c1 85b5     +LDD R27 , Z + 12 + 1
0011c2 8586     +LDD R24 , Z + 12 + 2
0011c3 8597     +LDD R25 , Z + 12 + 3
                 	__GETD2Z 12
0011c4 01f9      	MOVW R30,R18
0011c5 cfca      	RJMP SUBOPT_0x15
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x1D:
0011c6 e0a2      	LDI  R26,LOW(2)
0011c7 e0b0      	LDI  R27,0
0011c8 940e 0db7 	CALL _disk_readp
0011ca 30e0      	CPI  R30,0
0011cb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1E:
0011cc 93fa      	ST   -Y,R31
0011cd 93ea      	ST   -Y,R30
0011ce e0a1      	LDI  R26,LOW(1)
0011cf e0b0      	LDI  R27,0
0011d0 940e 0db7 	CALL _disk_readp
0011d2 30e0      	CPI  R30,0
0011d3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x1F:
0011d4 93fa      	ST   -Y,R31
0011d5 93ea      	ST   -Y,R30
0011d6 85e8      	LDD  R30,Y+8
0011d7 85f9      	LDD  R31,Y+8+1
                +
0011d8 85a4     +LDD R26 , Z + 12
0011d9 85b5     +LDD R27 , Z + 12 + 1
0011da 8586     +LDD R24 , Z + 12 + 2
0011db 8597     +LDD R25 , Z + 12 + 3
                 	__GETD2Z 12
0011dc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x20:
                +
0011dd 5fef     +SUBI R30 , LOW ( - 1 )
0011de 4fff     +SBCI R31 , HIGH ( - 1 )
0011df 4f6f     +SBCI R22 , BYTE3 ( - 1 )
0011e0 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__ADDD1N 1
0011e1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x21:
                +
0011e2 85ae     +LDD R26 , Y + 14
0011e3 85bf     +LDD R27 , Y + 14 + 1
0011e4 8988     +LDD R24 , Y + 14 + 2
0011e5 8999     +LDD R25 , Y + 14 + 3
                 	__GETD2S 14
0011e6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x22:
0011e7 940e 1324 	CALL __ADDD12
0011e9 940e 1404 	CALL __PUTPARD1
0011eb 89ea      	LDD  R30,Y+18
0011ec 89fb      	LDD  R31,Y+18+1
0011ed 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x23:
0011ee 93fa      	ST   -Y,R31
0011ef 93ea      	ST   -Y,R30
0011f0 cfd5      	RJMP SUBOPT_0x1D
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x24:
0011f1 e0b0      	LDI  R27,0
0011f2 940e 0db7 	CALL _disk_readp
0011f4 30e0      	CPI  R30,0
0011f5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x25:
0011f6 931a      	ST   -Y,R17
0011f7 930a      	ST   -Y,R16
                +
0011f8 9100 0921+LDS R16 , 0 + ( _FatFs_G002 )
0011fa 9110 0922+LDS R17 , 0 + ( _FatFs_G002 ) + 1
                 	__GETWRMN 16,17,0,_FatFs_G002
0011fc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
                 SUBOPT_0x26:
                +
0011fd 81ea     +LDD R30 , Y + 2
0011fe 81fb     +LDD R31 , Y + 2 + 1
0011ff 816c     +LDD R22 , Y + 2 + 2
001200 817d     +LDD R23 , Y + 2 + 3
                 	__GETD1S 2
001201 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x27:
                +
001202 83ea     +STD Y + 2 , R30
001203 83fb     +STD Y + 2 + 1 , R31
001204 836c     +STD Y + 2 + 2 , R22
001205 837d     +STD Y + 2 + 3 , R23
                 	__PUTD1S 2
001206 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x28:
                +
001207 81aa     +LDD R26 , Y + 2
001208 81bb     +LDD R27 , Y + 2 + 1
001209 818c     +LDD R24 , Y + 2 + 2
00120a 819d     +LDD R25 , Y + 2 + 3
                 	__GETD2S 2
00120b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x29:
                +
00120c e0e0     +LDI R30 , LOW ( 0x0 )
00120d e0f0     +LDI R31 , HIGH ( 0x0 )
00120e e060     +LDI R22 , BYTE3 ( 0x0 )
00120f e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
001210 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x2A:
001211 e0e0      	LDI  R30,LOW(0)
001212 e0f0      	LDI  R31,HIGH(0)
001213 93ed      	ST   X+,R30
001214 93fc      	ST   X,R31
001215 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2B:
001216 940e 1462 	CALL __SAVELOCR4
                +
001218 9120 0921+LDS R18 , 0 + ( _FatFs_G002 )
00121a 9130 0922+LDS R19 , 0 + ( _FatFs_G002 ) + 1
                 	__GETWRMN 18,19,0,_FatFs_G002
00121c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2C:
                +
00121d 81ac     +LDD R26 , Y + 4
00121e 81bd     +LDD R27 , Y + 4 + 1
00121f 818e     +LDD R24 , Y + 4 + 2
001220 819f     +LDD R25 , Y + 4 + 3
                 	__GETD2S 4
001221 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2D:
001222 93ba      	ST   -Y,R27
001223 93aa      	ST   -Y,R26
001224 940e 1462 	CALL __SAVELOCR4
001226 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x2E:
001227 91a0 0921 	LDS  R26,_FatFs_G002
001229 91b0 0922 	LDS  R27,_FatFs_G002+1
00122b 9616      	ADIW R26,6
00122c 912d      	LD   R18,X+
00122d 913c      	LD   R19,X
00122e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2F:
                +
00122f 85a4     +LDD R26 , Z + 12
001230 85b5     +LDD R27 , Z + 12 + 1
001231 8586     +LDD R24 , Z + 12 + 2
001232 8597     +LDD R25 , Z + 12 + 3
                 	__GETD2Z 12
001233 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x30:
001234 2fe2      	MOV  R30,R18
001235 5f2f      	SUBI R18,-1
001236 81ae      	LDD  R26,Y+6
001237 81bf      	LDD  R27,Y+6+1
001238 e0f0      	LDI  R31,0
001239 0fae      	ADD  R26,R30
00123a 1fbf      	ADC  R27,R31
00123b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x31:
00123c 2fe5      	MOV  R30,R21
00123d 5f5f      	SUBI R21,-1
00123e 85a8      	LDD  R26,Y+8
00123f 85b9      	LDD  R27,Y+8+1
001240 e0f0      	LDI  R31,0
001241 0fea      	ADD  R30,R26
001242 1ffb      	ADC  R31,R27
001243 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x32:
001244 81ae      	LDD  R26,Y+6
001245 81bf      	LDD  R27,Y+6+1
001246 9612      	ADIW R26,2
001247 940e 13cf 	CALL __GETW1P
001249 85e3      	LDD  R30,Z+11
00124a 30e0      	CPI  R30,0
00124b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x33:
00124c 940e 13cf 	CALL __GETW1P
00124e 2766      	CLR  R22
00124f 2777      	CLR  R23
001250 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x34:
001251 81ec      	LDD  R30,Y+4
001252 81fd      	LDD  R31,Y+4+1
001253 93fa      	ST   -Y,R31
001254 93ea      	ST   -Y,R30
001255 dfa7      	RCALL SUBOPT_0x26
001256 940e 1404 	CALL __PUTPARD1
001258 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x35:
001259 81ac      	LDD  R26,Y+4
00125a 81bd      	LDD  R27,Y+4+1
00125b 940e 13cf 	CALL __GETW1P
00125d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x36:
00125e 01fe      	MOVW R30,R28
00125f 9671      	ADIW R30,17
001260 93fa      	ST   -Y,R31
001261 93ea      	ST   -Y,R30
001262 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x37:
                +
001263 85af     +LDD R26 , Y + 15
001264 89b8     +LDD R27 , Y + 15 + 1
001265 8989     +LDD R24 , Y + 15 + 2
001266 899a     +LDD R25 , Y + 15 + 3
                 	__GETD2S 15
001267 940e 08f7 	CALL _check_fs_G002
001269 2f1e      	MOV  R17,R30
00126a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x38:
                +
00126b 85ef     +LDD R30 , Y + 15
00126c 89f8     +LDD R31 , Y + 15 + 1
00126d 8969     +LDD R22 , Y + 15 + 2
00126e 897a     +LDD R23 , Y + 15 + 3
                 	__GETD1S 15
00126f 940e 1404 	CALL __PUTPARD1
001271 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x39:
                +
001272 87e9     +STD Y + 9 , R30
001273 87fa     +STD Y + 9 + 1 , R31
001274 876b     +STD Y + 9 + 2 , R22
001275 877c     +STD Y + 9 + 3 , R23
                 	__PUTD1S 9
001276 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3A:
                +
001277 85e9     +LDD R30 , Y + 9
001278 85fa     +LDD R31 , Y + 9 + 1
001279 856b     +LDD R22 , Y + 9 + 2
00127a 857c     +LDD R23 , Y + 9 + 3
                 	__GETD1S 9
00127b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3B:
                +
00127c 85a9     +LDD R26 , Y + 9
00127d 85ba     +LDD R27 , Y + 9 + 1
00127e 858b     +LDD R24 , Y + 9 + 2
00127f 859c     +LDD R25 , Y + 9 + 3
                 	__GETD2S 9
001280 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3C:
001281 01fe      	MOVW R30,R28
001282 967f      	ADIW R30,31
001283 973d      	SBIW R30,13
001284 01df      	MOVW R26,R30
001285 940e 13cf 	CALL __GETW1P
001287 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x3D:
001288 a9ed      	LDD  R30,Y+53
001289 a9fe      	LDD  R31,Y+53+1
00128a 81a4      	LDD  R26,Z+4
00128b 81b5      	LDD  R27,Z+5
00128c 01fd      	MOVW R30,R26
00128d 940e 1356 	CALL __LSRW4
00128f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3E:
001290 81e1      	LDD  R30,Z+1
001291 e0f0      	LDI  R31,0
001292 940e 136e 	CALL __CWD1
001294 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x3F:
001295 a9ed      	LDD  R30,Y+53
001296 a9fe      	LDD  R31,Y+53+1
001297 df97      	RCALL SUBOPT_0x2F
001298 dfde      	RCALL SUBOPT_0x3A
001299 940e 1324 	CALL __ADDD12
00129b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x40:
00129c 81ee      	LDD  R30,Y+6
00129d 81ff      	LDD  R31,Y+6+1
                +
00129e 8da0     +LDD R26 , Z + 24
00129f 8db1     +LDD R27 , Z + 24 + 1
0012a0 8d82     +LDD R24 , Z + 24 + 2
0012a1 8d93     +LDD R25 , Z + 24 + 3
                 	__GETD2Z 24
0012a2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x41:
                +
0012a3 e0e0     +LDI R30 , LOW ( 0x200 )
0012a4 e0f2     +LDI R31 , HIGH ( 0x200 )
0012a5 e060     +LDI R22 , BYTE3 ( 0x200 )
0012a6 e070     +LDI R23 , BYTE4 ( 0x200 )
                 	__GETD1N 0x200
0012a7 940e 13a6 	CALL __DIVD21U
0012a9 01df      	MOVW R26,R30
0012aa 01cb      	MOVW R24,R22
0012ab 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x42:
0012ac 81ee      	LDD  R30,Y+6
0012ad 81ff      	LDD  R31,Y+6+1
                +
0012ae a1a4     +LDD R26 , Z + 36
0012af a1b5     +LDD R27 , Z + 36 + 1
0012b0 a186     +LDD R24 , Z + 36 + 2
0012b1 a197     +LDD R25 , Z + 36 + 3
                 	__GETD2Z 36
0012b2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x43:
0012b3 9613      	ADIW R26,3
0012b4 91ec      	LD   R30,X
0012b5 5fef      	SUBI R30,-LOW(1)
0012b6 93ec      	ST   X,R30
0012b7 50e1      	SUBI R30,LOW(1)
0012b8 e0f0      	LDI  R31,0
0012b9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x44:
0012ba 8da0      	LDD  R26,Z+24
0012bb 8db1      	LDD  R27,Z+25
0012bc 01fd      	MOVW R30,R26
0012bd 70f1      	ANDI R31,HIGH(0x1FF)
0012be 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x45:
0012bf e0e0      	LDI  R30,LOW(0)
0012c0 e0f0      	LDI  R31,HIGH(0)
0012c1 93fa      	ST   -Y,R31
0012c2 93ea      	ST   -Y,R30
0012c3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x46:
                +
0012c4 e0a0     +LDI R26 , LOW ( 0x0 )
0012c5 e0b0     +LDI R27 , HIGH ( 0x0 )
0012c6 e080     +LDI R24 , BYTE3 ( 0x0 )
0012c7 e090     +LDI R25 , BYTE4 ( 0x0 )
                 	__GETD2N 0x0
0012c8 940e 0e1d 	CALL _disk_writep
0012ca 30e0      	CPI  R30,0
0012cb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x47:
0012cc 01fa      	MOVW R30,R20
                +
0012cd 8da0     +LDD R26 , Z + 24
0012ce 8db1     +LDD R27 , Z + 24 + 1
0012cf 8d82     +LDD R24 , Z + 24 + 2
0012d0 8d93     +LDD R25 , Z + 24 + 3
                 	__GETD2Z 24
0012d1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x48:
0012d2 93ea      	ST   -Y,R30
                +
0012d3 e0a0     +LDI R26 , LOW ( 0x0 )
0012d4 e0b0     +LDI R27 , HIGH ( 0x0 )
0012d5 e080     +LDI R24 , BYTE3 ( 0x0 )
0012d6 e090     +LDI R25 , BYTE4 ( 0x0 )
                 	__GETD2N 0x0
0012d7 940c 0cd5 	JMP  _send_cmd_G003
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x49:
0012d9 2fe1      	MOV  R30,R17
0012da e0f0      	LDI  R31,0
0012db 01de      	MOVW R26,R28
0012dc 9616      	ADIW R26,6
0012dd 0fea      	ADD  R30,R26
0012de 1ffb      	ADC  R31,R27
0012df 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4A:
                +
0012e0 e0a0     +LDI R26 , LOW ( 0x200 )
0012e1 e0b2     +LDI R27 , HIGH ( 0x200 )
0012e2 e080     +LDI R24 , BYTE3 ( 0x200 )
0012e3 e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
0012e4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x4B:
0012e5 940e 13d9 	CALL __GETD1P_INC
0012e7 def5      	RCALL SUBOPT_0x20
0012e8 940e 13e3 	CALL __PUTDP1_DEC
                +
0012ea 50e1     +SUBI R30 , LOW ( 1 )
0012eb 40f0     +SBCI R31 , HIGH ( 1 )
0012ec 4060     +SBCI R22 , BYTE3 ( 1 )
0012ed 4070     +SBCI R23 , BYTE4 ( 1 )
                 	__SUBD1N 1
0012ee 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x4C:
0012ef 932a      	ST   -Y,R18
0012f0 85af      	LDD  R26,Y+15
0012f1 89b8      	LDD  R27,Y+15+1
0012f2 89e9      	LDD  R30,Y+17
0012f3 89fa      	LDD  R31,Y+17+1
0012f4 9509      	ICALL
0012f5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x4D:
0012f6 89ea      	LDD  R30,Y+18
0012f7 89fb      	LDD  R31,Y+18+1
0012f8 9734      	SBIW R30,4
0012f9 8bea      	STD  Y+18,R30
0012fa 8bfb      	STD  Y+18+1,R31
0012fb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x4E:
0012fc 85af      	LDD  R26,Y+15
0012fd 89b8      	LDD  R27,Y+15+1
0012fe 89e9      	LDD  R30,Y+17
0012ff 89fa      	LDD  R31,Y+17+1
001300 9509      	ICALL
001301 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x4F:
001302 89aa      	LDD  R26,Y+18
001303 89bb      	LDD  R27,Y+18+1
001304 9614      	ADIW R26,4
001305 940e 13cf 	CALL __GETW1P
001307 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x50:
001308 940e 1072 	CALL __lcd_write_data
00130a e0a3      	LDI  R26,LOW(3)
00130b e0b0      	LDI  R27,0
00130c 940c 1316 	JMP  _delay_ms
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x51:
00130e e3a0      	LDI  R26,LOW(48)
00130f 940e 105e 	CALL __lcd_write_nibble_G103
                +
001311 ef8a     +LDI R24 , LOW ( 250 )
001312 e090     +LDI R25 , HIGH ( 250 )
                +__DELAY_USW_LOOP :
001313 9701     +SBIW R24 , 1
001314 f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 250
001315 9508      	RET
                 
                 
                 	.CSEG
                 _delay_ms:
001316 9610      	adiw r26,0
001317 f039      	breq __delay_ms1
                 __delay_ms0:
                +
001318 ec84     +LDI R24 , LOW ( 0x9C4 )
001319 e099     +LDI R25 , HIGH ( 0x9C4 )
                +__DELAY_USW_LOOP :
00131a 9701     +SBIW R24 , 1
00131b f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x9C4
00131c 95a8      	wdr
00131d 9711      	sbiw r26,1
00131e f7c9      	brne __delay_ms0
                 __delay_ms1:
00131f 9508      	ret
                 
                 __ADDW2R15:
001320 2400      	CLR  R0
001321 0daf      	ADD  R26,R15
001322 1db0      	ADC  R27,R0
001323 9508      	RET
                 
                 __ADDD12:
001324 0fea      	ADD  R30,R26
001325 1ffb      	ADC  R31,R27
001326 1f68      	ADC  R22,R24
001327 1f79      	ADC  R23,R25
001328 9508      	RET
                 
                 __ADDD21:
001329 0fae      	ADD  R26,R30
00132a 1fbf      	ADC  R27,R31
00132b 1f86      	ADC  R24,R22
00132c 1f97      	ADC  R25,R23
00132d 9508      	RET
                 
                 __SUBD12:
00132e 1bea      	SUB  R30,R26
00132f 0bfb      	SBC  R31,R27
001330 0b68      	SBC  R22,R24
001331 0b79      	SBC  R23,R25
001332 9508      	RET
                 
                 __SUBD21:
001333 1bae      	SUB  R26,R30
001334 0bbf      	SBC  R27,R31
001335 0b86      	SBC  R24,R22
001336 0b97      	SBC  R25,R23
001337 9508      	RET
                 
                 __ORD12:
001338 2bea      	OR   R30,R26
001339 2bfb      	OR   R31,R27
00133a 2b68      	OR   R22,R24
00133b 2b79      	OR   R23,R25
00133c 9508      	RET
                 
                 __ANEGW1:
00133d 95f1      	NEG  R31
00133e 95e1      	NEG  R30
00133f 40f0      	SBCI R31,0
001340 9508      	RET
                 
                 __LSRD12:
001341 23ee      	TST  R30
001342 2e0e      	MOV  R0,R30
001343 01fd      	MOVW R30,R26
001344 01bc      	MOVW R22,R24
001345 f031      	BREQ __LSRD12R
                 __LSRD12L:
001346 9576      	LSR  R23
001347 9567      	ROR  R22
001348 95f7      	ROR  R31
001349 95e7      	ROR  R30
00134a 940a      	DEC  R0
00134b f7d1      	BRNE __LSRD12L
                 __LSRD12R:
00134c 9508      	RET
                 
                 __LSLW4:
00134d 0fee      	LSL  R30
00134e 1fff      	ROL  R31
                 __LSLW3:
00134f 0fee      	LSL  R30
001350 1fff      	ROL  R31
                 __LSLW2:
001351 0fee      	LSL  R30
001352 1fff      	ROL  R31
001353 0fee      	LSL  R30
001354 1fff      	ROL  R31
001355 9508      	RET
                 
                 __LSRW4:
001356 95f6      	LSR  R31
001357 95e7      	ROR  R30
                 __LSRW3:
001358 95f6      	LSR  R31
001359 95e7      	ROR  R30
                 __LSRW2:
00135a 95f6      	LSR  R31
00135b 95e7      	ROR  R30
00135c 95f6      	LSR  R31
00135d 95e7      	ROR  R30
00135e 9508      	RET
                 
                 __LSLD1:
00135f 0fee      	LSL  R30
001360 1fff      	ROL  R31
001361 1f66      	ROL  R22
001362 1f77      	ROL  R23
001363 9508      	RET
                 
                 __LSRD16:
001364 2fe6      	MOV  R30,R22
001365 2ff7      	MOV  R31,R23
001366 e060      	LDI  R22,0
001367 e070      	LDI  R23,0
001368 9508      	RET
                 
                 __LSLD16:
001369 2f6e      	MOV  R22,R30
00136a 2f7f      	MOV  R23,R31
00136b e0e0      	LDI  R30,0
00136c e0f0      	LDI  R31,0
00136d 9508      	RET
                 
                 __CWD1:
00136e 2f6f      	MOV  R22,R31
00136f 0f66      	ADD  R22,R22
001370 0b66      	SBC  R22,R22
001371 2f76      	MOV  R23,R22
001372 9508      	RET
                 
                 __MULD12U:
001373 9f7a      	MUL  R23,R26
001374 2d70      	MOV  R23,R0
001375 9f6b      	MUL  R22,R27
001376 0d70      	ADD  R23,R0
001377 9ff8      	MUL  R31,R24
001378 0d70      	ADD  R23,R0
001379 9fe9      	MUL  R30,R25
00137a 0d70      	ADD  R23,R0
00137b 9f6a      	MUL  R22,R26
00137c 2d60      	MOV  R22,R0
00137d 0d71      	ADD  R23,R1
00137e 9ffb      	MUL  R31,R27
00137f 0d60      	ADD  R22,R0
001380 1d71      	ADC  R23,R1
001381 9fe8      	MUL  R30,R24
001382 0d60      	ADD  R22,R0
001383 1d71      	ADC  R23,R1
001384 2788      	CLR  R24
001385 9ffa      	MUL  R31,R26
001386 2df0      	MOV  R31,R0
001387 0d61      	ADD  R22,R1
001388 1f78      	ADC  R23,R24
001389 9feb      	MUL  R30,R27
00138a 0df0      	ADD  R31,R0
00138b 1d61      	ADC  R22,R1
00138c 1f78      	ADC  R23,R24
00138d 9fea      	MUL  R30,R26
00138e 2de0      	MOV  R30,R0
00138f 0df1      	ADD  R31,R1
001390 1f68      	ADC  R22,R24
001391 1f78      	ADC  R23,R24
001392 9508      	RET
                 
                 __DIVW21U:
001393 2400      	CLR  R0
001394 2411      	CLR  R1
001395 e190      	LDI  R25,16
                 __DIVW21U1:
001396 0faa      	LSL  R26
001397 1fbb      	ROL  R27
001398 1c00      	ROL  R0
001399 1c11      	ROL  R1
00139a 1a0e      	SUB  R0,R30
00139b 0a1f      	SBC  R1,R31
00139c f418      	BRCC __DIVW21U2
00139d 0e0e      	ADD  R0,R30
00139e 1e1f      	ADC  R1,R31
00139f c001      	RJMP __DIVW21U3
                 __DIVW21U2:
0013a0 60a1      	SBR  R26,1
                 __DIVW21U3:
0013a1 959a      	DEC  R25
0013a2 f799      	BRNE __DIVW21U1
0013a3 01fd      	MOVW R30,R26
0013a4 01d0      	MOVW R26,R0
0013a5 9508      	RET
                 
                 __DIVD21U:
0013a6 933f      	PUSH R19
0013a7 934f      	PUSH R20
0013a8 935f      	PUSH R21
0013a9 2400      	CLR  R0
0013aa 2411      	CLR  R1
0013ab 2744      	CLR  R20
0013ac 2755      	CLR  R21
0013ad e230      	LDI  R19,32
                 __DIVD21U1:
0013ae 0faa      	LSL  R26
0013af 1fbb      	ROL  R27
0013b0 1f88      	ROL  R24
0013b1 1f99      	ROL  R25
0013b2 1c00      	ROL  R0
0013b3 1c11      	ROL  R1
0013b4 1f44      	ROL  R20
0013b5 1f55      	ROL  R21
0013b6 1a0e      	SUB  R0,R30
0013b7 0a1f      	SBC  R1,R31
0013b8 0b46      	SBC  R20,R22
0013b9 0b57      	SBC  R21,R23
0013ba f428      	BRCC __DIVD21U2
0013bb 0e0e      	ADD  R0,R30
0013bc 1e1f      	ADC  R1,R31
0013bd 1f46      	ADC  R20,R22
0013be 1f57      	ADC  R21,R23
0013bf c001      	RJMP __DIVD21U3
                 __DIVD21U2:
0013c0 60a1      	SBR  R26,1
                 __DIVD21U3:
0013c1 953a      	DEC  R19
0013c2 f759      	BRNE __DIVD21U1
0013c3 01fd      	MOVW R30,R26
0013c4 01bc      	MOVW R22,R24
0013c5 01d0      	MOVW R26,R0
0013c6 01ca      	MOVW R24,R20
0013c7 915f      	POP  R21
0013c8 914f      	POP  R20
0013c9 913f      	POP  R19
0013ca 9508      	RET
                 
                 __MODD21U:
0013cb dfda      	RCALL __DIVD21U
0013cc 01fd      	MOVW R30,R26
0013cd 01bc      	MOVW R22,R24
0013ce 9508      	RET
                 
                 __GETW1P:
0013cf 91ed      	LD   R30,X+
0013d0 91fc      	LD   R31,X
0013d1 9711      	SBIW R26,1
0013d2 9508      	RET
                 
                 __GETD1P:
0013d3 91ed      	LD   R30,X+
0013d4 91fd      	LD   R31,X+
0013d5 916d      	LD   R22,X+
0013d6 917c      	LD   R23,X
0013d7 9713      	SBIW R26,3
0013d8 9508      	RET
                 
                 __GETD1P_INC:
0013d9 91ed      	LD   R30,X+
0013da 91fd      	LD   R31,X+
0013db 916d      	LD   R22,X+
0013dc 917d      	LD   R23,X+
0013dd 9508      	RET
                 
                 __PUTDP1:
0013de 93ed      	ST   X+,R30
0013df 93fd      	ST   X+,R31
0013e0 936d      	ST   X+,R22
0013e1 937c      	ST   X,R23
0013e2 9508      	RET
                 
                 __PUTDP1_DEC:
0013e3 937e      	ST   -X,R23
0013e4 936e      	ST   -X,R22
0013e5 93fe      	ST   -X,R31
0013e6 93ee      	ST   -X,R30
0013e7 9508      	RET
                 
                 __GETW1PF:
0013e8 bf6b      	OUT  RAMPZ,R22
0013e9 9007      	ELPM R0,Z+
0013ea 91f6      	ELPM R31,Z
0013eb 2de0      	MOV  R30,R0
0013ec 9508      	RET
                 
                 __GETD1PF:
0013ed bf6b      	OUT  RAMPZ,R22
0013ee 9007      	ELPM R0,Z+
0013ef 9017      	ELPM R1,Z+
0013f0 9167      	ELPM R22,Z+
0013f1 9176      	ELPM R23,Z
0013f2 01f0      	MOVW R30,R0
0013f3 9508      	RET
                 
                 __GETD2PF:
0013f4 bf6b      	OUT  RAMPZ,R22
0013f5 91a7      	ELPM R26,Z+
0013f6 91b7      	ELPM R27,Z+
0013f7 9187      	ELPM R24,Z+
0013f8 9196      	ELPM R25,Z
0013f9 9508      	RET
                 
                 __GETD1S0:
0013fa 81e8      	LD   R30,Y
0013fb 81f9      	LDD  R31,Y+1
0013fc 816a      	LDD  R22,Y+2
0013fd 817b      	LDD  R23,Y+3
0013fe 9508      	RET
                 
                 __GETD2S0:
0013ff 81a8      	LD   R26,Y
001400 81b9      	LDD  R27,Y+1
001401 818a      	LDD  R24,Y+2
001402 819b      	LDD  R25,Y+3
001403 9508      	RET
                 
                 __PUTPARD1:
001404 937a      	ST   -Y,R23
001405 936a      	ST   -Y,R22
001406 93fa      	ST   -Y,R31
001407 93ea      	ST   -Y,R30
001408 9508      	RET
                 
                 __PUTPARD2:
001409 939a      	ST   -Y,R25
00140a 938a      	ST   -Y,R24
00140b 93ba      	ST   -Y,R27
00140c 93aa      	ST   -Y,R26
00140d 9508      	RET
                 
                 __SWAPD12:
00140e 2e18      	MOV  R1,R24
00140f 2f86      	MOV  R24,R22
001410 2d61      	MOV  R22,R1
001411 2e19      	MOV  R1,R25
001412 2f97      	MOV  R25,R23
001413 2d71      	MOV  R23,R1
                 
                 __SWAPW12:
001414 2e1b      	MOV  R1,R27
001415 2fbf      	MOV  R27,R31
001416 2df1      	MOV  R31,R1
                 
                 __SWAPB12:
001417 2e1a      	MOV  R1,R26
001418 2fae      	MOV  R26,R30
001419 2de1      	MOV  R30,R1
00141a 9508      	RET
                 
                 __EEPROMRDB:
00141b 99e1      	SBIC EECR,EEWE
00141c cffe      	RJMP __EEPROMRDB
00141d 93ff      	PUSH R31
00141e b7ff      	IN   R31,SREG
00141f 94f8      	CLI
001420 bbae      	OUT  EEARL,R26
001421 bbbf      	OUT  EEARH,R27
001422 9ae0      	SBI  EECR,EERE
001423 b3ed      	IN   R30,EEDR
001424 bfff      	OUT  SREG,R31
001425 91ff      	POP  R31
001426 9508      	RET
                 
                 __EEPROMWRD:
001427 d007      	RCALL __EEPROMWRW
001428 9612      	ADIW R26,2
001429 010f      	MOVW R0,R30
00142a 01fb      	MOVW R30,R22
00142b d003      	RCALL __EEPROMWRW
00142c 01f0      	MOVW R30,R0
00142d 9712      	SBIW R26,2
00142e 9508      	RET
                 
                 __EEPROMWRW:
00142f d007      	RCALL __EEPROMWRB
001430 9611      	ADIW R26,1
001431 93ef      	PUSH R30
001432 2fef      	MOV  R30,R31
001433 d003      	RCALL __EEPROMWRB
001434 91ef      	POP  R30
001435 9711      	SBIW R26,1
001436 9508      	RET
                 
                 __EEPROMWRB:
001437 9be1      	SBIS EECR,EEWE
001438 c002      	RJMP __EEPROMWRB1
001439 95a8      	WDR
00143a cffc      	RJMP __EEPROMWRB
                 __EEPROMWRB1:
00143b b79f      	IN   R25,SREG
00143c 94f8      	CLI
00143d bbae      	OUT  EEARL,R26
00143e bbbf      	OUT  EEARH,R27
00143f 9ae0      	SBI  EECR,EERE
001440 b38d      	IN   R24,EEDR
001441 17e8      	CP   R30,R24
001442 f019      	BREQ __EEPROMWRB0
001443 bbed      	OUT  EEDR,R30
001444 9ae2      	SBI  EECR,EEMWE
001445 9ae1      	SBI  EECR,EEWE
                 __EEPROMWRB0:
001446 bf9f      	OUT  SREG,R25
001447 9508      	RET
                 
                 __CPD10:
001448 9730      	SBIW R30,0
001449 4060      	SBCI R22,0
00144a 4070      	SBCI R23,0
00144b 9508      	RET
                 
                 __CPW02:
00144c 2400      	CLR  R0
00144d 160a      	CP   R0,R26
00144e 060b      	CPC  R0,R27
00144f 9508      	RET
                 
                 __CPD02:
001450 2400      	CLR  R0
001451 160a      	CP   R0,R26
001452 060b      	CPC  R0,R27
001453 0608      	CPC  R0,R24
001454 0609      	CPC  R0,R25
001455 9508      	RET
                 
                 __CPD12:
001456 17ea      	CP   R30,R26
001457 07fb      	CPC  R31,R27
001458 0768      	CPC  R22,R24
001459 0779      	CPC  R23,R25
00145a 9508      	RET
                 
                 __CPD21:
00145b 17ae      	CP   R26,R30
00145c 07bf      	CPC  R27,R31
00145d 0786      	CPC  R24,R22
00145e 0797      	CPC  R25,R23
00145f 9508      	RET
                 
                 __SAVELOCR6:
001460 935a      	ST   -Y,R21
                 __SAVELOCR5:
001461 934a      	ST   -Y,R20
                 __SAVELOCR4:
001462 933a      	ST   -Y,R19
                 __SAVELOCR3:
001463 932a      	ST   -Y,R18
                 __SAVELOCR2:
001464 931a      	ST   -Y,R17
001465 930a      	ST   -Y,R16
001466 9508      	RET
                 
                 __LOADLOCR6:
001467 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
001468 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
001469 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
00146a 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
00146b 8119      	LDD  R17,Y+1
00146c 8108      	LD   R16,Y
00146d 9508      	RET
                 
                 __INITLOCW:
00146e 0fac      	ADD  R26,R28
00146f 1fbd      	ADC  R27,R29
001470 bf6b      	OUT  RAMPZ,R22
                 __INITLOC0:
001471 9007      	ELPM R0,Z+
001472 920d      	ST   X+,R0
001473 9701      	SBIW R24,1
001474 f7e1      	BRNE __INITLOC0
001475 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  93 r1 :  28 r2 :   0 r3 :   0 r4 :   1 r5 :   0 r6 :   1 r7 :   0 
r8 :   1 r9 :   0 r10:   0 r11:   0 r12:   4 r13:   4 r14:   0 r15:   4 
r16: 117 r17: 157 r18: 100 r19:  57 r20:  63 r21:  47 r22: 161 r23: 122 
r24: 131 r25:  93 r26: 544 r27: 262 r28:  90 r29:  11 r30: 949 r31: 363 
x  : 122 y  : 782 z  : 117 
Registers used: 27 out of 35 (77.1%)

ATmega128 instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  40 add   :  39 
adiw  : 129 and   :   2 andi  :  47 asr   :   0 bclr  :   0 bld   :   0 
brbc  :   0 brbs  :   0 brcc  :   2 brcs  :   0 break :   0 breq  :  84 
brge  :   2 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :  25 
brlt  :   0 brmi  :   0 brne  : 119 brpl  :   2 brsh  :  22 brtc  :   0 
brts  :   1 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 call  : 487 
cbi   :  17 cbr   :   0 clc   :   0 clh   :   0 cli   :   4 cln   :   0 
clr   :  69 cls   :   0 clt   :   1 clv   :   0 clz   :   0 com   :   2 
cp    :  19 cpc   :  46 cpi   : 127 cpse  :   0 dec   :   8 des   :   0 
elpm  :  26 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   5 
ijmp  :   0 in    :  18 inc   :   3 jmp   :  50 ld    :  95 ldd   : 545 
ldi   : 500 lds   :  21 lpm   :   0 lsl   :   9 lsr   :   6 mov   :  98 
movw  : 196 mul   :  11 muls  :   0 mulsu :   0 neg   :   2 nop   :   0 
or    :  16 ori   :  10 out   :  47 pop   :  55 push  :  55 rcall :  95 
ret   : 146 reti  :   1 rjmp  : 220 rol   :  18 ror   :   8 sbc   :  22 
sbci  :  64 sbi   :  16 sbic  :   3 sbis  :   4 sbiw  :  72 sbr   :   2 
sbrc  :   2 sbrs  :  11 sec   :   0 seh   :   0 sei   :   1 sen   :   0 
ser   :   0 ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    : 230 std   : 125 sts   :  11 sub   :  15 subi  :  72 
swap  :   1 tst   :   5 wdr   :   2 
Instructions used: 68 out of 117 (58.1%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0028ec   9556    920  10476  131072   8.0%
[.dseg] 0x000100 0x00092f      0     15     15    4096   0.4%
[.eseg] 0x000000 0x000111      0    263    263    4096   6.4%

Assembly complete, 0 errors, 13 warnings
