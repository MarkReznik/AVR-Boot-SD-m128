
AVRASM ver. 2.1.30  F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm Sun Sep 22 22:55:39 2024

F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1100): warning: Register r4 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1101): warning: Register r5 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1102): warning: Register r6 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1103): warning: Register r7 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1104): warning: Register r9 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1105): warning: Register r8 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1106): warning: Register r11 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1107): warning: Register r12 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1108): warning: Register r13 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Debug
                 ;Chip type              : ATmega128
                 ;Program type           : Boot Loader
                 ;Clock frequency        : 10.000000 MHz
                 ;Memory model           : Medium
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 2048 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_MEDIUM_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x10FF
                 	.EQU __DSTACK_SIZE=0x0800
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __GETBRPF
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETBRPF_INC
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z+
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test=R4
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test_msb=R5
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test=R6
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test_msb=R7
                 	.DEF _token=R9
                 	.DEF _SectorsPerCluster=R8
                 	.DEF _pagesCnt=R11
                 	.DEF _appPages=R12
                 	.DEF _appPages_msb=R13
                 
                 	.CSEG
                 	.ORG 0xF800
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
00f800 940c f868 	JMP  __RESET
00f802 940c f800 	JMP  0xF800
00f804 940c f800 	JMP  0xF800
00f806 940c f800 	JMP  0xF800
00f808 940c f800 	JMP  0xF800
00f80a 940c f800 	JMP  0xF800
00f80c 940c f800 	JMP  0xF800
00f80e 940c f800 	JMP  0xF800
00f810 940c f800 	JMP  0xF800
00f812 940c f800 	JMP  0xF800
00f814 940c f800 	JMP  0xF800
00f816 940c f800 	JMP  0xF800
00f818 940c f800 	JMP  0xF800
00f81a 940c f800 	JMP  0xF800
00f81c 940c f800 	JMP  0xF800
00f81e 940c f800 	JMP  0xF800
00f820 940c f800 	JMP  0xF800
00f822 940c f800 	JMP  0xF800
00f824 940c f800 	JMP  0xF800
00f826 940c f800 	JMP  0xF800
00f828 940c f800 	JMP  0xF800
00f82a 940c f800 	JMP  0xF800
00f82c 940c f800 	JMP  0xF800
00f82e 940c f800 	JMP  0xF800
00f830 940c f800 	JMP  0xF800
00f832 940c f800 	JMP  0xF800
00f834 940c f800 	JMP  0xF800
00f836 940c f800 	JMP  0xF800
00f838 940c f800 	JMP  0xF800
00f83a 940c f800 	JMP  0xF800
00f83c 940c f800 	JMP  0xF800
00f83e 940c f800 	JMP  0xF800
00f840 940c f800 	JMP  0xF800
00f842 940c f800 	JMP  0xF800
00f844 940c f800 	JMP  0xF800
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
                 __REG_VARS:
00f846 f9e0
00f847 f9b4      	.DB  0xE0,0xF9,0xB4,0xF9
                 
                 _0x40000:
00f848 2030
00f849 2020
00f84a 2020
00f84b 2020      	.DB  0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20
00f84c 2020
00f84d 0020
00f84e 5055
00f84f 4144      	.DB  0x20,0x20,0x20,0x0,0x55,0x50,0x44,0x41
00f850 4554
00f851 5b00
00f852 6573
00f853 7474      	.DB  0x54,0x45,0x0,0x5B,0x73,0x65,0x74,0x74
00f854 6e69
00f855 7367
00f856 005d      	.DB  0x69,0x6E,0x67,0x73,0x5D,0x0
                 
                 __GLOBAL_INI_TBL:
00f857 0004      	.DW  0x04
00f858 0004      	.DW  0x04
00f859 f08c 0001 	.DD  __REG_VARS*2
                 
00f85b 000c      	.DW  0x0C
00f85c 0900      	.DW  _0x4000E
00f85d f090 0001 	.DD  _0x40000*2
                 
00f85f 0007      	.DW  0x07
00f860 090c      	.DW  _0x4000E+12
00f861 f09c 0001 	.DD  _0x40000*2+12
                 
00f863 000b      	.DW  0x0B
00f864 0913      	.DW  _0x4000E+19
00f865 f0a3 0001 	.DD  _0x40000*2+19
                 
                 _0xFFFFFFFF:
00f867 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
00f868 94f8      	CLI
00f869 27ee      	CLR  R30
00f86a bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF THE BOOT LOADER
00f86b e0f1      	LDI  R31,1
00f86c bff5      	OUT  MCUCR,R31
00f86d e0f2      	LDI  R31,2
00f86e bff5      	OUT  MCUCR,R31
00f86f 93e0 006c 	STS  XMCRB,R30
                 
                 ;CLEAR R2-R14
00f871 e08d      	LDI  R24,(14-2)+1
00f872 e0a2      	LDI  R26,2
00f873 27bb      	CLR  R27
                 __CLEAR_REG:
00f874 93ed      	ST   X+,R30
00f875 958a      	DEC  R24
00f876 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
00f877 e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
00f878 e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
00f879 e0a0      	LDI  R26,LOW(__SRAM_START)
00f87a e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
00f87b 93ed      	ST   X+,R30
00f87c 9701      	SBIW R24,1
00f87d f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
00f87e eaee      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
00f87f eff0      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
00f880 e0d1      	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00f881 bfdb      	OUT  RAMPZ,R29
00f882 9187      	ELPM R24,Z+
00f883 9197      	ELPM R25,Z+
00f884 9700      	SBIW R24,0
00f885 f081      	BREQ __GLOBAL_INI_END
00f886 91a7      	ELPM R26,Z+
00f887 91b7      	ELPM R27,Z+
00f888 9007      	ELPM R0,Z+
00f889 9017      	ELPM R1,Z+
00f88a 91c7      	ELPM R28,Z+
00f88b 91d7      	ELPM R29,Z+
00f88c 01bf      	MOVW R22,R30
00f88d b7db      	IN   R29,RAMPZ
00f88e 01f0      	MOVW R30,R0
00f88f bfcb      	OUT  RAMPZ,R28
                 __GLOBAL_INI_LOOP:
00f890 9007      	ELPM R0,Z+
00f891 920d      	ST   X+,R0
00f892 9701      	SBIW R24,1
00f893 f7e1      	BRNE __GLOBAL_INI_LOOP
00f894 01fb      	MOVW R30,R22
00f895 cfeb      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
00f896 efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
00f897 bfed      	OUT  SPL,R30
00f898 e1e0      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
00f899 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00f89a e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00f89b e0d9      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00f89c 940c f9b6 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x900
                 
                 	.CSEG
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : All devices with bootloaders support.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains functions for easy reading and writing
                 ;*                       of Flash memory on parts having the "Self-programming"
                 ;*                       feature. The user functions are as follows:
                 ;*
                 ;*                       ReadFlashByte()
                 ;*                       ReadFlashPage()
                 ;*                       WriteFlashByte()
                 ;*                       WriteFlashPage()
                 ;*                       RecoverFlash()
                 ;*
                 ;*                       The remaining functions contained in this file are used
                 ;*                       by the functions listet above.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;//#include <inavr.h>
                 ;#include "Self_programming.h"
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include <delay.h>
                 ;
                 ;
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_W_Test)(void flash *addr)= (void(*)(void flash *)) 0x0F9E0;
                 ;void (*__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test)(void flash *addr, unsigned int data)= (void(*)(void flash *, unsigne ...
                 ;
                 ;
                 ;/*!
                 ;* Declare global struct variable in EEPROM if Flash recovery enabled.
                 ;* FlashBackup pageNumber holds Flash pageaddress (/PAGESIZE) the data in Flash
                 ;* recovery buffer should be written to if data need to be recovered.
                 ;* FlashBackup.status tells if data need to be recovered.
                 ;**/
                 ;#ifdef __FLASH_RECOVER
                 ;__eeprom struct {
                 ;  unsigned int  pageNumber;
                 ;  unsigned char status;
                 ;}FlashBackup = {0};
                 ;#endif
                 ;
                 ;void MY_FILL_TEMP_WORD(unsigned long addr,unsigned int data)
                 ; 0000 003A {
                 
                 	.CSEG
                 ; 0000 003B      _FILL_TEMP_WORD(addr,data);
                 ;	addr -> Y+2
                 ;	data -> Y+0
                 ; 0000 003C }
                 ;void MY_PAGE_ERASE(unsigned long addr)
                 ; 0000 003E {
                 ; 0000 003F      _PAGE_ERASE(addr);
                 ;	addr -> Y+0
                 ; 0000 0040 }
                 ;void MY_PAGE_WRITE(unsigned long addr)
                 ; 0000 0042 {
                 ; 0000 0043      _PAGE_WRITE(addr);
                 ;	addr -> Y+0
                 ; 0000 0044 }
                 ;/*!
                 ;* The function Returns one byte located on Flash address given by ucFlashStartAdr.
                 ;**/
                 ;unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0000 0048 unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0000 0049 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 004A   return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
                 ;	flashStartAdr -> Y+0
                 ; 0000 004B //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 004C } // Returns data from Flash
                 ;
                 ;/*!
                 ;* The function reads one Flash page from address flashStartAdr and stores data
                 ;* in array dataPage[]. The number of bytes stored is depending upon the
                 ;* Flash page size. The function returns FALSE if input address is not a Flash
                 ;* page address, else TRUE.
                 ;**/
                 ;unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 0054 unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 0055   unsigned int index;
                 ; 0000 0056   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
                 ; 0000 0057     for(index = 0; index < PAGESIZE; index++){
                 ; 0000 0058       dataPage[index] = ReadFlashByte(flashStartAdr + index);
                 ; 0000 0059     }
                 ; 0000 005A     return TRUE;                            // Return TRUE if valid page address
                 ; 0000 005B   }
                 ; 0000 005C   else{
                 ; 0000 005D     return FALSE;                           // Return FALSE if not valid page address
                 ; 0000 005E   }
                 ; 0000 005F }
                 ;
                 ;/*!
                 ;* The function writes byte data to Flash address flashAddr. Returns FALSE if
                 ;* input address is not valid Flash byte address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0065 unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0066   MyAddressType  pageAdr;
                 ; 0000 0067   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 0068   if( AddressCheck( flashAddr & ~(PAGESIZE-1) )){
                 ;	flashAddr -> Y+7
                 ;	data -> Y+6
                 ;	pageAdr -> Y+2
                 ;	eepromInterruptSettings -> R17
                 ;	sregSettings -> R16
                 ; 0000 0069 
                 ; 0000 006A     eepromInterruptSettings= EECR & (1<<EERIE); // Stores EEPROM interrupt mask
                 ; 0000 006B     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
                 ; 0000 006C     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 ; 0000 006D 
                 ; 0000 006E     sregSettings= SREG;
                 ; 0000 006F     #asm("cli");
                 ; 0000 0070     pageAdr=flashAddr & ~(PAGESIZE-1);      // Gets Flash page address from byte address
                 ; 0000 0071 
                 ; 0000 0072     #ifdef __FLASH_RECOVER
                 ; 0000 0073     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 0074                                             // not contain data for writing
                 ; 0000 0075     while(EECR & (1<<EEWE));
                 ; 0000 0076     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0077     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 0078     FlashBackup.pageNumber = (unsigned int) (pageAdr/PAGESIZE); // Stores page address
                 ; 0000 0079                                                        // data should be written to
                 ; 0000 007A     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 007B                                                // contains unwritten data
                 ; 0000 007C     while(EECR & (1<<EEWE));
                 ; 0000 007D     #endif
                 ; 0000 007E 
                 ; 0000 007F     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0080 
                 ; 0000 0081 
                 ; 0000 0082     WriteBufToFlash(pageAdr);               // Writes to Flash
                 ; 0000 0083 
                 ; 0000 0084     #ifdef __FLASH_RECOVER
                 ; 0000 0085     FlashBackup.status = 0;                 // Indicates that Flash recovery buffer
                 ; 0000 0086                                             // does not contain unwritten data
                 ; 0000 0087     while(EECR & (1<<EEWE));
                 ; 0000 0088     #endif
                 ; 0000 0089 
                 ; 0000 008A     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 ; 0000 008B     SREG = sregSettings;
                 ; 0000 008C     return TRUE;                            // Return TRUE if address
                 ; 0000 008D                                             // valid for writing
                 ; 0000 008E   }
                 ; 0000 008F   else
                 ; 0000 0090     return FALSE;                           // Return FALSE if address not
                 ; 0000 0091                                             // valid for writing
                 ; 0000 0092 }
                 ;
                 ;/*!
                 ;* The function writes data from array dataPage[] to Flash page address
                 ;* flashStartAdr. The Number of bytes written is depending upon the Flash page
                 ;* size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
                 ;* page address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage)
                 ; 0000 009B {
                 _WriteFlashPage:
                 ; .FSTART _WriteFlashPage
                 ; 0000 009C   unsigned int index;
                 ; 0000 009D   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 009E   if( AddressCheck(flashStartAdr) ){
00f89e 93ba      	ST   -Y,R27
00f89f 93aa      	ST   -Y,R26
00f8a0 940e ffe1 	CALL __SAVELOCR4
                 ;	flashStartAdr -> Y+6
                 ;	*dataPage -> Y+4
                 ;	index -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	sregSettings -> R18
                +
00f8a2 81ae     +LDD R26 , Y + 6
00f8a3 81bf     +LDD R27 , Y + 6 + 1
00f8a4 8588     +LDD R24 , Y + 6 + 2
00f8a5 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
00f8a6 d055      	RCALL _AddressCheck
00f8a7 30e0      	CPI  R30,0
00f8a8 f409      	BRNE PC+2
00f8a9 c04d      	RJMP _0xD
                 ; 0000 009F     eepromInterruptSettings = EECR & (1<<EERIE); // Stoes EEPROM interrupt mask
00f8aa b3ec      	IN   R30,0x1C
00f8ab 70e8      	ANDI R30,LOW(0x8)
00f8ac 2f3e      	MOV  R19,R30
                 ; 0000 00A0     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
00f8ad 98e3      	CBI  0x1C,3
                 ; 0000 00A1     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 _0xE:
00f8ae 99e1      	SBIC 0x1C,1
00f8af cffe      	RJMP _0xE
                 ; 0000 00A2 
                 ; 0000 00A3     sregSettings= SREG;
00f8b0 b72f      	IN   R18,63
                 ; 0000 00A4     #asm("cli");
00f8b1 94f8      	cli
                 ; 0000 00A5 
                 ; 0000 00A6     #ifdef __FLASH_RECOVER
                 ; 0000 00A7     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00A8                                             // not contain data for writing
                 ; 0000 00A9     while(EECR & (1<<EEWE));
                 ; 0000 00AA 
                 ; 0000 00AB     //_ENABLE_RWW_SECTION();
                 ; 0000 00AC 
                 ; 0000 00AD     _WAIT_FOR_SPM();
                 ; 0000 00AE     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00AF 
                 ; 0000 00B0     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                 ; 0000 00B1       //_WAIT_FOR_SPM();
                 ; 0000 00B2       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B3       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B4     }
                 ; 0000 00B5 
                 ; 0000 00B6     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 00B7     FlashBackup.pageNumber=(unsigned int)(flashStartAdr/PAGESIZE);
                 ; 0000 00B8     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 00B9                                            // contains unwritten data
                 ; 0000 00BA     while(EECR & (1<<EEWE));
                 ; 0000 00BB     #endif
                 ; 0000 00BC 
                 ; 0000 00BD     if(index==0xFFF1)
00f8b2 efe1      	LDI  R30,LOW(65521)
00f8b3 efff      	LDI  R31,HIGH(65521)
00f8b4 17e0      	CP   R30,R16
00f8b5 07f1      	CPC  R31,R17
00f8b6 f491      	BRNE _0x11
                 ; 0000 00BE     {
                 ; 0000 00BF         __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
00f8b7 940e fdd5 	CALL SUBOPT_0x0
00f8b9 e0a0      	LDI  R26,LOW(0)
00f8ba e0b0      	LDI  R27,0
00f8bb 940e f97c 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00C0         __AddrToZ24ByteToSPMCR_SPM_W((void flash *)0x1EF00);
00f8bd 940e fddc 	CALL SUBOPT_0x1
00f8bf 940e f98c 	CALL ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0000 00C1         __AddrToZ24ByteToSPMCR_SPM_E((void flash *)0x1EF00);
00f8c1 940e fddc 	CALL SUBOPT_0x1
00f8c3 940e f99a 	CALL ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0000 00C2         __AddrToZ24ByteToSPMCR_SPM_EW((void flash *)0x1EF00);
00f8c5 940e fddc 	CALL SUBOPT_0x1
00f8c7 940e f9a8 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 00C3     }
                 ; 0000 00C4     _WAIT_FOR_SPM();
                 _0x11:
                 _0x12:
00f8c9 91e0 0068 	LDS  R30,104
00f8cb 70e1      	ANDI R30,LOW(0x1)
00f8cc f7e1      	BRNE _0x12
                 ; 0000 00C5     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00C6     //_ENABLE_RWW_SECTION();
                 ; 0000 00C7 
                 ; 0000 00C8     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                +
00f8cd e000     +LDI R16 , LOW ( 0 )
00f8ce e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x16:
                +
00f8cf 3000     +CPI R16 , LOW ( 256 )
00f8d0 e0e1     +LDI R30 , HIGH ( 256 )
00f8d1 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
00f8d2 f4c8      	BRSH _0x17
                 ; 0000 00C9       //_WAIT_FOR_SPM();
                 ; 0000 00CA       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00CB       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
00f8d3 01f8      	MOVW R30,R16
00f8d4 2766      	CLR  R22
00f8d5 2777      	CLR  R23
00f8d6 940e ffcc 	CALL __PUTPARD1
00f8d8 01f8      	MOVW R30,R16
00f8d9 940e fde1 	CALL SUBOPT_0x2
00f8db 900c      	LD   R0,X
00f8dc 2411      	CLR  R1
00f8dd 01f8      	MOVW R30,R16
00f8de 9631      	ADIW R30,1
00f8df 940e fde1 	CALL SUBOPT_0x2
00f8e1 91ec      	LD   R30,X
00f8e2 2ffe      	MOV  R31,R30
00f8e3 e0e0      	LDI  R30,0
00f8e4 01d0      	MOVW R26,R0
00f8e5 0fae      	ADD  R26,R30
00f8e6 1fbf      	ADC  R27,R31
00f8e7 940e f97c 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00CC     }
                +
00f8e9 5f0e     +SUBI R16 , LOW ( - 2 )
00f8ea 4f1f     +SBCI R17 , HIGH ( - 2 )
                 	__ADDWRN 16,17,2
00f8eb cfe3      	RJMP _0x16
                 _0x17:
                 ; 0000 00CD     //_PAGE_WRITE( flashStartAdr );
                 ; 0000 00CE     WriteBufToFlash(flashStartAdr);         // Writes to Flash
                +
00f8ec 81ae     +LDD R26 , Y + 6
00f8ed 81bf     +LDD R27 , Y + 6 + 1
00f8ee 8588     +LDD R24 , Y + 6 + 2
00f8ef 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
00f8f0 d025      	RCALL _WriteBufToFlash
                 ; 0000 00CF     #ifdef __FLASH_RECOVER
                 ; 0000 00D0       FlashBackup.status=0;                 // Inicate that Flash buffer does
                 ; 0000 00D1                                             // not contain data for writing
                 ; 0000 00D2       while(EECR & (1<<EEWE));
                 ; 0000 00D3     #endif
                 ; 0000 00D4 
                 ; 0000 00D5     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
00f8f1 b3ec      	IN   R30,0x1C
00f8f2 2be3      	OR   R30,R19
00f8f3 bbec      	OUT  0x1C,R30
                 ; 0000 00D6     SREG = sregSettings;
00f8f4 bf2f      	OUT  0x3F,R18
                 ; 0000 00D7     return TRUE;                            // Return TRUE if address
00f8f5 e0e1      	LDI  R30,LOW(1)
00f8f6 c001      	RJMP _0x200000B
                 ; 0000 00D8                                             // valid for writing
                 ; 0000 00D9   }
                 ; 0000 00DA   else
                 _0xD:
                 ; 0000 00DB     return FALSE;                           // Return FALSE if not address not
00f8f7 e0e0      	LDI  R30,LOW(0)
                 ; 0000 00DC                                             // valid for writing
                 ; 0000 00DD }
                 _0x200000B:
00f8f8 940e ffe8 	CALL __LOADLOCR4
00f8fa 962a      	ADIW R28,10
00f8fb 9508      	RET
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function checks if global variable FlashBackup.status indicates that Flash recovery
                 ;* buffer contains data that needs to be written to Flash. Writes data from
                 ;* Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
                 ;* This function should be called at program startup if FLASH recovery option
                 ;* is enabeled.
                 ;**/
                 ;unsigned char RecoverFlash(){
                 ; 0000 00E6 unsigned char RecoverFlash(){
                 ; 0000 00E7 #ifdef __FLASH_RECOVER
                 ; 0000 00E8   unsigned int index;
                 ; 0000 00E9   unsigned long flashStartAdr = (MyAddressType)FlashBackup.pageNumber * PAGESIZE;
                 ; 0000 00EA   if(FlashBackup.status == FLASH_BUFFER_FULL_ID){ // Checks if Flash recovery
                 ; 0000 00EB                                                   //  buffer contains data
                 ; 0000 00EC 
                 ; 0000 00ED     for(index=0; index < PAGESIZE; index+=2){     // Writes to Flash write buffer
                 ; 0000 00EE         _WAIT_FOR_SPM();
                 ; 0000 00EF         MY_FILL_TEMP_WORD( index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER+index)) );
                 ; 0000 00F0     }
                 ; 0000 00F1 
                 ; 0000 00F2 
                 ; 0000 00F3     //WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
                 ; 0000 00F4     _WAIT_FOR_SPM();
                 ; 0000 00F5     MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 00F6     _WAIT_FOR_SPM();
                 ; 0000 00F7     MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 00F8     _WAIT_FOR_SPM();
                 ; 0000 00F9     _ENABLE_RWW_SECTION();
                 ; 0000 00FA     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00FB                                             // not contain data for writing
                 ; 0000 00FC     while(EECR & (1<<EEWE));
                 ; 0000 00FD     return TRUE;                            // Returns TRUE if recovery has
                 ; 0000 00FE                                             // taken place
                 ; 0000 00FF   }
                 ; 0000 0100 #endif
                 ; 0000 0101   return FALSE;
                 ; 0000 0102 }
                 ;
                 ;
                 ;/*!
                 ;* The function checks if input argument is a valid Flash page address for
                 ;* writing. Returns TRUE only if:
                 ;* - Address points to the beginning of a Flash page
                 ;* - Address is within the limits defined in Self_programming.h
                 ;* - Address is not equal to page address used for buffring by the Flash recovery
                 ;*   functions (if enabled).
                 ;* Returns FALSE else.
                 ;**/
                 ;unsigned char AddressCheck(MyAddressType flashAdr){
                 ; 0000 010E unsigned char AddressCheck(MyAddressType flashAdr){
                 _AddressCheck:
                 ; .FSTART _AddressCheck
                 ; 0000 010F   #ifdef __FLASH_RECOVER
                 ; 0000 0110   // The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
                 ; 0000 0111   if( (flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
                 ; 0000 0112       (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE-1)) )
                 ; 0000 0113     return TRUE;                            // Address is a valid page address
                 ; 0000 0114   else
                 ; 0000 0115     return FALSE;                           // Address is not a valid page address
                 ; 0000 0116   #else
                 ; 0000 0117   if((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE-1) ) )
00f8fc 940e fde6 	CALL SUBOPT_0x3
                 ;	flashAdr -> Y+0
00f8fe 940e ffd6 	CALL __CPD20
00f900 f070      	BRLO _0x1A
00f901 940e fdeb 	CALL SUBOPT_0x4
                +
00f903 30a0     +CPI R26 , LOW ( 0x1F000 )
00f904 efe0     +LDI R30 , HIGH ( 0x1F000 )
00f905 07be     +CPC R27 , R30
00f906 e0e1     +LDI R30 , BYTE3 ( 0x1F000 )
00f907 078e     +CPC R24 , R30
00f908 e0e0     +LDI R30 , BYTE4 ( 0x1F000 )
00f909 079e     +CPC R25 , R30
                 	__CPD2N 0x1F000
00f90a f420      	BRSH _0x1A
00f90b 940e ffbd 	CALL __GETD1S0
00f90d 30e0      	CPI  R30,0
00f90e f009      	BREQ _0x1B
                 _0x1A:
00f90f c003      	RJMP _0x19
                 _0x1B:
                 ; 0000 0118     return TRUE;                            // Address is a valid page address
00f910 e0e1      	LDI  R30,LOW(1)
00f911 940c fcbc 	JMP  _0x200000A
                 ; 0000 0119   else
                 _0x19:
                 ; 0000 011A   {
                 ; 0000 011B     /*
                 ; 0000 011C     while(1)
                 ; 0000 011D     {
                 ; 0000 011E       PORTC.5=0;
                 ; 0000 011F       delay_ms(500);
                 ; 0000 0120       PORTC.5=1;
                 ; 0000 0121       delay_ms(500);
                 ; 0000 0122     }
                 ; 0000 0123     */
                 ; 0000 0124     return FALSE;                           // Address is not a valid page address
00f913 e0e0      	LDI  R30,LOW(0)
00f914 940c fcbc 	JMP  _0x200000A
                 ; 0000 0125   }
                 ; 0000 0126   #endif
                 ; 0000 0127 }
                 ; .FEND
                 ;
                 ;
                 ;/*!
                 ;* The function writes Flash temporary buffer to Flash page address given by
                 ;* input argument.
                 ;**/
                 ;
                 ;void WriteBufToFlash(MyAddressType flashStartAdr) {
                 ; 0000 012F void WriteBufToFlash(MyAddressType flashStartAdr) {
                 _WriteBufToFlash:
                 ; .FSTART _WriteBufToFlash
                 ; 0000 0130     //_WAIT_FOR_SPM();
                 ; 0000 0131     //MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 0132     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 0133     //_WAIT_FOR_SPM();
                 ; 0000 0134     //_ENABLE_RWW_SECTION();
                 ; 0000 0135     //MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 0136     _PAGE_WRITE( flashStartAdr );
00f916 940e fde6 	CALL SUBOPT_0x3
                 ;	flashStartAdr -> Y+0
00f918 940e f9a8 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 0137     //_WAIT_FOR_SPM();
                 ; 0000 0138     //_ENABLE_RWW_SECTION();
                 ; 0000 0139 /*
                 ; 0000 013A #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 013B   #ifdef __HAS_RAMPZ__
                 ; 0000 013C   RAMPZ = (unsigned char)(flashStartAdr >> 16);
                 ; 0000 013D   #endif
                 ; 0000 013E   _PAGE_ERASE(flashStartAdr);
                 ; 0000 013F   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0140   _PAGE_WRITE(flashStartAdr);
                 ; 0000 0141   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0142   #ifdef RWWSRE
                 ; 0000 0143   __DataToR0ByteToSPMCR_SPM( 0, (unsigned char)(1<<RWWSRE)|(1<<SPMEN)); // Enable RWW
                 ; 0000 0144   #endif
                 ; 0000 0145 #pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0146 */
                 ; 0000 0147 }
00f91a 940c fcbc 	JMP  _0x200000A
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads Flash page given by flashAddr, replaces one byte given by
                 ;* flashAddr with data, and stores entire page in Flash temporary buffer.
                 ;**/
                 ;void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014D void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014E //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 014F     unsigned int index, oddByte, pcWord;
                 ; 0000 0150 
                 ; 0000 0151     MyAddressType  pageAdr;
                 ; 0000 0152     oddByte=(unsigned char)flashAddr & 1;
                 ;	flashAddr -> Y+11
                 ;	data -> Y+10
                 ;	index -> R16,R17
                 ;	oddByte -> R18,R19
                 ;	pcWord -> R20,R21
                 ;	pageAdr -> Y+6
                 ; 0000 0153     pcWord=(unsigned int)flashAddr & (PAGESIZE-2); // Used when writing FLASH temp buffer
                 ; 0000 0154     pageAdr=flashAddr & ~(PAGESIZE-1);        // Get FLASH page address from byte address
                 ; 0000 0155     //while( SPMCR_REG & (1<<SPMEN) );
                 ; 0000 0156     //_ENABLE_RWW_SECTION();
                 ; 0000 0157 
                 ; 0000 0158     for(index=0; index < PAGESIZE; index+=2){
                 ; 0000 0159         if(index==pcWord){
                 ; 0000 015A           if(oddByte){
                 ; 0000 015B             //MY_FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015C             _FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015D           }                                     // Write odd byte in temporary buffer
                 ; 0000 015E           else{
                 ; 0000 015F             //MY_FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0160             _FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0161           }                                     // Write even byte in temporary buffer
                 ; 0000 0162         }
                 ; 0000 0163         else{
                 ; 0000 0164           //MY_FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0165           _FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0166         }                                       // Write Flash word directly to temporary buffer
                 ; 0000 0167     }
                 ; 0000 0168 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0169 }
                 ;/*****************************************************************************
                 ;*
                 ;* (C) 2010, HP InfoTech srl, www.hpinfotech.com
                 ;*
                 ;* File              : flash.c
                 ;* Compiler          : CodeVisionAVR V2.xx
                 ;* Revision          : $Revision: 1.0 $
                 ;* Date              : $Date: December 9, 2010 $
                 ;* Updated by        : $Author: HP InfoTech $
                 ;*
                 ;* Target platform   : All AVRs with bootloader support
                 ;*
                 ;* AppNote           : AVR109 - Self-programming
                 ;*
                 ;* Description       : Flash operations for AVR109 Self-programming
                 ;****************************************************************************/
                 ;
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;
                 ;//#define	SPMCR_REG	SPMCSR
                 ;
                 ;void dospmew(void)
                 ; 0001 0018 {
                 
                 	.CSEG
                 _dospmew:
                 ; .FSTART _dospmew
                 ; 0001 0019     #asm
                 ; 0001 001A          ldi   r22,$03
00f91c e063               ldi   r22,$03
                 ; 0001 001B          WR_SPMCR_REG_R22
00f91d 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 001C          spm
00f91f 95e8               spm
                 ; 0001 001D     #endasm
                 ; 0001 001E     _WAIT_FOR_SPM();
                 _0x20003:
00f920 91e0 0068 	LDS  R30,104
00f922 70e1      	ANDI R30,LOW(0x1)
00f923 f7e1      	BRNE _0x20003
                 ; 0001 001F     #asm
                 ; 0001 0020         ldi   r22,$05
00f924 e065              ldi   r22,$05
                 ; 0001 0021         WR_SPMCR_REG_R22
00f925 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0022         spm
00f927 95e8              spm
                 ; 0001 0023     #endasm
                 ; 0001 0024     _WAIT_FOR_SPM();
                 _0x20006:
00f928 91e0 0068 	LDS  R30,104
00f92a 70e1      	ANDI R30,LOW(0x1)
00f92b f7e1      	BRNE _0x20006
                 ; 0001 0025     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20009:
00f92c 91e0 0068 	LDS  R30,104
00f92e 74e0      	ANDI R30,LOW(0x40)
00f92f f049      	BREQ _0x2000B
                 ; 0001 0026     {
                 ; 0001 0027     #asm
                 ; 0001 0028         ldi   r22,$11
00f930 e161              ldi   r22,$11
                 ; 0001 0029         WR_SPMCR_REG_R22
00f931 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 002A         spm
00f933 95e8              spm
                 ; 0001 002B     #endasm
                 ; 0001 002C         _WAIT_FOR_SPM();
                 _0x2000C:
00f934 91e0 0068 	LDS  R30,104
00f936 70e1      	ANDI R30,LOW(0x1)
00f937 f7e1      	BRNE _0x2000C
                 ; 0001 002D     }
00f938 cff3      	RJMP _0x20009
                 _0x2000B:
                 ; 0001 002E }
00f939 9508      	RET
                 ; .FEND
                 ;
                 ;void dospmw(void)
                 ; 0001 0031 {
                 _dospmw:
                 ; .FSTART _dospmw
                 ; 0001 0032     #asm
                 ; 0001 0033         ldi   r22,$05
00f93a e065              ldi   r22,$05
                 ; 0001 0034         WR_SPMCR_REG_R22
00f93b 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0035         spm
00f93d 95e8              spm
                 ; 0001 0036     #endasm
                 ; 0001 0037     _WAIT_FOR_SPM();
                 _0x2000F:
00f93e 91e0 0068 	LDS  R30,104
00f940 70e1      	ANDI R30,LOW(0x1)
00f941 f7e1      	BRNE _0x2000F
                 ; 0001 0038     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20012:
00f942 91e0 0068 	LDS  R30,104
00f944 74e0      	ANDI R30,LOW(0x40)
00f945 f049      	BREQ _0x20014
                 ; 0001 0039     {
                 ; 0001 003A     #asm
                 ; 0001 003B         ldi   r22,$11
00f946 e161              ldi   r22,$11
                 ; 0001 003C         WR_SPMCR_REG_R22
00f947 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 003D         spm
00f949 95e8              spm
                 ; 0001 003E     #endasm
                 ; 0001 003F         _WAIT_FOR_SPM();
                 _0x20015:
00f94a 91e0 0068 	LDS  R30,104
00f94c 70e1      	ANDI R30,LOW(0x1)
00f94d f7e1      	BRNE _0x20015
                 ; 0001 0040     }
00f94e cff3      	RJMP _0x20012
                 _0x20014:
                 ; 0001 0041 }
00f94f 9508      	RET
                 ; .FEND
                 ;
                 ;void dospme(void)
                 ; 0001 0044 {
                 _dospme:
                 ; .FSTART _dospme
                 ; 0001 0045     #asm
                 ; 0001 0046         ldi   r22,$03
00f950 e063              ldi   r22,$03
                 ; 0001 0047         WR_SPMCR_REG_R22
00f951 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0048         spm
00f953 95e8              spm
                 ; 0001 0049     #endasm
                 ; 0001 004A     _WAIT_FOR_SPM();
                 _0x20018:
00f954 91e0 0068 	LDS  R30,104
00f956 70e1      	ANDI R30,LOW(0x1)
00f957 f7e1      	BRNE _0x20018
                 ; 0001 004B     while( SPMCR_REG & (1<<RWWSB) )
                 _0x2001B:
00f958 91e0 0068 	LDS  R30,104
00f95a 74e0      	ANDI R30,LOW(0x40)
00f95b f049      	BREQ _0x2001D
                 ; 0001 004C     {
                 ; 0001 004D     #asm
                 ; 0001 004E         ldi   r22,$11
00f95c e161              ldi   r22,$11
                 ; 0001 004F         WR_SPMCR_REG_R22
00f95d 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0050         spm
00f95f 95e8              spm
                 ; 0001 0051     #endasm
                 ; 0001 0052         _WAIT_FOR_SPM();
                 _0x2001E:
00f960 91e0 0068 	LDS  R30,104
00f962 70e1      	ANDI R30,LOW(0x1)
00f963 f7e1      	BRNE _0x2001E
                 ; 0001 0053     }
00f964 cff3      	RJMP _0x2001B
                 _0x2001D:
                 ; 0001 0054 }
00f965 9508      	RET
                 ; .FEND
                 ;
                 ;void dospm(void)
                 ; 0001 0057 {
                 _dospm:
                 ; .FSTART _dospm
                 ; 0001 0058     #asm
                 ; 0001 0059          ldi   r22,$01
00f966 e061               ldi   r22,$01
                 ; 0001 005A          WR_SPMCR_REG_R22
00f967 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 005B          spm
00f969 95e8               spm
                 ; 0001 005C     #endasm
                 ; 0001 005D     _WAIT_FOR_SPM();
                 _0x20021:
00f96a 91e0 0068 	LDS  R30,104
00f96c 70e1      	ANDI R30,LOW(0x1)
00f96d f7e1      	BRNE _0x20021
                 ; 0001 005E     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20024:
00f96e 91e0 0068 	LDS  R30,104
00f970 74e0      	ANDI R30,LOW(0x40)
00f971 f049      	BREQ _0x20026
                 ; 0001 005F     {
                 ; 0001 0060     #asm
                 ; 0001 0061         ldi   r22,$11
00f972 e161              ldi   r22,$11
                 ; 0001 0062         WR_SPMCR_REG_R22
00f973 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0063         spm
00f975 95e8              spm
                 ; 0001 0064     #endasm
                 ; 0001 0065         _WAIT_FOR_SPM();
                 _0x20027:
00f976 91e0 0068 	LDS  R30,104
00f978 70e1      	ANDI R30,LOW(0x1)
00f979 f7e1      	BRNE _0x20027
                 ; 0001 0066     }
00f97a cff3      	RJMP _0x20024
                 _0x20026:
                 ; 0001 0067 }
00f97b 9508      	RET
                 ; .FEND
                 ;
                 ;#pragma warn-
                 ;
                 ;unsigned char __AddrToZByteToSPMCR_LPM(void flash *addr, unsigned char ctrl)
                 ; 0001 006C {
                 ; 0001 006D #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 006E      ldd  r30,y+1
                 ; 0001 006F      ldd  r31,y+2
                 ; 0001 0070      ld   r22,y
                 ; 0001 0071      WR_SPMCR_REG_R22
                 ; 0001 0072      lpm
                 ; 0001 0073      mov  r30,r0
                 ; 0001 0074 #endasm
                 ; 0001 0075 }
                 ;
                 ;void __DataToR0ByteToSPMCR_SPM(unsigned char data, unsigned char ctrl)
                 ; 0001 0078 {
                 ; 0001 0079 #asm
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 007A      ldd  r0,y+1
                 ; 0001 007B      ld   r22,y
                 ; 0001 007C      WR_SPMCR_REG_R22
                 ; 0001 007D      spm
                 ; 0001 007E #endasm
                 ; 0001 007F }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 0082 {
                 ; 0001 0083     #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 0084          ldd  r30,y+3
                 ; 0001 0085          ldd  r31,y+4
                 ; 0001 0086          ldd  r0,y+1
                 ; 0001 0087          ldd  r1,y+2
                 ; 0001 0088          ld   r22,y
                 ; 0001 0089          WR_SPMCR_REG_R22
                 ; 0001 008A          spm
                 ; 0001 008B     #endasm
                 ; 0001 008C }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 008F {
                 ; 0001 0090 _WAIT_FOR_SPM();
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 ; 0001 0091     #asm
                 ; 0001 0092          ldd  r30,y+2
                 ; 0001 0093          ldd  r31,y+3
                 ; 0001 0094          ldd  r0,y+0
                 ; 0001 0095          ldd  r1,y+1
                 ; 0001 0096          //ldi   r22,LOW(1)
                 ; 0001 0097          //WR_SPMCR_REG_R22
                 ; 0001 0098          //spm
                 ; 0001 0099     #endasm
                 ; 0001 009A dospm();
                 ; 0001 009B }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 009E {
                 ; 0001 009F #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00A0      ldd  r30,y+1
                 ; 0001 00A1      ldd  r31,y+2
                 ; 0001 00A2      ld   r22,y
                 ; 0001 00A3      WR_SPMCR_REG_R22
                 ; 0001 00A4      spm
                 ; 0001 00A5 #endasm
                 ; 0001 00A6 }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00A9 {
                 ; 0001 00AA _WAIT_FOR_SPM();
                 ;	*addr -> Y+0
                 ; 0001 00AB #asm
                 ; 0001 00AC      ldd  r30,y+0
                 ; 0001 00AD      ldd  r31,y+1
                 ; 0001 00AE      //ld   r22,y
                 ; 0001 00AF      //WR_SPMCR_REG_R22
                 ; 0001 00B0      //spm
                 ; 0001 00B1 #endasm
                 ; 0001 00B2 dospmew();
                 ; 0001 00B3 }
                 ;
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 00B7 {
                 ; 0001 00B8 #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00B9      ldd  r30,y+3
                 ; 0001 00BA      ldd  r31,y+4
                 ; 0001 00BB      ldd  r22,y+5
                 ; 0001 00BC      out  rampz,r22
                 ; 0001 00BD      ldd  r0,y+1
                 ; 0001 00BE      ldd  r1,y+2
                 ; 0001 00BF      ld   r22,y
                 ; 0001 00C0      WR_SPMCR_REG_R22
                 ; 0001 00C1      spm
                 ; 0001 00C2 #endasm
                 ; 0001 00C3 }
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 00C6 {
                 ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F:
                 ; .FSTART ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0001 00C7 _WAIT_FOR_SPM();
00f97c 93ba      	ST   -Y,R27
00f97d 93aa      	ST   -Y,R26
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 _0x20030:
00f97e 91e0 0068 	LDS  R30,104
00f980 70e1      	ANDI R30,LOW(0x1)
00f981 f7e1      	BRNE _0x20030
                 ; 0001 00C8 #asm
                 ; 0001 00C9      ldd  r30,y+2
00f982 81ea           ldd  r30,y+2
                 ; 0001 00CA      ldd  r31,y+3
00f983 81fb           ldd  r31,y+3
                 ; 0001 00CB      ldd  r22,y+4
00f984 816c           ldd  r22,y+4
                 ; 0001 00CC      out  rampz,r22
00f985 bf6b           out  rampz,r22
                 ; 0001 00CD      ldd  r0,y+0
00f986 8008           ldd  r0,y+0
                 ; 0001 00CE      ldd  r1,y+1
00f987 8019           ldd  r1,y+1
                 ; 0001 00CF      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00D0      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00D1      //spm
                      //spm
                 ; 0001 00D2 #endasm
                 ; 0001 00D3 dospm();
00f988 940e f966 	CALL _dospm
                 ; 0001 00D4 }
00f98a 940c fd50 	JMP  _0x2000004
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 00D7 {
                 ; 0001 00D8 #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00D9      ldd  r30,y+1
                 ; 0001 00DA      ldd  r31,y+2
                 ; 0001 00DB      ldd  r22,y+3
                 ; 0001 00DC      out  rampz,r22
                 ; 0001 00DD      ld   r22,y
                 ; 0001 00DE      WR_SPMCR_REG_R22
                 ; 0001 00DF      spm
                 ; 0001 00E0 #endasm
                 ; 0001 00E1 }
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00E4 {
                 ___AddrToZ24ByteToSPMCR_SPM_W:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0001 00E5 _WAIT_FOR_SPM();
00f98c 940e ffd1 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20033:
00f98e 91e0 0068 	LDS  R30,104
00f990 70e1      	ANDI R30,LOW(0x1)
00f991 f7e1      	BRNE _0x20033
                 ; 0001 00E6 #asm
                 ; 0001 00E7      ldd  r30,y+0
00f992 81e8           ldd  r30,y+0
                 ; 0001 00E8      ldd  r31,y+1
00f993 81f9           ldd  r31,y+1
                 ; 0001 00E9      ldd  r22,y+2
00f994 816a           ldd  r22,y+2
                 ; 0001 00EA      out  rampz,r22
00f995 bf6b           out  rampz,r22
                 ; 0001 00EB      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00EC      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00ED      //spm
                      //spm
                 ; 0001 00EE #endasm
                 ; 0001 00EF dospmw();
00f996 940e f93a 	CALL _dospmw
                 ; 0001 00F0 }
00f998 940c fcbc 	JMP  _0x200000A
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_E(void flash *addr)
                 ; 0001 00F3 {
                 ___AddrToZ24ByteToSPMCR_SPM_E:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0001 00F4 _WAIT_FOR_SPM();
00f99a 940e ffd1 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20036:
00f99c 91e0 0068 	LDS  R30,104
00f99e 70e1      	ANDI R30,LOW(0x1)
00f99f f7e1      	BRNE _0x20036
                 ; 0001 00F5 #asm
                 ; 0001 00F6      ldd  r30,y+0
00f9a0 81e8           ldd  r30,y+0
                 ; 0001 00F7      ldd  r31,y+1
00f9a1 81f9           ldd  r31,y+1
                 ; 0001 00F8      ldd  r22,y+2
00f9a2 816a           ldd  r22,y+2
                 ; 0001 00F9      out  rampz,r22
00f9a3 bf6b           out  rampz,r22
                 ; 0001 00FA      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00FB      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00FC      //spm
                      //spm
                 ; 0001 00FD #endasm
                 ; 0001 00FE dospme();
00f9a4 940e f950 	CALL _dospme
                 ; 0001 00FF }
00f9a6 940c fcbc 	JMP  _0x200000A
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_EW(void flash *addr)
                 ; 0001 0102 {
                 ___AddrToZ24ByteToSPMCR_SPM_EW:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0001 0103 _WAIT_FOR_SPM();
00f9a8 940e ffd1 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20039:
00f9aa 91e0 0068 	LDS  R30,104
00f9ac 70e1      	ANDI R30,LOW(0x1)
00f9ad f7e1      	BRNE _0x20039
                 ; 0001 0104 #asm
                 ; 0001 0105      ldd  r30,y+0
00f9ae 81e8           ldd  r30,y+0
                 ; 0001 0106      ldd  r31,y+1
00f9af 81f9           ldd  r31,y+1
                 ; 0001 0107      ldd  r22,y+2
00f9b0 816a           ldd  r22,y+2
                 ; 0001 0108      out  rampz,r22
00f9b1 bf6b           out  rampz,r22
                 ; 0001 0109      //ld   r22,y
                      //ld   r22,y
                 ; 0001 010A      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 010B      //spm
                      //spm
                 ; 0001 010C #endasm
                 ; 0001 010D dospmew();
00f9b2 940e f91c 	CALL _dospmew
                 ; 0001 010E }
00f9b4 940c fcbc 	JMP  _0x200000A
                 ; .FEND
                 ;
                 ;#ifdef _WARNINGS_ON_
                 ;#pragma warn+
                 ;#endif
                 ;
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming_main.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : This example is written for ATmega128.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains an example program using the Flash R/W
                 ;*                       functions provided with the files Self_programming.h /
                 ;*                       Self_programming.c . The program should be compiled using
                 ;*                       a linker file (*.xcl) that is configured to place the
                 ;*                       entire program code into the Boot section of the Flash memory.
                 ;*                       Please refer to the application note document for more
                 ;*                       information.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;*****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include "Self_programming.h"
                 ;#include "spi_sdcard.h"
                 ;
                 ;#define SDBUF_SIZE  512
                 ;#define PAGES_PER_SDBUF (SDBUF_SIZE/PAGESIZE)
                 ;
                 ;//#define DEBUGLED
                 ;//#define DEBUG_ERRSD
                 ;//#define DEBUG_LCD
                 ;
                 ;#ifdef DEBUG_LCD
                 ;
                 ;/* printf */
                 ;#include <stdio.h>
                 ;#include <stdlib.h>
                 ;/* string functions */
                 ;#include <string.h>
                 ;#include <alcd.h>
                 ;
                 ;#endif
                 ;
                 ;unsigned char result[5], sdBuf[SDBUF_SIZE], testBuf[PAGESIZE], token, SectorsPerCluster, pagesCnt;
                 ;unsigned long appStartAdr,adr,SectorsPerFat,fat_begin_lba;
                 ;unsigned long cluster_begin_lba,root_dir_first_cluster,fat_file_adr,fat_file_next_adr,filesize,readbytes;
                 ;unsigned int appPages,bytesChecksum,checksumCnt;
                 ;unsigned int Number_of_Reserved_Sectors;
                 ;//(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ;//(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FA ...
                 ;//(unsigned char)sectors_per_cluster = BPB_SecPerClus;
                 ;//(unsigned long)root_dir_first_cluster = BPB_RootClus;
                 ;//void testWrite();
                 ;
                 ;#ifdef DEBUG_ERRSD
                 ;void errorSD(unsigned char err);
                 ;#endif
                 ;#ifdef DEBUG_LCD
                 ;lcd_printhex(unsigned long num32, char size);
                 ;char cnum[10];
                 ;#endif
                 ;
                 ;//function prototypes
                 ;//unsigned char fat_init();//0=sucess, 1,2,3 errors
                 ;//unsigned char dir_open(const char *dirname); //0=sucess, 4 error
                 ;//unsigned char file_open(const char *filename); //0=sucess, 5,6 errors
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len);
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest);
                 ;void (*app_pointer)(void) = (void(*)(void))0x0000;
                 ;
                 ;
                 ;
                 ;void main( void ){
                 ; 0002 0051 void main( void ){
                 
                 	.CSEG
                 _main:
                 ; .FSTART _main
                 ; 0002 0052 
                 ; 0002 0053   unsigned int i,j,k;
                 ; 0002 0054   unsigned char rollnum;
                 ; 0002 0055   unsigned char rollbuf[11];
                 ; 0002 0056 /* globally enable interrupts */
                 ; 0002 0057 #asm("sei")
00f9b6 972c      	SBIW R28,12
                 ;	i -> R16,R17
                 ;	j -> R18,R19
                 ;	k -> R20,R21
                 ;	rollnum -> Y+11
                 ;	rollbuf -> Y+0
00f9b7 9478      	sei
                 ; 0002 0058 #ifdef DEBUG_LCD
                 ; 0002 0059     DDRC.0=1;
                 ; 0002 005A     PORTC.0=1;
                 ; 0002 005B     /* initialize the LCD for 2 lines & 16 columns */
                 ; 0002 005C     lcd_init(16);
                 ; 0002 005D     /* switch to writing in Display RAM */
                 ; 0002 005E     lcd_gotoxy(0,0);
                 ; 0002 005F     lcd_clear();
                 ; 0002 0060     lcd_putsf("BootSdTest.");
                 ; 0002 0061     lcd_gotoxy(0,1);
                 ; 0002 0062     lcd_putsf("0");
                 ; 0002 0063     delay_ms(500);
                 ; 0002 0064     //while(1);
                 ; 0002 0065 #endif
                 ; 0002 0066 #ifdef DEBUGLED
                 ; 0002 0067   DDRC=0xFF;
                 ; 0002 0068   PORTC=0xFF;
                 ; 0002 0069     //do
                 ; 0002 006A     {
                 ; 0002 006B       PORTC.0=0;
                 ; 0002 006C       PORTC.1=1;
                 ; 0002 006D       delay_ms(500);
                 ; 0002 006E       PORTC.1=0;
                 ; 0002 006F       PORTC.0=1;
                 ; 0002 0070       delay_ms(500);
                 ; 0002 0071       PORTC=0xFF;
                 ; 0002 0072     }
                 ; 0002 0073     //while(1);
                 ; 0002 0074 #endif
                 ; 0002 0075     //fat init function
                 ; 0002 0076     //init SD
                 ; 0002 0077   if((result[0]=SD_init())!=SD_SUCCESS){
00f9b8 940e fd14 	CALL _SD_init
00f9ba 93e0 091e 	STS  _result,R30
                 ; 0002 0078 #ifdef DEBUG_ERRSD
                 ; 0002 0079     errorSD(1);
                 ; 0002 007A #endif
                 ; 0002 007B     //return 1;
                 ; 0002 007C     //app_pointer();//jump to app 0 on error
                 ; 0002 007D   }
                 ; 0002 007E   #ifdef DEBUG_LCD
                 ; 0002 007F   lcd_putsf("1");
                 ; 0002 0080   delay_ms(500);
                 ; 0002 0081   #endif
                 ; 0002 0082   // read MBR get FAT start sector
                 ; 0002 0083   if((result[0]=SD_readSingleBlock(0, sdBuf, &token))!=SD_SUCCESS){
00f9bc 940e fdd5 	CALL SUBOPT_0x0
00f9be 940e fdee 	CALL SUBOPT_0x5
                 ; 0002 0084 #ifdef DEBUG_ERRSD
                 ; 0002 0085     errorSD(2);
                 ; 0002 0086 #endif
                 ; 0002 0087     //return 2;
                 ; 0002 0088     //app_pointer();//jump to app 0 on error
                 ; 0002 0089   }
                 ; 0002 008A   #ifdef DEBUG_LCD
                 ; 0002 008B   lcd_putsf("2");
                 ; 0002 008C   delay_ms(500);
                 ; 0002 008D   #endif
                 ; 0002 008E   adr=buf2num(&sdBuf[445+9],4);//FAT start sector. 1 sector = 512 bytes
                +
00f9c0 eee9     +LDI R30 , LOW ( _sdBuf + ( 454 ) )
00f9c1 e0fa     +LDI R31 , HIGH ( _sdBuf + ( 454 ) )
                 	__POINTW1MN _sdBuf,454
00f9c2 940e fdf8 	CALL SUBOPT_0x6
00f9c4 940e fdfc 	CALL SUBOPT_0x7
                 ; 0002 008F 
                 ; 0002 0090   //load and read FAT ID (1st) sector. Get FAT info. Secors per Cluster and etc..
                 ; 0002 0091   if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
00f9c6 940e fe05 	CALL SUBOPT_0x8
                 ; 0002 0092     #ifdef DEBUG_ERRSD
                 ; 0002 0093     errorSD(3);
                 ; 0002 0094     #endif
                 ; 0002 0095     //return 3;
                 ; 0002 0096     //app_pointer();//jump to app 0 on error
                 ; 0002 0097   }
                 ; 0002 0098   #ifdef DEBUG_LCD
                 ; 0002 0099   lcd_putsf("3");
                 ; 0002 009A   delay_ms(500);
                 ; 0002 009B   #endif
                 ; 0002 009C   SectorsPerCluster=sdBuf[0x0D];// 8 sectors per cluster
                +
00f9c8 9080 0930+LDS R8 , _sdBuf + ( 13 )
                 	__GETBRMN 8,_sdBuf,13
                 ; 0002 009D   SectorsPerFat=buf2num(&sdBuf[0x24],4); // 0xF10 for test sdcard
                +
00f9ca e4e7     +LDI R30 , LOW ( _sdBuf + ( 36 ) )
00f9cb e0f9     +LDI R31 , HIGH ( _sdBuf + ( 36 ) )
                 	__POINTW1MN _sdBuf,36
00f9cc 940e fdf8 	CALL SUBOPT_0x6
00f9ce 93e0 0b2b 	STS  _SectorsPerFat,R30
00f9d0 93f0 0b2c 	STS  _SectorsPerFat+1,R31
00f9d2 9360 0b2d 	STS  _SectorsPerFat+2,R22
00f9d4 9370 0b2e 	STS  _SectorsPerFat+3,R23
                 ; 0002 009E   Number_of_Reserved_Sectors=buf2num(&sdBuf[0x0E],2); // 0x20 usually
                +
00f9d6 e3e1     +LDI R30 , LOW ( _sdBuf + ( 14 ) )
00f9d7 e0f9     +LDI R31 , HIGH ( _sdBuf + ( 14 ) )
                 	__POINTW1MN _sdBuf,14
00f9d8 93fa      	ST   -Y,R31
00f9d9 93ea      	ST   -Y,R30
00f9da e0a2      	LDI  R26,LOW(2)
00f9db d263      	RCALL _buf2num
00f9dc 93e0 0b4b 	STS  _Number_of_Reserved_Sectors,R30
00f9de 93f0 0b4c 	STS  _Number_of_Reserved_Sectors+1,R31
                 ; 0002 009F   //read the FAT fils/directories info from Root Directory cluster (usually 2),Number_of_Reserved_Sectors (usually 0x20) ...
                 ; 0002 00A0   //(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ; 0002 00A1   fat_begin_lba=adr+Number_of_Reserved_Sectors;//0x20;//first sector of FAT data
00f9e0 91a0 0b27 	LDS  R26,_adr
00f9e2 91b0 0b28 	LDS  R27,_adr+1
00f9e4 9180 0b29 	LDS  R24,_adr+2
00f9e6 9190 0b2a 	LDS  R25,_adr+3
00f9e8 2766      	CLR  R22
00f9e9 2777      	CLR  R23
00f9ea 940e ff13 	CALL __ADDD12
00f9ec 93e0 0b2f 	STS  _fat_begin_lba,R30
00f9ee 93f0 0b30 	STS  _fat_begin_lba+1,R31
00f9f0 9360 0b31 	STS  _fat_begin_lba+2,R22
00f9f2 9370 0b32 	STS  _fat_begin_lba+3,R23
                 ; 0002 00A2   //(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_ ...
                 ; 0002 00A3   //Number_of_FATs always 2. Offset 0x10 8bit
                 ; 0002 00A4   cluster_begin_lba=fat_begin_lba+(2*SectorsPerFat);//number of sector where data begin
00f9f4 91e0 0b2b 	LDS  R30,_SectorsPerFat
00f9f6 91f0 0b2c 	LDS  R31,_SectorsPerFat+1
00f9f8 9160 0b2d 	LDS  R22,_SectorsPerFat+2
00f9fa 9170 0b2e 	LDS  R23,_SectorsPerFat+3
00f9fc 940e ff39 	CALL __LSLD1
00f9fe 940e fe10 	CALL SUBOPT_0x9
00fa00 93e0 0b33 	STS  _cluster_begin_lba,R30
00fa02 93f0 0b34 	STS  _cluster_begin_lba+1,R31
00fa04 9360 0b35 	STS  _cluster_begin_lba+2,R22
00fa06 9370 0b36 	STS  _cluster_begin_lba+3,R23
                 ; 0002 00A5   //read root dir (sector 2 but always offset 2 too then 0) to find folder 0 FAT reference. and find Flash.dat sector
                 ; 0002 00A6   //lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
                 ; 0002 00A7   adr=cluster_begin_lba +(2-2)*SectorsPerCluster;
00fa08 940e fdfc 	CALL SUBOPT_0x7
                 ; 0002 00A8   //adr*=512UL;
                 ; 0002 00A9 
                 ; 0002 00AA     //dir open function
                 ; 0002 00AB     result[1]=0;
00fa0a e0e0      	LDI  R30,LOW(0)
                +
00fa0b 93e0 091f+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
                 ; 0002 00AC   for(i=0;i<SectorsPerCluster;i++)
                +
00fa0d e000     +LDI R16 , LOW ( 0 )
00fa0e e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x40007:
00fa0f 940e fe1b 	CALL SUBOPT_0xA
00fa11 f500      	BRSH _0x40008
                 ; 0002 00AD   {
                 ; 0002 00AE 
                 ; 0002 00AF       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
00fa12 940e fe05 	CALL SUBOPT_0x8
                 ; 0002 00B0     #ifdef DEBUG_ERRSD
                 ; 0002 00B1         errorSD(4);
                 ; 0002 00B2     #endif
                 ; 0002 00B3         //return 4;
                 ; 0002 00B4         //app_pointer();//jump to app 0 on error
                 ; 0002 00B5       }
                 ; 0002 00B6       for(j=0;j<(16);j++)//search 16*32bit records in 512bytes sector
                +
00fa14 e020     +LDI R18 , LOW ( 0 )
00fa15 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x4000B:
                +
00fa16 3120     +CPI R18 , LOW ( 16 )
00fa17 e0e0     +LDI R30 , HIGH ( 16 )
00fa18 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
00fa19 f440      	BRSH _0x4000C
                 ; 0002 00B7       {
                 ; 0002 00B8            if((result[1]=compbuf("0          ",&sdBuf[j*32]))!=0)
                +
00fa1a e0e0     +LDI R30 , LOW ( _0x4000E + ( 0 ) )
00fa1b e0f9     +LDI R31 , HIGH ( _0x4000E + ( 0 ) )
                 	__POINTW1MN _0x4000E,0
00fa1c 940e fe21 	CALL SUBOPT_0xB
00fa1e f419      	BRNE _0x4000C
                 ; 0002 00B9            //if((result[1]=compbuf(dirname,&sdBuf[j*32]))!=0)
                 ; 0002 00BA            {
                 ; 0002 00BB                 break;//dir 0 is found
                 ; 0002 00BC            }
                 ; 0002 00BD       }
                +
00fa1f 5f2f     +SUBI R18 , LOW ( - 1 )
00fa20 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fa21 cff4      	RJMP _0x4000B
                 _0x4000C:
                 ; 0002 00BE       if(result[1]!=0)
                +
00fa22 91e0 091f+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fa24 30e0      	CPI  R30,0
00fa25 f039      	BREQ _0x4000F
                 ; 0002 00BF       {
                 ; 0002 00C0         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
00fa26 940e fe30 	CALL SUBOPT_0xC
00fa28 940e fe36 	CALL SUBOPT_0xD
                 ; 0002 00C1         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
00fa2a 940e fe47 	CALL SUBOPT_0xE
                 ; 0002 00C2         break;
00fa2c c005      	RJMP _0x40008
                 ; 0002 00C3       }
                 ; 0002 00C4       else
                 _0x4000F:
                 ; 0002 00C5         adr++;
00fa2d 940e fe60 	CALL SUBOPT_0xF
                 ; 0002 00C6   }
                +
00fa2f 5f0f     +SUBI R16 , LOW ( - 1 )
00fa30 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fa31 cfdd      	RJMP _0x40007
                 _0x40008:
                 ; 0002 00C7   if(result[1]==0){
                +
00fa32 91e0 091f+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fa34 30e0      	CPI  R30,0
00fa35 f429      	BRNE _0x40011
                 ; 0002 00C8      app_pointer();//jump to app on error dir not found
                +
00fa36 91e0 0b4d+LDS R30 , _app_pointer + ( 0 )
00fa38 91f0 0b4e+LDS R31 , _app_pointer + ( 0 ) + 1
00fa3a 9509     +ICALL
                 	__CALL1MN _app_pointer,0
                 ; 0002 00C9   }
                 ; 0002 00CA   #ifdef DEBUG_LCD
                 ; 0002 00CB   lcd_putsf("4");//dir found ok
                 ; 0002 00CC   delay_ms(500);
                 ; 0002 00CD   #endif
                 ; 0002 00CE   //fat_file_adr is hold the files records cluster in found dir
                 ; 0002 00CF   //file open func. read first cluster where data about filenames in dir
                 ; 0002 00D0   adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
                 _0x40011:
00fa3b 940e fe6b 	CALL SUBOPT_0x10
00fa3d 940e fe74 	CALL SUBOPT_0x11
                 ; 0002 00D1   for(i=0;i<SectorsPerCluster;i++)
                 _0x40013:
00fa3f 940e fe1b 	CALL SUBOPT_0xA
00fa41 f580      	BRSH _0x40014
                 ; 0002 00D2   {
                 ; 0002 00D3 
                 ; 0002 00D4       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
00fa42 940e fe05 	CALL SUBOPT_0x8
                 ; 0002 00D5     #ifdef DEBUG_ERRSD
                 ; 0002 00D6         errorSD(5);
                 ; 0002 00D7     #endif
                 ; 0002 00D8         //return 5;
                 ; 0002 00D9         //app_pointer();//jump to app on error
                 ; 0002 00DA       }
                 ; 0002 00DB       for(j=0;j<(16);j++)//search 16 * 32 filename records
                +
00fa44 e020     +LDI R18 , LOW ( 0 )
00fa45 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40017:
                +
00fa46 3120     +CPI R18 , LOW ( 16 )
00fa47 e0e0     +LDI R30 , HIGH ( 16 )
00fa48 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
00fa49 f440      	BRSH _0x40018
                 ; 0002 00DC       {
                 ; 0002 00DD            if((result[1]=compbuf("UPDATE",&sdBuf[j*32]))!=0)
                +
00fa4a e0ec     +LDI R30 , LOW ( _0x4000E + ( 12 ) )
00fa4b e0f9     +LDI R31 , HIGH ( _0x4000E + ( 12 ) )
                 	__POINTW1MN _0x4000E,12
00fa4c 940e fe21 	CALL SUBOPT_0xB
00fa4e f419      	BRNE _0x40018
                 ; 0002 00DE            //if((result[1]=compbuf(filename,&sdBuf[j*32]))!=0)
                 ; 0002 00DF            {
                 ; 0002 00E0                 break;//file Flash... is found
                 ; 0002 00E1            }
                 ; 0002 00E2       }
                +
00fa4f 5f2f     +SUBI R18 , LOW ( - 1 )
00fa50 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fa51 cff4      	RJMP _0x40017
                 _0x40018:
                 ; 0002 00E3       if(result[1]!=0)
                +
00fa52 91e0 091f+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fa54 30e0      	CPI  R30,0
00fa55 f0b9      	BREQ _0x4001A
                 ; 0002 00E4       {
                 ; 0002 00E5         //read 1st number of cluster where data placed
                 ; 0002 00E6         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
00fa56 940e fe30 	CALL SUBOPT_0xC
00fa58 940e fe36 	CALL SUBOPT_0xD
                 ; 0002 00E7         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
00fa5a 940e fe47 	CALL SUBOPT_0xE
                 ; 0002 00E8         filesize = buf2num(&sdBuf[j*32+0x1C],8);
00fa5c 940e fe30 	CALL SUBOPT_0xC
                +
00fa5e 5ce1     +SUBI R30 , LOW ( - _sdBuf - ( 28 ) )
00fa5f 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 28 ) )
                 	__ADDW1MN _sdBuf,28
00fa60 93fa      	ST   -Y,R31
00fa61 93ea      	ST   -Y,R30
00fa62 e0a8      	LDI  R26,LOW(8)
00fa63 d1db      	RCALL _buf2num
00fa64 93e0 0b3f 	STS  _filesize,R30
00fa66 93f0 0b40 	STS  _filesize+1,R31
00fa68 9360 0b41 	STS  _filesize+2,R22
00fa6a 9370 0b42 	STS  _filesize+3,R23
                 ; 0002 00E9         break;
00fa6c c005      	RJMP _0x40014
                 ; 0002 00EA       }
                 ; 0002 00EB       else
                 _0x4001A:
                 ; 0002 00EC         adr++;
00fa6d 940e fe60 	CALL SUBOPT_0xF
                 ; 0002 00ED   }
                +
00fa6f 5f0f     +SUBI R16 , LOW ( - 1 )
00fa70 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fa71 cfcd      	RJMP _0x40013
                 _0x40014:
                 ; 0002 00EE   if(result[1]==0){// error if file not found
                 ; 0002 00EF     #ifdef DEBUG_ERRSD
                 ; 0002 00F0     errorSD(6);
                 ; 0002 00F1     #endif
                 ; 0002 00F2     //return 6;
                 ; 0002 00F3     //app_pointer();//jump to app on error
                 ; 0002 00F4   }
                 ; 0002 00F5   #ifdef DEBUG_LCD
                 ; 0002 00F6   lcd_putsf("5");//file found ok
                 ; 0002 00F7   delay_ms(500);
                 ; 0002 00F8   #endif
                 ; 0002 00F9   //check UPDATE0 or UPDATE1...UPDATE9
                 ; 0002 00FA   if((sdBuf[j*32+6])=='0'){
00fa72 940e fe30 	CALL SUBOPT_0xC
                +
00fa74 5de7     +SUBI R30 , LOW ( - _sdBuf - ( 6 ) )
00fa75 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 6 ) )
                 	__ADDW1MN _sdBuf,6
00fa76 81a0      	LD   R26,Z
00fa77 33a0      	CPI  R26,LOW(0x30)
00fa78 f0c1      	BREQ _0x4001E
                 ; 0002 00FB     //return 1;//error if update reach 0
                 ; 0002 00FC     #ifdef DEBUG_ERRSD
                 ; 0002 00FD     errorSD(7);
                 ; 0002 00FE     #endif
                 ; 0002 00FF     #ifdef DEBUG_LCD
                 ; 0002 0100     lcd_putsf("ret0");
                 ; 0002 0101     delay_ms(500);
                 ; 0002 0102     #endif
                 ; 0002 0103     //app_pointer();//jump to app if no more retry
                 ; 0002 0104   }
                 ; 0002 0105   else if(((sdBuf[j*32+6])>'0')||((sdBuf[j*32+6])<='9')){
00fa79 940e fe30 	CALL SUBOPT_0xC
                +
00fa7b 5de7     +SUBI R30 , LOW ( - _sdBuf - ( 6 ) )
00fa7c 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 6 ) )
                 	__ADDW1MN _sdBuf,6
00fa7d 81a0      	LD   R26,Z
00fa7e 33a1      	CPI  R26,LOW(0x31)
00fa7f f410      	BRSH _0x40020
00fa80 33aa      	CPI  R26,LOW(0x3A)
00fa81 f448      	BRSH _0x4001F
                 _0x40020:
                 ; 0002 0106     sdBuf[j*32+6]--;//decrement 1 retry.
00fa82 940e fe30 	CALL SUBOPT_0xC
                +
00fa84 5de7     +SUBI R30 , LOW ( - _sdBuf - ( 6 ) )
00fa85 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 6 ) )
                 	__ADDW1MN _sdBuf,6
00fa86 01df      	MOVW R26,R30
00fa87 91ec      	LD   R30,X
00fa88 50e1      	SUBI R30,LOW(1)
00fa89 93ec      	ST   X,R30
                 ; 0002 0107   }
                 ; 0002 0108   else{
00fa8a c006      	RJMP _0x40022
                 _0x4001F:
                 ; 0002 0109     sdBuf[j*32+6]='9';
00fa8b 940e fe30 	CALL SUBOPT_0xC
                +
00fa8d 5de7     +SUBI R30 , LOW ( - _sdBuf - ( 6 ) )
00fa8e 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 6 ) )
                 	__ADDW1MN _sdBuf,6
00fa8f e3a9      	LDI  R26,LOW(57)
00fa90 83a0      	STD  Z+0,R26
                 ; 0002 010A   }
                 _0x40022:
                 _0x4001E:
                 ; 0002 010B   result[0]=SD_writeSingleBlock(adr, sdBuf, &token);//save new UPDATE(num) filename.
00fa91 91e0 0b27 	LDS  R30,_adr
00fa93 91f0 0b28 	LDS  R31,_adr+1
00fa95 9160 0b29 	LDS  R22,_adr+2
00fa97 9170 0b2a 	LDS  R23,_adr+3
00fa99 940e ffcc 	CALL __PUTPARD1
00fa9b e2e3      	LDI  R30,LOW(_sdBuf)
00fa9c e0f9      	LDI  R31,HIGH(_sdBuf)
00fa9d 93fa      	ST   -Y,R31
00fa9e 93ea      	ST   -Y,R30
00fa9f e0a9      	LDI  R26,LOW(9)
00faa0 e0b0      	LDI  R27,HIGH(9)
00faa1 940e fd8f 	CALL _SD_writeSingleBlock
00faa3 93e0 091e 	STS  _result,R30
                 ; 0002 010C   #ifdef DEBUG_LCD
                 ; 0002 010D   lcd_putsf("7");
                 ; 0002 010E   delay_ms(500);
                 ; 0002 010F   #endif
                 ; 0002 0110   //check FAT for chain of clusters to read
                 ; 0002 0111   readbytes=0;
00faa5 e0e0      	LDI  R30,LOW(0)
00faa6 93e0 0b43 	STS  _readbytes,R30
00faa8 93e0 0b44 	STS  _readbytes+1,R30
00faaa 93e0 0b45 	STS  _readbytes+2,R30
00faac 93e0 0b46 	STS  _readbytes+3,R30
                 ; 0002 0112   while(fat_file_adr != 0x0FFFFFFFUL)
                 _0x40023:
00faae 91a0 0b37 	LDS  R26,_fat_file_adr
00fab0 91b0 0b38 	LDS  R27,_fat_file_adr+1
00fab2 9180 0b39 	LDS  R24,_fat_file_adr+2
00fab4 9190 0b3a 	LDS  R25,_fat_file_adr+3
00fab6 940e fe8e 	CALL SUBOPT_0x12
00fab8 f409      	BRNE PC+2
00fab9 c16d      	RJMP _0x40025
                 ; 0002 0113   {
                 ; 0002 0114     //read where next cluster from FAT, check that not EOF
                 ; 0002 0115     //if((result[0]=SD_readSingleBlock(fat_begin_lba, sdBuf, &token))!=SD_SUCCESS){
                 ; 0002 0116 
                 ; 0002 0117     if((result[0]=SD_readSingleBlock(fat_begin_lba+((fat_file_adr*4)/512), sdBuf, &token))!=SD_SUCCESS){
00faba 940e fe6b 	CALL SUBOPT_0x10
00fabc 940e ff39 	CALL __LSLD1
00fabe 940e ff39 	CALL __LSLD1
00fac0 01df      	MOVW R26,R30
00fac1 01cb      	MOVW R24,R22
                +
00fac2 e0e0     +LDI R30 , LOW ( 0x200 )
00fac3 e0f2     +LDI R31 , HIGH ( 0x200 )
00fac4 e060     +LDI R22 , BYTE3 ( 0x200 )
00fac5 e070     +LDI R23 , BYTE4 ( 0x200 )
                 	__GETD1N 0x200
00fac6 940e ff80 	CALL __DIVD21U
00fac8 940e fe10 	CALL SUBOPT_0x9
00faca 940e ffcc 	CALL __PUTPARD1
00facc 940e fdee 	CALL SUBOPT_0x5
00face 30e0      	CPI  R30,0
00facf f009      	BREQ _0x40026
                 ; 0002 0118     #ifdef DEBUG_ERRSD
                 ; 0002 0119         errorSD(7);
                 ; 0002 011A     #endif
                 ; 0002 011B         while(1);//do watchdog reset on error
                 _0x40027:
00fad0 cfff      	RJMP _0x40027
                 ; 0002 011C     }
                 ; 0002 011D     //next cluster address, of file data, read from current cluster record.each record 4 bytes (32bits)
                 ; 0002 011E     //fat_file_next_adr=buf2num(&sdBuf[fat_file_adr*4],4);
                 ; 0002 011F     fat_file_next_adr=buf2num(&sdBuf[(fat_file_adr*4)%512],4);
                 _0x40026:
00fad1 91a0 0b37 	LDS  R26,_fat_file_adr
00fad3 91b0 0b38 	LDS  R27,_fat_file_adr+1
00fad5 e0e4      	LDI  R30,LOW(4)
00fad6 940e ff75 	CALL __MULB1W2U
00fad8 70f1      	ANDI R31,HIGH(0x1FF)
00fad9 5ded      	SUBI R30,LOW(-_sdBuf)
00fada 4ff6      	SBCI R31,HIGH(-_sdBuf)
00fadb 940e fdf8 	CALL SUBOPT_0x6
00fadd 93e0 0b3b 	STS  _fat_file_next_adr,R30
00fadf 93f0 0b3c 	STS  _fat_file_next_adr+1,R31
00fae1 9360 0b3d 	STS  _fat_file_next_adr+2,R22
00fae3 9370 0b3e 	STS  _fat_file_next_adr+3,R23
                 ; 0002 0120     #ifdef DEBUG_LCD
                 ; 0002 0121       lcd_clear();
                 ; 0002 0122       lcd_putsf("beglba");
                 ; 0002 0123       lcd_printhex(fat_begin_lba,sizeof(fat_begin_lba));
                 ; 0002 0124       delay_ms(1000);
                 ; 0002 0125       lcd_clear();
                 ; 0002 0126       lcd_putsf("curcls");
                 ; 0002 0127       lcd_printhex(fat_file_adr,sizeof(fat_file_adr));
                 ; 0002 0128       lcd_gotoxy(0,1);
                 ; 0002 0129       lcd_putsf("nxtcls");
                 ; 0002 012A       lcd_printhex(fat_file_next_adr,sizeof(fat_file_next_adr));
                 ; 0002 012B       delay_ms(1000);
                 ; 0002 012C     #endif
                 ; 0002 012D     adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
00fae5 940e fe6b 	CALL SUBOPT_0x10
00fae7 940e fe74 	CALL SUBOPT_0x11
                 ; 0002 012E     for(i=0;i<SectorsPerCluster;i++)
                 _0x4002B:
00fae9 940e fe1b 	CALL SUBOPT_0xA
00faeb f008      	BRLO PC+2
00faec c129      	RJMP _0x4002C
                 ; 0002 012F     {
                 ; 0002 0130         //read data from next sector of file cluster
                 ; 0002 0131         if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
00faed 940e fe05 	CALL SUBOPT_0x8
                 ; 0002 0132         #ifdef DEBUG_ERRSD
                 ; 0002 0133             errorSD(8);
                 ; 0002 0134         #endif
                 ; 0002 0135         }
                 ; 0002 0136         #ifdef DEBUG_LCD
                 ; 0002 0137           lcd_clear();
                 ; 0002 0138           lcd_putsf("sector ");
                 ; 0002 0139           lcd_printhex(i,sizeof(i));
                 ; 0002 013A           //delay_ms(500);
                 ; 0002 013B           //if(readbytes==2048){
                 ; 0002 013C           lcd_gotoxy(0,1);
                 ; 0002 013D           lcd_putsf("data0 ");
                 ; 0002 013E           lcd_printhex(sdBuf[0],sizeof(sdBuf[0]));
                 ; 0002 013F           delay_ms(1000);
                 ; 0002 0140         //}
                 ; 0002 0141         #endif
                 ; 0002 0142         //address 2000 = start adr flash app 3 bytes, flash pages 2 bytes, checksum 2 bytes
                 ; 0002 0143         //app bytes starts from 2048, roll 0x88
                 ; 0002 0144         if(readbytes<512){
00faef 940e fe96 	CALL SUBOPT_0x13
                +
00faf1 30a0     +CPI R26 , LOW ( 0x200 )
00faf2 e0e2     +LDI R30 , HIGH ( 0x200 )
00faf3 07be     +CPC R27 , R30
00faf4 e0e0     +LDI R30 , BYTE3 ( 0x200 )
00faf5 078e     +CPC R24 , R30
00faf6 e0e0     +LDI R30 , BYTE4 ( 0x200 )
00faf7 079e     +CPC R25 , R30
                 	__CPD2N 0x200
00faf8 f008      	BRLO PC+2
00faf9 c03d      	RJMP _0x4002E
                 ; 0002 0145             //j=0x99;
                 ; 0002 0146             for(j=0;j<256;j++){//find roll
                +
00fafa e020     +LDI R18 , LOW ( 0 )
00fafb e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40030:
                +
00fafc 3020     +CPI R18 , LOW ( 256 )
00fafd e0e1     +LDI R30 , HIGH ( 256 )
00fafe 073e     +CPC R19 , R30
                 	__CPWRN 18,19,256
00faff f5b8      	BRSH _0x40031
                 ; 0002 0147                if(j>0){
00fb00 2400      	CLR  R0
00fb01 1602      	CP   R0,R18
00fb02 0603      	CPC  R0,R19
00fb03 f508      	BRSH _0x40032
                 ; 0002 0148                    for(k=0;k<10;k++){//[settings]
                +
00fb04 e040     +LDI R20 , LOW ( 0 )
00fb05 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 _0x40034:
                +
00fb06 304a     +CPI R20 , LOW ( 10 )
00fb07 e0e0     +LDI R30 , HIGH ( 10 )
00fb08 075e     +CPC R21 , R30
                 	__CPWRN 20,21,10
00fb09 f4d8      	BRSH _0x40035
                 ; 0002 0149                         rollbuf[k]=(sdBuf[k]<<1)|(sdBuf[k]>>7);  //ROL
00fb0a 01fa      	MOVW R30,R20
00fb0b 01de      	MOVW R26,R28
00fb0c 0fea      	ADD  R30,R26
00fb0d 1ffb      	ADC  R31,R27
00fb0e 01bf      	MOVW R22,R30
00fb0f e2a3      	LDI  R26,LOW(_sdBuf)
00fb10 e0b9      	LDI  R27,HIGH(_sdBuf)
00fb11 0fa4      	ADD  R26,R20
00fb12 1fb5      	ADC  R27,R21
00fb13 91ec      	LD   R30,X
00fb14 0fee      	LSL  R30
00fb15 2e0e      	MOV  R0,R30
00fb16 e2a3      	LDI  R26,LOW(_sdBuf)
00fb17 e0b9      	LDI  R27,HIGH(_sdBuf)
00fb18 0fa4      	ADD  R26,R20
00fb19 1fb5      	ADC  R27,R21
00fb1a 940e fe9f 	CALL SUBOPT_0x14
                 ; 0002 014A                         rollbuf[k]^=j;  //XOR   j=roll
00fb1c 01de      	MOVW R26,R28
00fb1d 0fa4      	ADD  R26,R20
00fb1e 1fb5      	ADC  R27,R21
00fb1f 91ec      	LD   R30,X
00fb20 27e2      	EOR  R30,R18
00fb21 93ec      	ST   X,R30
                 ; 0002 014B                    }
                +
00fb22 5f4f     +SUBI R20 , LOW ( - 1 )
00fb23 4f5f     +SBCI R21 , HIGH ( - 1 )
                 	__ADDWRN 20,21,1
00fb24 cfe1      	RJMP _0x40034
                 _0x40035:
                 ; 0002 014C                }
                 ; 0002 014D                result[1]=compbuf("[settings]",&rollbuf[0]);
                 _0x40032:
                +
00fb25 e1e3     +LDI R30 , LOW ( _0x4000E + ( 19 ) )
00fb26 e0f9     +LDI R31 , HIGH ( _0x4000E + ( 19 ) )
                 	__POINTW1MN _0x4000E,19
00fb27 93fa      	ST   -Y,R31
00fb28 93ea      	ST   -Y,R30
00fb29 01de      	MOVW R26,R28
00fb2a 9612      	ADIW R26,2
00fb2b d0fd      	RCALL _compbuf
                +
00fb2c 93e0 091f+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
                 ; 0002 014E                if(result[1]!=0){
                +
00fb2e 91e0 091f+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fb30 30e0      	CPI  R30,0
00fb31 f011      	BREQ _0x40036
                 ; 0002 014F                     rollnum=j;
                +
00fb32 872b     +STD Y + 11 , R18
                 	__PUTBSR 18,11
                 ; 0002 0150                     #ifdef DEBUG_LCD
                 ; 0002 0151                       lcd_clear();
                 ; 0002 0152                       lcd_putsf("roll ");
                 ; 0002 0153                       lcd_printhex(rollnum,sizeof(rollnum));
                 ; 0002 0154                       delay_ms(1000);
                 ; 0002 0155                     #endif
                 ; 0002 0156                     break;
00fb33 c003      	RJMP _0x40031
                 ; 0002 0157                }
                 ; 0002 0158             }
                 _0x40036:
                +
00fb34 5f2f     +SUBI R18 , LOW ( - 1 )
00fb35 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fb36 cfc5      	RJMP _0x40030
                 _0x40031:
                 ; 0002 0159             if(result[1]==0){//roll didn't found
                 ; 0002 015A                 #ifdef DEBUG_ERRSD
                 ; 0002 015B                 errorSD(9);
                 ; 0002 015C                 #endif
                 ; 0002 015D                 //return;
                 ; 0002 015E             }
                 ; 0002 015F         }
                 ; 0002 0160 
                 ; 0002 0161         for(j=0;j<512;j++)
                 _0x4002E:
                +
00fb37 e020     +LDI R18 , LOW ( 0 )
00fb38 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40039:
                +
00fb39 3020     +CPI R18 , LOW ( 512 )
00fb3a e0e2     +LDI R30 , HIGH ( 512 )
00fb3b 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fb3c f550      	BRSH _0x4003A
                 ; 0002 0162         {
                 ; 0002 0163             if(rollnum!=0){
00fb3d 85eb      	LDD  R30,Y+11
00fb3e 30e0      	CPI  R30,0
00fb3f f0b1      	BREQ _0x4003B
                 ; 0002 0164                 sdBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
00fb40 01f9      	MOVW R30,R18
00fb41 5ded      	SUBI R30,LOW(-_sdBuf)
00fb42 4ff6      	SBCI R31,HIGH(-_sdBuf)
00fb43 01bf      	MOVW R22,R30
00fb44 940e fea7 	CALL SUBOPT_0x15
00fb46 91ec      	LD   R30,X
00fb47 0fee      	LSL  R30
00fb48 2e0e      	MOV  R0,R30
00fb49 940e fea7 	CALL SUBOPT_0x15
00fb4b 940e fe9f 	CALL SUBOPT_0x14
                 ; 0002 0165                 sdBuf[j]^=rollnum;//0x88;  //XOR
00fb4d 01f9      	MOVW R30,R18
00fb4e 5ded      	SUBI R30,LOW(-_sdBuf)
00fb4f 4ff6      	SBCI R31,HIGH(-_sdBuf)
00fb50 010f      	MOVW R0,R30
00fb51 81e0      	LD   R30,Z
00fb52 85ab      	LDD  R26,Y+11
00fb53 27ea      	EOR  R30,R26
00fb54 01d0      	MOVW R26,R0
00fb55 93ec      	ST   X,R30
                 ; 0002 0166             }
                 ; 0002 0167             checksumCnt+=sdBuf[j];
                 _0x4003B:
00fb56 940e fea7 	CALL SUBOPT_0x15
00fb58 91ec      	LD   R30,X
00fb59 e0f0      	LDI  R31,0
00fb5a 91a0 0b49 	LDS  R26,_checksumCnt
00fb5c 91b0 0b4a 	LDS  R27,_checksumCnt+1
00fb5e 0fea      	ADD  R30,R26
00fb5f 1ffb      	ADC  R31,R27
00fb60 93e0 0b49 	STS  _checksumCnt,R30
00fb62 93f0 0b4a 	STS  _checksumCnt+1,R31
                 ; 0002 0168         }
                +
00fb64 5f2f     +SUBI R18 , LOW ( - 1 )
00fb65 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fb66 cfd2      	RJMP _0x40039
                 _0x4003A:
                 ; 0002 0169         readbytes+=512;
00fb67 91e0 0b43 	LDS  R30,_readbytes
00fb69 91f0 0b44 	LDS  R31,_readbytes+1
00fb6b 9160 0b45 	LDS  R22,_readbytes+2
00fb6d 9170 0b46 	LDS  R23,_readbytes+3
                +
00fb6f 50e0     +SUBI R30 , LOW ( - 512 )
00fb70 4ffe     +SBCI R31 , HIGH ( - 512 )
00fb71 4f6f     +SBCI R22 , BYTE3 ( - 512 )
00fb72 4f7f     +SBCI R23 , BYTE4 ( - 512 )
                 	__ADDD1N 512
00fb73 93e0 0b43 	STS  _readbytes,R30
00fb75 93f0 0b44 	STS  _readbytes+1,R31
00fb77 9360 0b45 	STS  _readbytes+2,R22
00fb79 9370 0b46 	STS  _readbytes+3,R23
                 ; 0002 016A         //read app data
                 ; 0002 016B         if(readbytes>2048)
00fb7b 940e fe96 	CALL SUBOPT_0x13
                +
00fb7d 30a1     +CPI R26 , LOW ( 0x801 )
00fb7e e0e8     +LDI R30 , HIGH ( 0x801 )
00fb7f 07be     +CPC R27 , R30
00fb80 e0e0     +LDI R30 , BYTE3 ( 0x801 )
00fb81 078e     +CPC R24 , R30
00fb82 e0e0     +LDI R30 , BYTE4 ( 0x801 )
00fb83 079e     +CPC R25 , R30
                 	__CPD2N 0x801
00fb84 f168      	BRLO _0x4003C
                 ; 0002 016C         {
                 ; 0002 016D            for(pagesCnt=0;pagesCnt<PAGES_PER_SDBUF;pagesCnt++)
00fb85 24bb      	CLR  R11
                 _0x4003E:
00fb86 e0e2      	LDI  R30,LOW(2)
00fb87 16be      	CP   R11,R30
00fb88 f540      	BRSH _0x4003F
                 ; 0002 016E            {
                 ; 0002 016F                #ifdef DEBUG_LCD
                 ; 0002 0170                   lcd_clear();
                 ; 0002 0171                   lcd_putsf("appage ");
                 ; 0002 0172                   lcd_printhex(appPages,sizeof(appPages));
                 ; 0002 0173                   delay_ms(1000);
                 ; 0002 0174                   lcd_clear();
                 ; 0002 0175                   lcd_putsf("apstrt ");
                 ; 0002 0176                   lcd_printhex(appStartAdr,sizeof(appStartAdr));
                 ; 0002 0177                   delay_ms(1000);
                 ; 0002 0178                 #endif
                 ; 0002 0179                #asm("wdr")
00fb89 95a8      	wdr
                 ; 0002 017A                if(WriteFlashPage(appStartAdr, &sdBuf[pagesCnt*PAGESIZE])==0)
00fb8a 940e feac 	CALL SUBOPT_0x16
00fb8c 940e ffcc 	CALL __PUTPARD1
00fb8e 2dab      	MOV  R26,R11
00fb8f e0b0      	LDI  R27,0
00fb90 e0e0      	LDI  R30,LOW(256)
00fb91 e0f1      	LDI  R31,HIGH(256)
00fb92 940e ff7b 	CALL __MULW12
00fb94 5ded      	SUBI R30,LOW(-_sdBuf)
00fb95 4ff6      	SBCI R31,HIGH(-_sdBuf)
00fb96 01df      	MOVW R26,R30
00fb97 940e f89e 	CALL _WriteFlashPage
00fb99 30e0      	CPI  R30,0
00fb9a f409      	BRNE _0x40040
                 ; 0002 017B                {
                 ; 0002 017C                     //after error during flash write page. wait for watchdog to reset
                 ; 0002 017D                     #ifdef DEBUGLED
                 ; 0002 017E                     do
                 ; 0002 017F                     {
                 ; 0002 0180                       PORTC.6=0;
                 ; 0002 0181                       delay_ms(500);
                 ; 0002 0182                       PORTC.6=1;
                 ; 0002 0183                       delay_ms(500);
                 ; 0002 0184                     }
                 ; 0002 0185                     #endif
                 ; 0002 0186                     while(1);
                 _0x40041:
00fb9b cfff      	RJMP _0x40041
                 ; 0002 0187                }
                 ; 0002 0188                appStartAdr+=PAGESIZE;
                 _0x40040:
00fb9c 940e feac 	CALL SUBOPT_0x16
                +
00fb9e 50e0     +SUBI R30 , LOW ( - 256 )
00fb9f 4fff     +SBCI R31 , HIGH ( - 256 )
00fba0 4f6f     +SBCI R22 , BYTE3 ( - 256 )
00fba1 4f7f     +SBCI R23 , BYTE4 ( - 256 )
                 	__ADDD1N 256
00fba2 940e feb5 	CALL SUBOPT_0x17
                 ; 0002 0189                appPages--;
00fba4 01f6      	MOVW R30,R12
00fba5 9731      	SBIW R30,1
00fba6 016f      	MOVW R12,R30
                 ; 0002 018A                if(appPages==0)
00fba7 2c0c      	MOV  R0,R12
00fba8 280d      	OR   R0,R13
00fba9 f429      	BRNE _0x40044
                 ; 0002 018B                {
                 ; 0002 018C                     #ifdef DEBUG_LCD
                 ; 0002 018D                       lcd_clear();
                 ; 0002 018E                       lcd_putsf("jump to app");
                 ; 0002 018F                       delay_ms(2000);
                 ; 0002 0190                     #endif
                 ; 0002 0191                     app_pointer();//go to app address 0
                +
00fbaa 91e0 0b4d+LDS R30 , _app_pointer + ( 0 )
00fbac 91f0 0b4e+LDS R31 , _app_pointer + ( 0 ) + 1
00fbae 9509     +ICALL
                 	__CALL1MN _app_pointer,0
                 ; 0002 0192                     /*
                 ; 0002 0193                     do
                 ; 0002 0194                     {
                 ; 0002 0195                       #ifdef DEBUGLED
                 ; 0002 0196                       PORTC.5=0;
                 ; 0002 0197                       delay_ms(500);
                 ; 0002 0198                       PORTC.5=1;
                 ; 0002 0199                       delay_ms(500);
                 ; 0002 019A                       #endif
                 ; 0002 019B                     }while(1);
                 ; 0002 019C                     */
                 ; 0002 019D                }
                 ; 0002 019E            }
                 _0x40044:
00fbaf 94b3      	INC  R11
00fbb0 cfd5      	RJMP _0x4003E
                 _0x4003F:
                 ; 0002 019F         }
                 ; 0002 01A0         //read app start adr, num of pages, checksum
                 ; 0002 01A1         else if(readbytes>=2000){//Offset=512-48=464
00fbb1 c048      	RJMP _0x40045
                 _0x4003C:
00fbb2 940e fe96 	CALL SUBOPT_0x13
                +
00fbb4 3da0     +CPI R26 , LOW ( 0x7D0 )
00fbb5 e0e7     +LDI R30 , HIGH ( 0x7D0 )
00fbb6 07be     +CPC R27 , R30
00fbb7 e0e0     +LDI R30 , BYTE3 ( 0x7D0 )
00fbb8 078e     +CPC R24 , R30
00fbb9 e0e0     +LDI R30 , BYTE4 ( 0x7D0 )
00fbba 079e     +CPC R25 , R30
                 	__CPD2N 0x7D0
00fbbb f1f0      	BRLO _0x40046
                 ; 0002 01A2            appStartAdr=(unsigned long)sdBuf[464]<<16;
                +
00fbbc 91e0 0af3+LDS R30 , _sdBuf + ( 464 )
                 	__GETB1MN _sdBuf,464
00fbbe e0f0      	LDI  R31,0
00fbbf 940e ff48 	CALL __CWD1
00fbc1 940e ff43 	CALL __LSLD16
00fbc3 940e feb5 	CALL SUBOPT_0x17
                 ; 0002 01A3            appStartAdr|=(unsigned long)sdBuf[465]<<8;
                +
00fbc5 91e0 0af4+LDS R30 , _sdBuf + ( 465 )
                 	__GETB1MN _sdBuf,465
00fbc7 e0f0      	LDI  R31,0
00fbc8 940e ff48 	CALL __CWD1
00fbca 01df      	MOVW R26,R30
00fbcb 01cb      	MOVW R24,R22
00fbcc e0e8      	LDI  R30,LOW(8)
00fbcd 940e ff21 	CALL __LSLD12
00fbcf 940e febe 	CALL SUBOPT_0x18
                 ; 0002 01A4            appStartAdr|=(unsigned long)sdBuf[466];
                +
00fbd1 91e0 0af5+LDS R30 , _sdBuf + ( 466 )
                 	__GETB1MN _sdBuf,466
00fbd3 e0f0      	LDI  R31,0
00fbd4 940e ff48 	CALL __CWD1
00fbd6 940e febe 	CALL SUBOPT_0x18
                 ; 0002 01A5            appPages=(unsigned int)sdBuf[467]<<8;
                +
00fbd8 91f0 0af6+LDS R31 , _sdBuf + ( 467 )
                 	__GETBRMN 31,_sdBuf,467
00fbda e0e0      	LDI  R30,LOW(0)
00fbdb 016f      	MOVW R12,R30
                 ; 0002 01A6            appPages|=(unsigned int)sdBuf[468];
                +
00fbdc 91e0 0af7+LDS R30 , _sdBuf + ( 468 )
                 	__GETB1MN _sdBuf,468
00fbde e0f0      	LDI  R31,0
                +
00fbdf 2ace     +OR R12 , R30
00fbe0 2adf     +OR R13 , R31
                 	__ORWRR 12,13,30,31
                 ; 0002 01A7            bytesChecksum=(unsigned int)sdBuf[469]<<8;
                +
00fbe1 91f0 0af8+LDS R31 , _sdBuf + ( 469 )
                 	__GETBRMN 31,_sdBuf,469
00fbe3 e0e0      	LDI  R30,LOW(0)
00fbe4 93e0 0b47 	STS  _bytesChecksum,R30
00fbe6 93f0 0b48 	STS  _bytesChecksum+1,R31
                 ; 0002 01A8            bytesChecksum|=(unsigned int)sdBuf[470];
                +
00fbe8 91e0 0af9+LDS R30 , _sdBuf + ( 470 )
                 	__GETB1MN _sdBuf,470
00fbea e0f0      	LDI  R31,0
00fbeb 91a0 0b47 	LDS  R26,_bytesChecksum
00fbed 91b0 0b48 	LDS  R27,_bytesChecksum+1
00fbef 2bea      	OR   R30,R26
00fbf0 2bfb      	OR   R31,R27
00fbf1 93e0 0b47 	STS  _bytesChecksum,R30
00fbf3 93f0 0b48 	STS  _bytesChecksum+1,R31
                 ; 0002 01A9            checksumCnt=0;
00fbf5 e0e0      	LDI  R30,LOW(0)
00fbf6 93e0 0b49 	STS  _checksumCnt,R30
00fbf8 93e0 0b4a 	STS  _checksumCnt+1,R30
                 ; 0002 01AA            #ifdef DEBUG_LCD
                 ; 0002 01AB               lcd_clear();
                 ; 0002 01AC               lcd_putsf("appags ");
                 ; 0002 01AD               lcd_printhex(appPages,sizeof(appPages));
                 ; 0002 01AE               delay_ms(500);
                 ; 0002 01AF             #endif
                 ; 0002 01B0         }
                 ; 0002 01B1         if(fat_file_next_adr == 0x0FFFFFFFUL){
                 _0x40046:
                 _0x40045:
00fbfa 91a0 0b3b 	LDS  R26,_fat_file_next_adr
00fbfc 91b0 0b3c 	LDS  R27,_fat_file_next_adr+1
00fbfe 9180 0b3d 	LDS  R24,_fat_file_next_adr+2
00fc00 9190 0b3e 	LDS  R25,_fat_file_next_adr+3
00fc02 940e fe8e 	CALL SUBOPT_0x12
00fc04 f469      	BRNE _0x40047
                 ; 0002 01B2 
                 ; 0002 01B3 
                 ; 0002 01B4             if(readbytes >= filesize){
00fc05 91e0 0b3f 	LDS  R30,_filesize
00fc07 91f0 0b40 	LDS  R31,_filesize+1
00fc09 9160 0b41 	LDS  R22,_filesize+2
00fc0b 9170 0b42 	LDS  R23,_filesize+3
00fc0d 940e fe96 	CALL SUBOPT_0x13
00fc0f 940e ffda 	CALL __CPD21
00fc11 f420      	BRSH _0x4002C
                 ; 0002 01B5                 break;
                 ; 0002 01B6             }
                 ; 0002 01B7             else
                 ; 0002 01B8             {
                 ; 0002 01B9                 /*
                 ; 0002 01BA                 if(  WriteFlashPage(0x1EF00, sdBuf)){//;     // Writes testbuffer1 to Flash page 2
                 ; 0002 01BB                     #ifdef DEBUGLED
                 ; 0002 01BC                     PORTC.5=0;
                 ; 0002 01BD                     #endif
                 ; 0002 01BE                 }                                          // Function returns TRUE
                 ; 0002 01BF                 if(  ReadFlashPage (0x1EF00, testBuf)){//;      // Reads back Flash page 2 to TestBuffer2
                 ; 0002 01C0                     #ifdef DEBUGLED
                 ; 0002 01C1                     PORTC.6=0;
                 ; 0002 01C2                     #endif
                 ; 0002 01C3                 }
                 ; 0002 01C4                 */
                 ; 0002 01C5             }
                 ; 0002 01C6 
                 ; 0002 01C7         }
                 ; 0002 01C8         adr++;
                 _0x40047:
00fc12 d24d      	RCALL SUBOPT_0xF
                 ; 0002 01C9     }
                +
00fc13 5f0f     +SUBI R16 , LOW ( - 1 )
00fc14 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fc15 ced3      	RJMP _0x4002B
                 _0x4002C:
                 ; 0002 01CA     fat_file_adr = fat_file_next_adr;
00fc16 91e0 0b3b 	LDS  R30,_fat_file_next_adr
00fc18 91f0 0b3c 	LDS  R31,_fat_file_next_adr+1
00fc1a 9160 0b3d 	LDS  R22,_fat_file_next_adr+2
00fc1c 9170 0b3e 	LDS  R23,_fat_file_next_adr+3
00fc1e 93e0 0b37 	STS  _fat_file_adr,R30
00fc20 93f0 0b38 	STS  _fat_file_adr+1,R31
00fc22 9360 0b39 	STS  _fat_file_adr+2,R22
00fc24 9370 0b3a 	STS  _fat_file_adr+3,R23
                 ; 0002 01CB   }
00fc26 ce87      	RJMP _0x40023
                 _0x40025:
                 ; 0002 01CC   while(1);
                 _0x4004A:
00fc27 cfff      	RJMP _0x4004A
                 ; 0002 01CD }
                 _0x4004D:
00fc28 cfff      	RJMP _0x4004D
                 ; .FEND
                 
                 	.DSEG
                 _0x4000E:
000900           	.BYTE 0x1E
                 ;
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest)
                 ; 0002 01D0 {
                 
                 	.CSEG
                 _compbuf:
                 ; .FSTART _compbuf
                 ; 0002 01D1     while(*src)
00fc29 93ba      	ST   -Y,R27
00fc2a 93aa      	ST   -Y,R26
                 ;	*src -> Y+2
                 ;	*dest -> Y+0
                 _0x4004E:
00fc2b 81aa      	LDD  R26,Y+2
00fc2c 81bb      	LDD  R27,Y+2+1
00fc2d 91ec      	LD   R30,X
00fc2e 30e0      	CPI  R30,0
00fc2f f069      	BREQ _0x40050
                 ; 0002 01D2     {
                 ; 0002 01D3         if(*src++ != *dest++)
00fc30 900d      	LD   R0,X+
00fc31 83aa      	STD  Y+2,R26
00fc32 83bb      	STD  Y+2+1,R27
00fc33 81a8      	LD   R26,Y
00fc34 81b9      	LDD  R27,Y+1
00fc35 91ed      	LD   R30,X+
00fc36 83a8      	ST   Y,R26
00fc37 83b9      	STD  Y+1,R27
00fc38 15e0      	CP   R30,R0
00fc39 f011      	BREQ _0x40051
                 ; 0002 01D4             return 0;
00fc3a e0e0      	LDI  R30,LOW(0)
00fc3b c080      	RJMP _0x200000A
                 ; 0002 01D5         //src++;dest++;
                 ; 0002 01D6         //len--;
                 ; 0002 01D7     }
                 _0x40051:
00fc3c cfee      	RJMP _0x4004E
                 _0x40050:
                 ; 0002 01D8     return 1;
00fc3d e0e1      	LDI  R30,LOW(1)
00fc3e c07d      	RJMP _0x200000A
                 ; 0002 01D9 }
                 ; .FEND
                 ;
                 ;#ifdef DEBUG_ERRSD
                 ;void errorSD(unsigned char err)
                 ;{
                 ;#ifdef DEBUGLED
                 ;    unsigned int repeat=10;
                 ;    do{
                 ;       PORTC &= ~(1<<err);
                 ;       delay_ms(500);
                 ;       PORTC = 0xFF;
                 ;       delay_ms(500);
                 ;    }
                 ;    while(repeat--);
                 ;#endif
                 ;#ifdef DEBUG_LCD
                 ;  char strnum[5];
                 ;    if(err>100){
                 ;       err=100;
                 ;    }
                 ;    itoa(err,strnum);
                 ;    lcd_gotoxy(0,0);
                 ;    lcd_putsf("SD ERROR: ");
                 ;    lcd_puts(strnum);
                 ;    while(1);
                 ;#else
                 ;    app_pointer();
                 ;#endif
                 ;    //while(1);
                 ;}
                 ;#endif
                 ;
                 ;//convert bytes buffer to 32bit UL value
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len)
                 ; 0002 01FB {
                 _buf2num:
                 ; .FSTART _buf2num
                 ; 0002 01FC     unsigned long num=0;
                 ; 0002 01FD     //unsigned char i;
                 ; 0002 01FE     /*
                 ; 0002 01FF     if(len>4){
                 ; 0002 0200        len=4;// 4bytes max 32bit UL
                 ; 0002 0201     }
                 ; 0002 0202     */
                 ; 0002 0203     for(;((len>0));len--)
00fc3f 93aa      	ST   -Y,R26
00fc40 9724      	SBIW R28,4
00fc41 e0e0      	LDI  R30,LOW(0)
00fc42 83e8      	ST   Y,R30
00fc43 83e9      	STD  Y+1,R30
00fc44 83ea      	STD  Y+2,R30
00fc45 83eb      	STD  Y+3,R30
                 ;	*buf -> Y+5
                 ;	len -> Y+4
                 ;	num -> Y+0
                 _0x40053:
00fc46 81ac      	LDD  R26,Y+4
00fc47 30a1      	CPI  R26,LOW(0x1)
00fc48 f0d0      	BRLO _0x40054
                 ; 0002 0204     {
                 ; 0002 0205         num<<=8;
00fc49 d1a1      	RCALL SUBOPT_0x4
00fc4a e0e8      	LDI  R30,LOW(8)
00fc4b 940e ff21 	CALL __LSLD12
00fc4d 940e ffc7 	CALL __PUTD1S0
                 ; 0002 0206         num|=buf[len-1];
00fc4f 81ec      	LDD  R30,Y+4
00fc50 e0f0      	LDI  R31,0
00fc51 9731      	SBIW R30,1
00fc52 81ad      	LDD  R26,Y+5
00fc53 81be      	LDD  R27,Y+5+1
00fc54 0fae      	ADD  R26,R30
00fc55 1fbf      	ADC  R27,R31
00fc56 91ec      	LD   R30,X
00fc57 d193      	RCALL SUBOPT_0x4
00fc58 27ff      	CLR  R31
00fc59 2766      	CLR  R22
00fc5a 2777      	CLR  R23
00fc5b 940e ff18 	CALL __ORD12
00fc5d 940e ffc7 	CALL __PUTD1S0
                 ; 0002 0207     }
00fc5f 81ec      	LDD  R30,Y+4
00fc60 50e1      	SUBI R30,LOW(1)
00fc61 83ec      	STD  Y+4,R30
00fc62 cfe3      	RJMP _0x40053
                 _0x40054:
                 ; 0002 0208     return num;
00fc63 940e ffbd 	CALL __GETD1S0
00fc65 9627      	ADIW R28,7
00fc66 9508      	RET
                 ; 0002 0209 }
                 ; .FEND
                 ;
                 ;
                 ;#ifdef DEBUG_LCD
                 ;lcd_printhex(unsigned long num32, char size){
                 ;    char i,nible;
                 ;    //num32>>=((4-size)*8);//0x12345678 >>24 -> 0x00000012
                 ;    //lcd_putchar(size+'0');
                 ;    for(i=1;i<=(size*2);i++){
                 ;        nible=((num32)>>(32-((4-size)*8)-((i)*4)))&0x0F;
                 ;        if(nible>9){
                 ;          nible-=0x0A;
                 ;          nible+='A';
                 ;        }
                 ;        else{
                 ;          nible+='0';
                 ;        }
                 ;        lcd_putchar(nible);
                 ;    }
                 ;}
                 ;#endif
                 ;#include "spi_sdcard.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;
                 ;
                 ;
                 ;void SPI_init()
                 ; 0003 0007 {
                 
                 	.CSEG
                 _SPI_init:
                 ; .FSTART _SPI_init
                 ; 0003 0008     // set CS, MOSI and SCK to output
                 ; 0003 0009     DDR_SPI = (1 << CS) | (1 << MOSI) | (1 << SCK);
00fc67 e0e7      	LDI  R30,LOW(7)
00fc68 bbe7      	OUT  0x17,R30
                 ; 0003 000A     PORT_SPI|=(1 << CS);
00fc69 9ac0      	SBI  0x18,0
                 ; 0003 000B     // enable pull up resistor in MISO
                 ; 0003 000C     DDR_SPI &= ~(1 << MISO);
00fc6a 98bb      	CBI  0x17,3
                 ; 0003 000D     PORT_SPI &= ~(1 << MISO);
00fc6b 98c3      	CBI  0x18,3
                 ; 0003 000E     //PORT_SPI |= (1 << MISO);
                 ; 0003 000F 
                 ; 0003 0010     // enable SPI, set as master, and clock to fosc/128
                 ; 0003 0011     SPCR = (1 << SPE) | (1 << MSTR) | (0 << SPR1) | (0 << SPR0);
00fc6c e5e0      	LDI  R30,LOW(80)
00fc6d b9ed      	OUT  0xD,R30
                 ; 0003 0012 }
00fc6e 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SPI_transfer(unsigned char data)
                 ; 0003 0015 {
                 _SPI_transfer:
                 ; .FSTART _SPI_transfer
                 ; 0003 0016     // load data into register
                 ; 0003 0017     SPDR = data;
00fc6f 93aa      	ST   -Y,R26
                 ;	data -> Y+0
00fc70 81e8      	LD   R30,Y
00fc71 b9ef      	OUT  0xF,R30
                 ; 0003 0018 
                 ; 0003 0019     // Wait for transmission complete
                 ; 0003 001A     while(!(SPSR & (1 << SPIF)));
                 _0x60003:
00fc72 9b77      	SBIS 0xE,7
00fc73 cffe      	RJMP _0x60003
                 ; 0003 001B 
                 ; 0003 001C     // return SPDR
                 ; 0003 001D     return SPDR;
00fc74 b1ef      	IN   R30,0xF
00fc75 9621      	ADIW R28,1
00fc76 9508      	RET
                 ; 0003 001E }
                 ; .FEND
                 ;
                 ;
                 ;void SD_powerUpSeq()
                 ; 0003 0022 {
                 _SD_powerUpSeq:
                 ; .FSTART _SD_powerUpSeq
                 ; 0003 0023     unsigned char i;
                 ; 0003 0024 
                 ; 0003 0025     SPI_init();
00fc77 931a      	ST   -Y,R17
                 ;	i -> R17
00fc78 dfee      	RCALL _SPI_init
                 ; 0003 0026 
                 ; 0003 0027     // make sure card is deselected
                 ; 0003 0028     CS_DISABLE();
00fc79 9ac0      	SBI  0x18,0
                 ; 0003 0029 
                 ; 0003 002A     // give SD card time to power up
                 ; 0003 002B     delay_ms(1);
00fc7a e0a1      	LDI  R26,LOW(1)
00fc7b e0b0      	LDI  R27,0
00fc7c 940e ff09 	CALL _delay_ms
                 ; 0003 002C 
                 ; 0003 002D     // send 80 clock cycles to synchronize
                 ; 0003 002E     for(i = 0; i < 10; i++)
00fc7e e010      	LDI  R17,LOW(0)
                 _0x60007:
00fc7f 301a      	CPI  R17,10
00fc80 f420      	BRSH _0x60008
                 ; 0003 002F         SPI_transfer(0xFF);
00fc81 efaf      	LDI  R26,LOW(255)
00fc82 dfec      	RCALL _SPI_transfer
00fc83 5f1f      	SUBI R17,-1
00fc84 cffa      	RJMP _0x60007
                 _0x60008:
                 ; 0003 0032 PORTB |= (1 << 0       );
00fc85 d243      	RCALL SUBOPT_0x19
                 ; 0003 0033     SPI_transfer(0xFF);
                 ; 0003 0034 }
00fc86 c08b      	RJMP _0x2000007
                 ; .FEND
                 ;
                 ;unsigned char SD_command(unsigned char cmd, unsigned long arg, unsigned char crc)
                 ; 0003 0037 {
                 _SD_command:
                 ; .FSTART _SD_command
                 ; 0003 0038     unsigned char res,count;
                 ; 0003 0039     // transmit command to sd card
                 ; 0003 003A     SPI_transfer(cmd|0x40);
00fc87 93aa      	ST   -Y,R26
00fc88 931a      	ST   -Y,R17
00fc89 930a      	ST   -Y,R16
                 ;	cmd -> Y+7
                 ;	arg -> Y+3
                 ;	crc -> Y+2
                 ;	res -> R17
                 ;	count -> R16
00fc8a 81ef      	LDD  R30,Y+7
00fc8b 64e0      	ORI  R30,0x40
00fc8c d23f      	RCALL SUBOPT_0x1A
                 ; 0003 003B 
                 ; 0003 003C     // transmit argument
                 ; 0003 003D     SPI_transfer((unsigned char)(arg >> 24));
00fc8d e1e8      	LDI  R30,LOW(24)
00fc8e 940e ff2d 	CALL __LSRD12
00fc90 2fae      	MOV  R26,R30
00fc91 dfdd      	RCALL _SPI_transfer
                 ; 0003 003E     SPI_transfer((unsigned char)(arg >> 16));
                +
00fc92 81eb     +LDD R30 , Y + 3
00fc93 81fc     +LDD R31 , Y + 3 + 1
00fc94 816d     +LDD R22 , Y + 3 + 2
00fc95 817e     +LDD R23 , Y + 3 + 3
                 	__GETD1S 3
00fc96 940e ff3e 	CALL __LSRD16
00fc98 d233      	RCALL SUBOPT_0x1A
                 ; 0003 003F     SPI_transfer((unsigned char)(arg >> 8));
00fc99 e0e8      	LDI  R30,LOW(8)
00fc9a 940e ff2d 	CALL __LSRD12
00fc9c 2fae      	MOV  R26,R30
00fc9d dfd1      	RCALL _SPI_transfer
                 ; 0003 0040     SPI_transfer((unsigned char)(arg));
00fc9e 81ab      	LDD  R26,Y+3
00fc9f dfcf      	RCALL _SPI_transfer
                 ; 0003 0041 
                 ; 0003 0042     // transmit crc
                 ; 0003 0043     SPI_transfer(crc|0x01);
00fca0 81ea      	LDD  R30,Y+2
00fca1 60e1      	ORI  R30,1
00fca2 2fae      	MOV  R26,R30
00fca3 dfcb      	RCALL _SPI_transfer
                 ; 0003 0044 
                 ; 0003 0045     //wait response R1
                 ; 0003 0046     res = SD_readRes1();
00fca4 d005      	RCALL _SD_readRes1
00fca5 2f1e      	MOV  R17,R30
                 ; 0003 0047     /*
                 ; 0003 0048     do {
                 ; 0003 0049      res=SPI_transfer(0xFF);;
                 ; 0003 004A      count++;
                 ; 0003 004B     } while ( ((res&0x80)!=0x00)&&(count<0xff) );
                 ; 0003 004C     */
                 ; 0003 004D     return res;
00fca6 8119      	LDD  R17,Y+1
00fca7 8108      	LDD  R16,Y+0
00fca8 9628      	ADIW R28,8
00fca9 9508      	RET
                 ; 0003 004E }
                 ; .FEND
                 ;
                 ;
                 ;unsigned char SD_readRes1()
                 ; 0003 0052 {
                 _SD_readRes1:
                 ; .FSTART _SD_readRes1
                 ; 0003 0053     unsigned char res1;
                 ; 0003 0054     unsigned int i = 0;
                 ; 0003 0055 
                 ; 0003 0056     // keep polling until actual data received
                 ; 0003 0057     //while((res1 = SPI_transfer(0xFF)) == 0xFF)
                 ; 0003 0058     while(((res1 = SPI_transfer(0xFF))&0x80) != 0x00)
00fcaa 940e ffe1 	CALL __SAVELOCR4
                 ;	res1 -> R17
                 ;	i -> R18,R19
                +
00fcac e020     +LDI R18 , LOW ( 0 )
00fcad e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60009:
00fcae efaf      	LDI  R26,LOW(255)
00fcaf dfbf      	RCALL _SPI_transfer
00fcb0 2f1e      	MOV  R17,R30
00fcb1 78e0      	ANDI R30,LOW(0x80)
00fcb2 f031      	BREQ _0x6000B
                 ; 0003 0059     {
                 ; 0003 005A         i++;
                +
00fcb3 5f2f     +SUBI R18 , LOW ( - 1 )
00fcb4 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                 ; 0003 005B 
                 ; 0003 005C         // if no data received for (254)8 bytes, break
                 ; 0003 005D         if(i > 0x1FF) break;
                +
00fcb5 3020     +CPI R18 , LOW ( 512 )
00fcb6 e0e2     +LDI R30 , HIGH ( 512 )
00fcb7 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fcb8 f3a8      	BRLO _0x60009
                 ; 0003 005E     }
                 _0x6000B:
                 ; 0003 005F 
                 ; 0003 0060     return res1;
00fcb9 2fe1      	MOV  R30,R17
00fcba 940e ffe8 	CALL __LOADLOCR4
                 _0x200000A:
00fcbc 9624      	ADIW R28,4
00fcbd 9508      	RET
                 ; 0003 0061 }
                 ; .FEND
                 ;
                 ;unsigned char SD_goIdleState()
                 ; 0003 0064 {
                 _SD_goIdleState:
                 ; .FSTART _SD_goIdleState
                 ; 0003 0065     unsigned char res1;
                 ; 0003 0066     // assert chip select
                 ; 0003 0067     SPI_transfer(0xFF);
00fcbe d214      	RCALL SUBOPT_0x1B
                 ;	res1 -> R17
                 ; 0003 0068     CS_ENABLE();
                 ; 0003 0069     //SPI_transfer(0xFF);
                 ; 0003 006A 
                 ; 0003 006B     // send CMD0
                 ; 0003 006C     res1 = SD_command(CMD0, CMD0_ARG, CMD0_CRC);
00fcbf e0e0      	LDI  R30,LOW(0)
00fcc0 93ea      	ST   -Y,R30
00fcc1 d113      	RCALL SUBOPT_0x0
00fcc2 e9a4      	LDI  R26,LOW(148)
00fcc3 c04a      	RJMP _0x2000006
                 ; 0003 006D 
                 ; 0003 006E     // read response
                 ; 0003 006F     //res1 = SD_readRes1();
                 ; 0003 0070 
                 ; 0003 0071     // deassert chip select
                 ; 0003 0072     SPI_transfer(0xFF);
                 ; 0003 0073     CS_DISABLE();
                 ; 0003 0074     SPI_transfer(0xFF);
                 ; 0003 0075 
                 ; 0003 0076     return res1;
                 ; 0003 0077 }
                 ; .FEND
                 ;
                 ;void SD_readRes7(unsigned char *res)
                 ; 0003 007A {
                 _SD_readRes7:
                 ; .FSTART _SD_readRes7
                 ; 0003 007B     // read response 1 in R7
                 ; 0003 007C     //res[0] = SD_readRes1();
                 ; 0003 007D 
                 ; 0003 007E     // if error reading R1, return
                 ; 0003 007F     if(res[0] > 1) return;
00fcc4 93ba      	ST   -Y,R27
00fcc5 93aa      	ST   -Y,R26
                 ;	*res -> Y+0
00fcc6 81a8      	LD   R26,Y
00fcc7 81b9      	LDD  R27,Y+1
00fcc8 91ac      	LD   R26,X
00fcc9 30a2      	CPI  R26,LOW(0x2)
00fcca f578      	BRSH _0x2000009
                 ; 0003 0080 
                 ; 0003 0081     // read remaining bytes
                 ; 0003 0082     res[1] = SPI_transfer(0xFF);
00fccb efaf      	LDI  R26,LOW(255)
00fccc dfa2      	RCALL _SPI_transfer
                +
00fccd 81a8     +LDD R26 , Y + 0
00fcce 81b9     +LDD R27 , Y + 0 + 1
00fccf 9611     +ADIW R26 , 1
00fcd0 93ec     +ST X , R30
                 	__PUTB1SNS 0,1
                 ; 0003 0083     res[2] = SPI_transfer(0xFF);
00fcd1 efaf      	LDI  R26,LOW(255)
00fcd2 df9c      	RCALL _SPI_transfer
                +
00fcd3 81a8     +LDD R26 , Y + 0
00fcd4 81b9     +LDD R27 , Y + 0 + 1
00fcd5 9612     +ADIW R26 , 2
00fcd6 93ec     +ST X , R30
                 	__PUTB1SNS 0,2
                 ; 0003 0084     res[3] = SPI_transfer(0xFF);
00fcd7 efaf      	LDI  R26,LOW(255)
00fcd8 df96      	RCALL _SPI_transfer
                +
00fcd9 81a8     +LDD R26 , Y + 0
00fcda 81b9     +LDD R27 , Y + 0 + 1
00fcdb 9613     +ADIW R26 , 3
00fcdc 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
                 ; 0003 0085     res[4] = SPI_transfer(0xFF);
00fcdd efaf      	LDI  R26,LOW(255)
00fcde df90      	RCALL _SPI_transfer
                +
00fcdf 81a8     +LDD R26 , Y + 0
00fce0 81b9     +LDD R27 , Y + 0 + 1
00fce1 9614     +ADIW R26 , 4
00fce2 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
                 ; 0003 0086 }
00fce3 c016      	RJMP _0x2000009
                 ; .FEND
                 ;
                 ;void SD_sendIfCond(unsigned char *res)
                 ; 0003 0089 {
                 _SD_sendIfCond:
                 ; .FSTART _SD_sendIfCond
                 ; 0003 008A     // assert chip select
                 ; 0003 008B     SPI_transfer(0xFF);
00fce4 d1f3      	RCALL SUBOPT_0x1C
                 ;	*res -> Y+0
                 ; 0003 008C     CS_ENABLE();
                 ; 0003 008D     //SPI_transfer(0xFF);
                 ; 0003 008E 
                 ; 0003 008F     // send CMD8
                 ; 0003 0090     res[0]=SD_command(CMD8, CMD8_ARG, CMD8_CRC);
00fce5 e0e8      	LDI  R30,LOW(8)
00fce6 93ea      	ST   -Y,R30
                +
00fce7 eaea     +LDI R30 , LOW ( 0x1AA )
00fce8 e0f1     +LDI R31 , HIGH ( 0x1AA )
00fce9 e060     +LDI R22 , BYTE3 ( 0x1AA )
00fcea e070     +LDI R23 , BYTE4 ( 0x1AA )
                 	__GETD1N 0x1AA
00fceb 940e ffcc 	CALL __PUTPARD1
00fced e8a6      	LDI  R26,LOW(134)
00fcee c005      	RJMP _0x2000008
                 ; 0003 0091 
                 ; 0003 0092     // read response
                 ; 0003 0093     SD_readRes7(res);
                 ; 0003 0094 
                 ; 0003 0095     // deassert chip select
                 ; 0003 0096     SPI_transfer(0xFF);
                 ; 0003 0097     CS_DISABLE();
                 ; 0003 0098     SPI_transfer(0xFF);
                 ; 0003 0099 }
                 ; .FEND
                 ;
                 ;/*
                 ;void SD_readRes3_7(unsigned char *res)
                 ;{
                 ;    // read R1
                 ;    //res[0] = SD_readRes1();
                 ;
                 ;    // if error reading R1, return
                 ;    if(res[0] > 1) return;
                 ;
                 ;    // read remaining bytes
                 ;    res[1] = SPI_transfer(0xFF);
                 ;    res[2] = SPI_transfer(0xFF);
                 ;    res[3] = SPI_transfer(0xFF);
                 ;    res[4] = SPI_transfer(0xFF);
                 ;}
                 ;*/
                 ;
                 ;void SD_readOCR(unsigned char *res)
                 ; 0003 00AD {
                 _SD_readOCR:
                 ; .FSTART _SD_readOCR
                 ; 0003 00AE     // assert chip select
                 ; 0003 00AF     SPI_transfer(0xFF);
00fcef d1e8      	RCALL SUBOPT_0x1C
                 ;	*res -> Y+0
                 ; 0003 00B0     CS_ENABLE();
                 ; 0003 00B1     //SPI_transfer(0xFF);
                 ; 0003 00B2 
                 ; 0003 00B3     // send CMD58
                 ; 0003 00B4     res[0] = SD_command(CMD58, CMD58_ARG, CMD58_CRC);
00fcf0 e3ea      	LDI  R30,LOW(58)
00fcf1 93ea      	ST   -Y,R30
00fcf2 d0e2      	RCALL SUBOPT_0x0
00fcf3 e0a0      	LDI  R26,LOW(0)
                 _0x2000008:
00fcf4 df92      	RCALL _SD_command
00fcf5 81a8      	LD   R26,Y
00fcf6 81b9      	LDD  R27,Y+1
00fcf7 93ec      	ST   X,R30
                 ; 0003 00B5 
                 ; 0003 00B6     // read response
                 ; 0003 00B7     //SD_readRes3_7(res);
                 ; 0003 00B8     SD_readRes7(res);
00fcf8 dfcb      	RCALL _SD_readRes7
                 ; 0003 00B9 
                 ; 0003 00BA     // deassert chip select
                 ; 0003 00BB     SPI_transfer(0xFF);
00fcf9 d1e4      	RCALL SUBOPT_0x1D
                 ; 0003 00BC     CS_DISABLE();
                 ; 0003 00BD     SPI_transfer(0xFF);
                 ; 0003 00BE }
                 _0x2000009:
00fcfa 9622      	ADIW R28,2
00fcfb 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SD_sendApp()
                 ; 0003 00C1 {
                 _SD_sendApp:
                 ; .FSTART _SD_sendApp
                 ; 0003 00C2     unsigned char res1;
                 ; 0003 00C3     // assert chip select
                 ; 0003 00C4     SPI_transfer(0xFF);
00fcfc d1d6      	RCALL SUBOPT_0x1B
                 ;	res1 -> R17
                 ; 0003 00C5     CS_ENABLE();
                 ; 0003 00C6     //SPI_transfer(0xFF);
                 ; 0003 00C7 
                 ; 0003 00C8     // send CMD0
                 ; 0003 00C9     res1 = SD_command(CMD55, CMD55_ARG, CMD55_CRC);
00fcfd e3e7      	LDI  R30,LOW(55)
00fcfe 93ea      	ST   -Y,R30
                +
00fcff e0e0     +LDI R30 , LOW ( 0x0 )
00fd00 e0f0     +LDI R31 , HIGH ( 0x0 )
00fd01 e060     +LDI R22 , BYTE3 ( 0x0 )
00fd02 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
00fd03 c007      	RJMP _0x2000005
                 ; 0003 00CA 
                 ; 0003 00CB     // read response
                 ; 0003 00CC     //res1 = SD_readRes1();
                 ; 0003 00CD 
                 ; 0003 00CE     // deassert chip select
                 ; 0003 00CF     SPI_transfer(0xFF);
                 ; 0003 00D0     CS_DISABLE();
                 ; 0003 00D1     SPI_transfer(0xFF);
                 ; 0003 00D2 
                 ; 0003 00D3     return res1;
                 ; 0003 00D4 }
                 ; .FEND
                 ;
                 ;unsigned char SD_sendOpCond()
                 ; 0003 00D7 {
                 _SD_sendOpCond:
                 ; .FSTART _SD_sendOpCond
                 ; 0003 00D8     unsigned char res1;
                 ; 0003 00D9     // assert chip select
                 ; 0003 00DA     SPI_transfer(0xFF);
00fd04 d1ce      	RCALL SUBOPT_0x1B
                 ;	res1 -> R17
                 ; 0003 00DB     CS_ENABLE();
                 ; 0003 00DC     //SPI_transfer(0xFF);
                 ; 0003 00DD 
                 ; 0003 00DE     // send CMD0
                 ; 0003 00DF     res1 =  SD_command(ACMD41, ACMD41_ARG, ACMD41_CRC);
00fd05 e2e9      	LDI  R30,LOW(41)
00fd06 93ea      	ST   -Y,R30
                +
00fd07 e0e0     +LDI R30 , LOW ( 0x40000000 )
00fd08 e0f0     +LDI R31 , HIGH ( 0x40000000 )
00fd09 e060     +LDI R22 , BYTE3 ( 0x40000000 )
00fd0a e470     +LDI R23 , BYTE4 ( 0x40000000 )
                 	__GETD1N 0x40000000
                 _0x2000005:
00fd0b 940e ffcc 	CALL __PUTPARD1
00fd0d e0a0      	LDI  R26,LOW(0)
                 _0x2000006:
00fd0e df78      	RCALL _SD_command
00fd0f 2f1e      	MOV  R17,R30
                 ; 0003 00E0 
                 ; 0003 00E1     // read response
                 ; 0003 00E2     //res1 = SD_readRes1();
                 ; 0003 00E3 
                 ; 0003 00E4     // deassert chip select
                 ; 0003 00E5     SPI_transfer(0xFF);
00fd10 d1cd      	RCALL SUBOPT_0x1D
                 ; 0003 00E6     CS_DISABLE();
                 ; 0003 00E7     SPI_transfer(0xFF);
                 ; 0003 00E8 
                 ; 0003 00E9     return res1;
00fd11 2fe1      	MOV  R30,R17
                 _0x2000007:
00fd12 9119      	LD   R17,Y+
00fd13 9508      	RET
                 ; 0003 00EA }
                 ; .FEND
                 ;
                 ;unsigned char SD_init()
                 ; 0003 00ED {
                 _SD_init:
                 ; .FSTART _SD_init
                 ; 0003 00EE     unsigned char res[5], cmdAttempts = 0;
                 ; 0003 00EF 
                 ; 0003 00F0     SD_powerUpSeq();
00fd14 9725      	SBIW R28,5
00fd15 931a      	ST   -Y,R17
                 ;	res -> Y+1
                 ;	cmdAttempts -> R17
00fd16 e010      	LDI  R17,0
00fd17 df5f      	RCALL _SD_powerUpSeq
                 ; 0003 00F1 
                 ; 0003 00F2     // command card to idle
                 ; 0003 00F3     while((res[0] = SD_goIdleState()) != 0x01)
                 _0x6000E:
00fd18 dfa5      	RCALL _SD_goIdleState
00fd19 83e9      	STD  Y+1,R30
00fd1a 30e1      	CPI  R30,LOW(0x1)
00fd1b f031      	BREQ _0x60010
                 ; 0003 00F4     {
                 ; 0003 00F5         cmdAttempts++;
00fd1c 5f1f      	SUBI R17,-1
                 ; 0003 00F6         if(cmdAttempts > 100) return SD_ERROR;
00fd1d 3615      	CPI  R17,101
00fd1e f010      	BRLO _0x60011
00fd1f e0e1      	LDI  R30,LOW(1)
00fd20 c02e      	RJMP _0x2000003
                 ; 0003 00F7     }
                 _0x60011:
00fd21 cff6      	RJMP _0x6000E
                 _0x60010:
                 ; 0003 00F8 
                 ; 0003 00F9     // send interface conditions
                 ; 0003 00FA     SD_sendIfCond(res);
00fd22 01de      	MOVW R26,R28
00fd23 9611      	ADIW R26,1
00fd24 dfbf      	RCALL _SD_sendIfCond
                 ; 0003 00FB     if(res[0] != 0x01)
00fd25 81a9      	LDD  R26,Y+1
00fd26 30a1      	CPI  R26,LOW(0x1)
00fd27 f011      	BREQ _0x60012
                 ; 0003 00FC     {
                 ; 0003 00FD         return SD_ERROR;
00fd28 e0e1      	LDI  R30,LOW(1)
00fd29 c025      	RJMP _0x2000003
                 ; 0003 00FE     }
                 ; 0003 00FF 
                 ; 0003 0100     // check echo pattern
                 ; 0003 0101     if(res[4] != 0xAA)
                 _0x60012:
00fd2a 81ad      	LDD  R26,Y+5
00fd2b 3aaa      	CPI  R26,LOW(0xAA)
00fd2c f011      	BREQ _0x60013
                 ; 0003 0102     {
                 ; 0003 0103         return SD_ERROR;
00fd2d e0e1      	LDI  R30,LOW(1)
00fd2e c020      	RJMP _0x2000003
                 ; 0003 0104     }
                 ; 0003 0105 
                 ; 0003 0106     // attempt to initialize card
                 ; 0003 0107     cmdAttempts = 0;
                 _0x60013:
00fd2f e010      	LDI  R17,LOW(0)
                 ; 0003 0108     do
                 _0x60015:
                 ; 0003 0109     {
                 ; 0003 010A         if(cmdAttempts > 100) return SD_ERROR;
00fd30 3615      	CPI  R17,101
00fd31 f010      	BRLO _0x60017
00fd32 e0e1      	LDI  R30,LOW(1)
00fd33 c01b      	RJMP _0x2000003
                 ; 0003 010B 
                 ; 0003 010C         // send app cmd
                 ; 0003 010D         res[0] = SD_sendApp();
                 _0x60017:
00fd34 dfc7      	RCALL _SD_sendApp
00fd35 83e9      	STD  Y+1,R30
                 ; 0003 010E 
                 ; 0003 010F         // if no error in response
                 ; 0003 0110         if(res[0] < 2)
00fd36 81a9      	LDD  R26,Y+1
00fd37 30a2      	CPI  R26,LOW(0x2)
00fd38 f410      	BRSH _0x60018
                 ; 0003 0111         {
                 ; 0003 0112             res[0] = SD_sendOpCond();
00fd39 dfca      	RCALL _SD_sendOpCond
00fd3a 83e9      	STD  Y+1,R30
                 ; 0003 0113         }
                 ; 0003 0114 
                 ; 0003 0115         // wait
                 ; 0003 0116         if(res[0] != SD_READY)
                 _0x60018:
00fd3b 81e9      	LDD  R30,Y+1
00fd3c 30e0      	CPI  R30,0
00fd3d f021      	BREQ _0x60019
                 ; 0003 0117             delay_ms(10);
00fd3e e0aa      	LDI  R26,LOW(10)
00fd3f e0b0      	LDI  R27,0
00fd40 940e ff09 	CALL _delay_ms
                 ; 0003 0118 
                 ; 0003 0119         cmdAttempts++;
                 _0x60019:
00fd42 5f1f      	SUBI R17,-1
                 ; 0003 011A     }
                 ; 0003 011B     while(res[0] != SD_READY);
00fd43 81e9      	LDD  R30,Y+1
00fd44 30e0      	CPI  R30,0
00fd45 f751      	BRNE _0x60015
                 ; 0003 011C 
                 ; 0003 011D     // read OCR
                 ; 0003 011E     SD_readOCR(res);
00fd46 01de      	MOVW R26,R28
00fd47 9611      	ADIW R26,1
00fd48 dfa6      	RCALL _SD_readOCR
                 ; 0003 011F 
                 ; 0003 0120     // check card is ready
                 ; 0003 0121     if(!(res[1] & 0x80)) return SD_ERROR;
00fd49 81ea      	LDD  R30,Y+2
00fd4a 78e0      	ANDI R30,LOW(0x80)
00fd4b f411      	BRNE _0x6001A
00fd4c e0e1      	LDI  R30,LOW(1)
00fd4d c001      	RJMP _0x2000003
                 ; 0003 0122 
                 ; 0003 0123     return SD_SUCCESS;
                 _0x6001A:
00fd4e e0e0      	LDI  R30,LOW(0)
                 _0x2000003:
00fd4f 8118      	LDD  R17,Y+0
                 _0x2000004:
00fd50 9626      	ADIW R28,6
00fd51 9508      	RET
                 ; 0003 0124 }
                 ; .FEND
                 ;
                 ;#define CMD17                   17
                 ;#define CMD17_CRC               0x00
                 ;#define SD_MAX_READ_ATTEMPTS    1563
                 ;
                 ;/*******************************************************************************
                 ; Read single 512 byte block
                 ; token = 0xFE - Successful read
                 ; token = 0x0X - Data error
                 ; token = 0xFF - Timeout
                 ;*******************************************************************************/
                 ;unsigned char SD_readSingleBlock(unsigned long addr, unsigned char *buf, unsigned char *token)
                 ; 0003 0131 {
                 _SD_readSingleBlock:
                 ; .FSTART _SD_readSingleBlock
                 ; 0003 0132     unsigned char res1, read;
                 ; 0003 0133     unsigned int i, readAttempts;
                 ; 0003 0134     #asm("wdr")
00fd52 93ba      	ST   -Y,R27
00fd53 93aa      	ST   -Y,R26
00fd54 940e ffdf 	CALL __SAVELOCR6
                 ;	addr -> Y+10
                 ;	*buf -> Y+8
                 ;	*token -> Y+6
                 ;	res1 -> R17
                 ;	read -> R16
                 ;	i -> R18,R19
                 ;	readAttempts -> R20,R21
00fd56 95a8      	wdr
                 ; 0003 0135     addr*=512UL;
00fd57 d189      	RCALL SUBOPT_0x1E
                 ; 0003 0136     // set token to none
                 ; 0003 0137     *token = 0xFF;
                 ; 0003 0138 
                 ; 0003 0139     // assert chip select
                 ; 0003 013A     SPI_transfer(0xFF);
                 ; 0003 013B     CS_ENABLE();
                 ; 0003 013C     //SPI_transfer(0xFF);
                 ; 0003 013D 
                 ; 0003 013E     // send CMD17
                 ; 0003 013F     res1 = SD_command(CMD17, addr, CMD17_CRC);
00fd58 e1e1      	LDI  R30,LOW(17)
00fd59 d19d      	RCALL SUBOPT_0x1F
                 ; 0003 0140 
                 ; 0003 0141     // read R1
                 ; 0003 0142     //res1 = SD_readRes1();
                 ; 0003 0143 
                 ; 0003 0144     // if response received from card
                 ; 0003 0145     if(res1 != 0xFF)
00fd5a 3f1f      	CPI  R17,255
00fd5b f169      	BREQ _0x6001B
                 ; 0003 0146     {
                 ; 0003 0147         // wait for a response token (timeout = 100ms)
                 ; 0003 0148         readAttempts = 0;
                +
00fd5c e040     +LDI R20 , LOW ( 0 )
00fd5d e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 0149         while(++readAttempts != SD_MAX_READ_ATTEMPTS)
                 _0x6001C:
00fd5e 01fa      	MOVW R30,R20
00fd5f 9631      	ADIW R30,1
00fd60 01af      	MOVW R20,R30
00fd61 31eb      	CPI  R30,LOW(0x61B)
00fd62 e0a6      	LDI  R26,HIGH(0x61B)
00fd63 07fa      	CPC  R31,R26
00fd64 f029      	BREQ _0x6001E
                 ; 0003 014A             if((read = SPI_transfer(0xFF)) != 0xFF) break;
00fd65 efaf      	LDI  R26,LOW(255)
00fd66 df08      	RCALL _SPI_transfer
00fd67 2f0e      	MOV  R16,R30
00fd68 3fef      	CPI  R30,LOW(0xFF)
00fd69 f3a1      	BREQ _0x6001C
                 ; 0003 014B 
                 ; 0003 014C         // if response token is 0xFE
                 ; 0003 014D         if(read == 0xFE)
                 _0x6001E:
00fd6a 3f0e      	CPI  R16,254
00fd6b f4d1      	BRNE _0x60020
                 ; 0003 014E         {
                 ; 0003 014F             // read 512 byte block
                 ; 0003 0150             for(i = 0; i < 512; i++) *buf++ = SPI_transfer(0xFF);
                +
00fd6c e020     +LDI R18 , LOW ( 0 )
00fd6d e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60022:
                +
00fd6e 3020     +CPI R18 , LOW ( 512 )
00fd6f e0e2     +LDI R30 , HIGH ( 512 )
00fd70 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fd71 f480      	BRSH _0x60023
00fd72 85e8      	LDD  R30,Y+8
00fd73 85f9      	LDD  R31,Y+8+1
00fd74 9631      	ADIW R30,1
00fd75 87e8      	STD  Y+8,R30
00fd76 87f9      	STD  Y+8+1,R31
00fd77 9731      	SBIW R30,1
00fd78 93ff      	PUSH R31
00fd79 93ef      	PUSH R30
00fd7a efaf      	LDI  R26,LOW(255)
00fd7b def3      	RCALL _SPI_transfer
00fd7c 91af      	POP  R26
00fd7d 91bf      	POP  R27
00fd7e 93ec      	ST   X,R30
                +
00fd7f 5f2f     +SUBI R18 , LOW ( - 1 )
00fd80 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fd81 cfec      	RJMP _0x60022
                 _0x60023:
                 ; 0003 0153 SPI_transfer(0xFF);
00fd82 efaf      	LDI  R26,LOW(255)
00fd83 deeb      	RCALL _SPI_transfer
                 ; 0003 0154             SPI_transfer(0xFF);
00fd84 efaf      	LDI  R26,LOW(255)
00fd85 dee9      	RCALL _SPI_transfer
                 ; 0003 0155         }
                 ; 0003 0156 
                 ; 0003 0157         // set token to card response
                 ; 0003 0158         *token = read;
                 _0x60020:
00fd86 81ae      	LDD  R26,Y+6
00fd87 81bf      	LDD  R27,Y+6+1
00fd88 930c      	ST   X,R16
                 ; 0003 0159     }
                 ; 0003 015A 
                 ; 0003 015B     // deassert chip select
                 ; 0003 015C     SPI_transfer(0xFF);
                 _0x6001B:
00fd89 d154      	RCALL SUBOPT_0x1D
                 ; 0003 015D     CS_DISABLE();
                 ; 0003 015E     SPI_transfer(0xFF);
                 ; 0003 015F     if(read==0xFE)
00fd8a 3f0e      	CPI  R16,254
00fd8b f409      	BRNE _0x60024
                 ; 0003 0160         return res1;
00fd8c c043      	RJMP _0x2000002
                 ; 0003 0161     else
                 _0x60024:
                 ; 0003 0162         return SD_ERROR;
00fd8d e0e1      	LDI  R30,LOW(1)
00fd8e c042      	RJMP _0x2000001
                 ; 0003 0163 }
                 ; .FEND
                 ;
                 ;#define SD_BLOCK_LEN            512
                 ;#define SD_START_TOKEN          0xFE
                 ;#define CMD24_CRC           0x00
                 ;#define CMD24                   24
                 ;#define CMD24_ARG               0x00
                 ;#define SD_MAX_WRITE_ATTEMPTS   3907
                 ;/*******************************************************************************
                 ; Write single 512 byte block
                 ; token = 0x00 - busy timeout
                 ; token = 0x05 - data accepted
                 ; token = 0xFF - response timeout
                 ;*******************************************************************************/
                 ;
                 ;unsigned char SD_writeSingleBlock(unsigned long addr, unsigned char *buf, unsigned char *token)
                 ; 0003 0173 {
                 _SD_writeSingleBlock:
                 ; .FSTART _SD_writeSingleBlock
                 ; 0003 0174     unsigned char res1, read;
                 ; 0003 0175     unsigned int i, readAttempts;
                 ; 0003 0176     #asm("wdr")
00fd8f 93ba      	ST   -Y,R27
00fd90 93aa      	ST   -Y,R26
00fd91 940e ffdf 	CALL __SAVELOCR6
                 ;	addr -> Y+10
                 ;	*buf -> Y+8
                 ;	*token -> Y+6
                 ;	res1 -> R17
                 ;	read -> R16
                 ;	i -> R18,R19
                 ;	readAttempts -> R20,R21
00fd93 95a8      	wdr
                 ; 0003 0177     addr*=512UL;
00fd94 d14c      	RCALL SUBOPT_0x1E
                 ; 0003 0178     // set token to none
                 ; 0003 0179     *token = 0xFF;
                 ; 0003 017A 
                 ; 0003 017B     // assert chip select
                 ; 0003 017C     SPI_transfer(0xFF);
                 ; 0003 017D     CS_ENABLE();
                 ; 0003 017E     SPI_transfer(0xFF);
00fd95 efaf      	LDI  R26,LOW(255)
00fd96 ded8      	RCALL _SPI_transfer
                 ; 0003 017F 
                 ; 0003 0180     // send CMD24
                 ; 0003 0181     res1=SD_command(CMD24, addr, CMD24_CRC);
00fd97 e1e8      	LDI  R30,LOW(24)
00fd98 d15e      	RCALL SUBOPT_0x1F
                 ; 0003 0182 
                 ; 0003 0183     // read response
                 ; 0003 0184     //res1 = SD_readRes1();
                 ; 0003 0185 
                 ; 0003 0186     // if no error
                 ; 0003 0187     if(res1 == SD_READY)
00fd99 3010      	CPI  R17,0
00fd9a f5a1      	BRNE _0x60026
                 ; 0003 0188     {
                 ; 0003 0189         // send start token
                 ; 0003 018A         SPI_transfer(SD_START_TOKEN);
00fd9b efae      	LDI  R26,LOW(254)
00fd9c ded2      	RCALL _SPI_transfer
                 ; 0003 018B 
                 ; 0003 018C         // write buffer to card
                 ; 0003 018D         for(i = 0; i < SD_BLOCK_LEN; i++) SPI_transfer(buf[i]);
                +
00fd9d e020     +LDI R18 , LOW ( 0 )
00fd9e e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60028:
                +
00fd9f 3020     +CPI R18 , LOW ( 512 )
00fda0 e0e2     +LDI R30 , HIGH ( 512 )
00fda1 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fda2 f438      	BRSH _0x60029
00fda3 01f9      	MOVW R30,R18
00fda4 d03c      	RCALL SUBOPT_0x2
00fda5 91ac      	LD   R26,X
00fda6 dec8      	RCALL _SPI_transfer
                +
00fda7 5f2f     +SUBI R18 , LOW ( - 1 )
00fda8 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fda9 cff5      	RJMP _0x60028
                 _0x60029:
                 ; 0003 0190 readAttempts = 0;
                +
00fdaa e040     +LDI R20 , LOW ( 0 )
00fdab e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 0191         while(++readAttempts != SD_MAX_WRITE_ATTEMPTS)
                 _0x6002A:
00fdac d155      	RCALL SUBOPT_0x20
00fdad f059      	BREQ _0x6002C
                 ; 0003 0192             if((read = SPI_transfer(0xFF)) != 0xFF) { *token = 0xFF; break; }
00fdae efaf      	LDI  R26,LOW(255)
00fdaf debf      	RCALL _SPI_transfer
00fdb0 2f0e      	MOV  R16,R30
00fdb1 3fef      	CPI  R30,LOW(0xFF)
00fdb2 f029      	BREQ _0x6002D
00fdb3 81ae      	LDD  R26,Y+6
00fdb4 81bf      	LDD  R27,Y+6+1
00fdb5 efef      	LDI  R30,LOW(255)
00fdb6 93ec      	ST   X,R30
00fdb7 c001      	RJMP _0x6002C
                 ; 0003 0193 
                 ; 0003 0194         // if data accepted
                 ; 0003 0195         if((read & 0x1F) == 0x05)
                 _0x6002D:
00fdb8 cff3      	RJMP _0x6002A
                 _0x6002C:
00fdb9 2fe0      	MOV  R30,R16
00fdba 71ef      	ANDI R30,LOW(0x1F)
00fdbb 30e5      	CPI  R30,LOW(0x5)
00fdbc f491      	BRNE _0x6002E
                 ; 0003 0196         {
                 ; 0003 0197             // set token to data accepted
                 ; 0003 0198             *token = 0x05;
00fdbd 81ae      	LDD  R26,Y+6
00fdbe 81bf      	LDD  R27,Y+6+1
00fdbf e0e5      	LDI  R30,LOW(5)
00fdc0 93ec      	ST   X,R30
                 ; 0003 0199 
                 ; 0003 019A             // wait for write to finish (timeout = 250ms)
                 ; 0003 019B             readAttempts = 0;
                +
00fdc1 e040     +LDI R20 , LOW ( 0 )
00fdc2 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 019C             while(SPI_transfer(0xFF) == 0x00){
                 _0x6002F:
00fdc3 efaf      	LDI  R26,LOW(255)
00fdc4 deaa      	RCALL _SPI_transfer
00fdc5 30e0      	CPI  R30,0
00fdc6 f441      	BRNE _0x60031
                 ; 0003 019D                 if(++readAttempts == SD_MAX_WRITE_ATTEMPTS){
00fdc7 d13a      	RCALL SUBOPT_0x20
00fdc8 f429      	BRNE _0x60032
                 ; 0003 019E                     *token = 0x00;
00fdc9 81ae      	LDD  R26,Y+6
00fdca 81bf      	LDD  R27,Y+6+1
00fdcb e0e0      	LDI  R30,LOW(0)
00fdcc 93ec      	ST   X,R30
                 ; 0003 019F                     break;
00fdcd c001      	RJMP _0x60031
                 ; 0003 01A0                 }
                 ; 0003 01A1             }
                 _0x60032:
00fdce cff4      	RJMP _0x6002F
                 _0x60031:
                 ; 0003 01A2         }
                 ; 0003 01A3     }
                 _0x6002E:
                 ; 0003 01A4 
                 ; 0003 01A5     // deassert chip select
                 ; 0003 01A6     SPI_transfer(0xFF);
                 _0x60026:
00fdcf d10e      	RCALL SUBOPT_0x1D
                 ; 0003 01A7     CS_DISABLE();
                 ; 0003 01A8     SPI_transfer(0xFF);
                 ; 0003 01A9 
                 ; 0003 01AA     return res1;
                 _0x2000002:
00fdd0 2fe1      	MOV  R30,R17
                 _0x2000001:
00fdd1 940e ffe6 	CALL __LOADLOCR6
00fdd3 962e      	ADIW R28,14
00fdd4 9508      	RET
                 ; 0003 01AB }
                 ; .FEND
                 
                 	.DSEG
                 _result:
00091e           	.BYTE 0x5
                 _sdBuf:
000923           	.BYTE 0x200
                 _appStartAdr:
000b23           	.BYTE 0x4
                 _adr:
000b27           	.BYTE 0x4
                 _SectorsPerFat:
000b2b           	.BYTE 0x4
                 _fat_begin_lba:
000b2f           	.BYTE 0x4
                 _cluster_begin_lba:
000b33           	.BYTE 0x4
                 _fat_file_adr:
000b37           	.BYTE 0x4
                 _fat_file_next_adr:
000b3b           	.BYTE 0x4
                 _filesize:
000b3f           	.BYTE 0x4
                 _readbytes:
000b43           	.BYTE 0x4
                 _bytesChecksum:
000b47           	.BYTE 0x2
                 _checksumCnt:
000b49           	.BYTE 0x2
                 _Number_of_Reserved_Sectors:
000b4b           	.BYTE 0x2
                 _app_pointer:
000b4d           	.BYTE 0x2
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x0:
                +
00fdd5 e0e0     +LDI R30 , LOW ( 0x0 )
00fdd6 e0f0     +LDI R31 , HIGH ( 0x0 )
00fdd7 e060     +LDI R22 , BYTE3 ( 0x0 )
00fdd8 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
00fdd9 940e ffcc 	CALL __PUTPARD1
00fddb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1:
                +
00fddc e0a0     +LDI R26 , LOW ( 0x1EF00 )
00fddd eebf     +LDI R27 , HIGH ( 0x1EF00 )
00fdde e081     +LDI R24 , BYTE3 ( 0x1EF00 )
00fddf e090     +LDI R25 , BYTE4 ( 0x1EF00 )
                 	__GETD2N 0x1EF00
00fde0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2:
00fde1 85a8      	LDD  R26,Y+8
00fde2 85b9      	LDD  R27,Y+8+1
00fde3 0fae      	ADD  R26,R30
00fde4 1fbf      	ADC  R27,R31
00fde5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3:
00fde6 940e ffd1 	CALL __PUTPARD2
00fde8 940e ffc2 	CALL __GETD2S0
00fdea 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4:
00fdeb 940e ffc2 	CALL __GETD2S0
00fded 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:37 WORDS
                 SUBOPT_0x5:
00fdee e2e3      	LDI  R30,LOW(_sdBuf)
00fdef e0f9      	LDI  R31,HIGH(_sdBuf)
00fdf0 93fa      	ST   -Y,R31
00fdf1 93ea      	ST   -Y,R30
00fdf2 e0a9      	LDI  R26,LOW(9)
00fdf3 e0b0      	LDI  R27,HIGH(9)
00fdf4 df5d      	RCALL _SD_readSingleBlock
00fdf5 93e0 091e 	STS  _result,R30
00fdf7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x6:
00fdf8 93fa      	ST   -Y,R31
00fdf9 93ea      	ST   -Y,R30
00fdfa e0a4      	LDI  R26,LOW(4)
00fdfb ce43      	RJMP _buf2num
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x7:
00fdfc 93e0 0b27 	STS  _adr,R30
00fdfe 93f0 0b28 	STS  _adr+1,R31
00fe00 9360 0b29 	STS  _adr+2,R22
00fe02 9370 0b2a 	STS  _adr+3,R23
00fe04 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:27 WORDS
                 SUBOPT_0x8:
00fe05 91e0 0b27 	LDS  R30,_adr
00fe07 91f0 0b28 	LDS  R31,_adr+1
00fe09 9160 0b29 	LDS  R22,_adr+2
00fe0b 9170 0b2a 	LDS  R23,_adr+3
00fe0d 940e ffcc 	CALL __PUTPARD1
00fe0f cfde      	RJMP SUBOPT_0x5
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x9:
00fe10 91a0 0b2f 	LDS  R26,_fat_begin_lba
00fe12 91b0 0b30 	LDS  R27,_fat_begin_lba+1
00fe14 9180 0b31 	LDS  R24,_fat_begin_lba+2
00fe16 9190 0b32 	LDS  R25,_fat_begin_lba+3
00fe18 940e ff13 	CALL __ADDD12
00fe1a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xA:
00fe1b 2de8      	MOV  R30,R8
00fe1c 01d8      	MOVW R26,R16
00fe1d e0f0      	LDI  R31,0
00fe1e 17ae      	CP   R26,R30
00fe1f 07bf      	CPC  R27,R31
00fe20 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0xB:
00fe21 93fa      	ST   -Y,R31
00fe22 93ea      	ST   -Y,R30
                +
00fe23 e2a0     +LDI R26 , 32
00fe24 9fa2     +MUL R26 , R18
00fe25 01f0     +MOVW R30 , R0
00fe26 9fa3     +MUL R26 , R19
00fe27 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
00fe28 5ded      	SUBI R30,LOW(-_sdBuf)
00fe29 4ff6      	SBCI R31,HIGH(-_sdBuf)
00fe2a 01df      	MOVW R26,R30
00fe2b ddfd      	RCALL _compbuf
                +
00fe2c 93e0 091f+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
00fe2e 30e0      	CPI  R30,0
00fe2f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:21 WORDS
                 SUBOPT_0xC:
                +
00fe30 e2a0     +LDI R26 , 32
00fe31 9fa2     +MUL R26 , R18
00fe32 01f0     +MOVW R30 , R0
00fe33 9fa3     +MUL R26 , R19
00fe34 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
00fe35 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xD:
                +
00fe36 5ce9     +SUBI R30 , LOW ( - _sdBuf - ( 20 ) )
00fe37 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 20 ) )
                 	__ADDW1MN _sdBuf,20
00fe38 81e0      	LD   R30,Z
00fe39 e0f0      	LDI  R31,0
00fe3a 940e ff48 	CALL __CWD1
00fe3c 940e ff43 	CALL __LSLD16
00fe3e 93e0 0b37 	STS  _fat_file_adr,R30
00fe40 93f0 0b38 	STS  _fat_file_adr+1,R31
00fe42 9360 0b39 	STS  _fat_file_adr+2,R22
00fe44 9370 0b3a 	STS  _fat_file_adr+3,R23
00fe46 cfe9      	RJMP SUBOPT_0xC
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:19 WORDS
                 SUBOPT_0xE:
                +
00fe47 5ce3     +SUBI R30 , LOW ( - _sdBuf - ( 26 ) )
00fe48 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 26 ) )
                 	__ADDW1MN _sdBuf,26
00fe49 81e0      	LD   R30,Z
00fe4a e0f0      	LDI  R31,0
00fe4b 940e ff48 	CALL __CWD1
00fe4d 91a0 0b37 	LDS  R26,_fat_file_adr
00fe4f 91b0 0b38 	LDS  R27,_fat_file_adr+1
00fe51 9180 0b39 	LDS  R24,_fat_file_adr+2
00fe53 9190 0b3a 	LDS  R25,_fat_file_adr+3
00fe55 940e ff18 	CALL __ORD12
00fe57 93e0 0b37 	STS  _fat_file_adr,R30
00fe59 93f0 0b38 	STS  _fat_file_adr+1,R31
00fe5b 9360 0b39 	STS  _fat_file_adr+2,R22
00fe5d 9370 0b3a 	STS  _fat_file_adr+3,R23
00fe5f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xF:
00fe60 e2a7      	LDI  R26,LOW(_adr)
00fe61 e0bb      	LDI  R27,HIGH(_adr)
00fe62 940e ffb3 	CALL __GETD1P_INC
                +
00fe64 5fef     +SUBI R30 , LOW ( - 1 )
00fe65 4fff     +SBCI R31 , HIGH ( - 1 )
00fe66 4f6f     +SBCI R22 , BYTE3 ( - 1 )
00fe67 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
00fe68 940e ffb8 	CALL __PUTDP1_DEC
00fe6a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x10:
00fe6b 91e0 0b37 	LDS  R30,_fat_file_adr
00fe6d 91f0 0b38 	LDS  R31,_fat_file_adr+1
00fe6f 9160 0b39 	LDS  R22,_fat_file_adr+2
00fe71 9170 0b3a 	LDS  R23,_fat_file_adr+3
00fe73 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:21 WORDS
                 SUBOPT_0x11:
                +
00fe74 50e2     +SUBI R30 , LOW ( 2 )
00fe75 40f0     +SBCI R31 , HIGH ( 2 )
00fe76 4060     +SBCI R22 , BYTE3 ( 2 )
00fe77 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
00fe78 01df      	MOVW R26,R30
00fe79 01cb      	MOVW R24,R22
00fe7a 2de8      	MOV  R30,R8
00fe7b e0f0      	LDI  R31,0
00fe7c 940e ff48 	CALL __CWD1
00fe7e 940e ff55 	CALL __MULD12U
00fe80 91a0 0b33 	LDS  R26,_cluster_begin_lba
00fe82 91b0 0b34 	LDS  R27,_cluster_begin_lba+1
00fe84 9180 0b35 	LDS  R24,_cluster_begin_lba+2
00fe86 9190 0b36 	LDS  R25,_cluster_begin_lba+3
00fe88 940e ff13 	CALL __ADDD12
00fe8a df71      	RCALL SUBOPT_0x7
                +
00fe8b e000     +LDI R16 , LOW ( 0 )
00fe8c e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
00fe8d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x12:
                +
00fe8e 3faf     +CPI R26 , LOW ( 0xFFFFFFF )
00fe8f efef     +LDI R30 , HIGH ( 0xFFFFFFF )
00fe90 07be     +CPC R27 , R30
00fe91 efef     +LDI R30 , BYTE3 ( 0xFFFFFFF )
00fe92 078e     +CPC R24 , R30
00fe93 e0ef     +LDI R30 , BYTE4 ( 0xFFFFFFF )
00fe94 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFFFFF
00fe95 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x13:
00fe96 91a0 0b43 	LDS  R26,_readbytes
00fe98 91b0 0b44 	LDS  R27,_readbytes+1
00fe9a 9180 0b45 	LDS  R24,_readbytes+2
00fe9c 9190 0b46 	LDS  R25,_readbytes+3
00fe9e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x14:
00fe9f 91ec      	LD   R30,X
00fea0 1fee      	ROL  R30
00fea1 e0e0      	LDI  R30,0
00fea2 1fee      	ROL  R30
00fea3 29e0      	OR   R30,R0
00fea4 01db      	MOVW R26,R22
00fea5 93ec      	ST   X,R30
00fea6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x15:
00fea7 e2a3      	LDI  R26,LOW(_sdBuf)
00fea8 e0b9      	LDI  R27,HIGH(_sdBuf)
00fea9 0fa2      	ADD  R26,R18
00feaa 1fb3      	ADC  R27,R19
00feab 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x16:
00feac 91e0 0b23 	LDS  R30,_appStartAdr
00feae 91f0 0b24 	LDS  R31,_appStartAdr+1
00feb0 9160 0b25 	LDS  R22,_appStartAdr+2
00feb2 9170 0b26 	LDS  R23,_appStartAdr+3
00feb4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x17:
00feb5 93e0 0b23 	STS  _appStartAdr,R30
00feb7 93f0 0b24 	STS  _appStartAdr+1,R31
00feb9 9360 0b25 	STS  _appStartAdr+2,R22
00febb 9370 0b26 	STS  _appStartAdr+3,R23
00febd 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x18:
00febe 91a0 0b23 	LDS  R26,_appStartAdr
00fec0 91b0 0b24 	LDS  R27,_appStartAdr+1
00fec2 9180 0b25 	LDS  R24,_appStartAdr+2
00fec4 9190 0b26 	LDS  R25,_appStartAdr+3
00fec6 940e ff18 	CALL __ORD12
00fec8 cfec      	RJMP SUBOPT_0x17
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x19:
00fec9 9ac0      	SBI  0x18,0
00feca efaf      	LDI  R26,LOW(255)
00fecb cda3      	RJMP _SPI_transfer
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1A:
00fecc 2fae      	MOV  R26,R30
00fecd dda1      	RCALL _SPI_transfer
                +
00fece 81ab     +LDD R26 , Y + 3
00fecf 81bc     +LDD R27 , Y + 3 + 1
00fed0 818d     +LDD R24 , Y + 3 + 2
00fed1 819e     +LDD R25 , Y + 3 + 3
                 	__GETD2S 3
00fed2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1B:
00fed3 931a      	ST   -Y,R17
00fed4 efaf      	LDI  R26,LOW(255)
00fed5 dd99      	RCALL _SPI_transfer
00fed6 98c0      	CBI  0x18,0
00fed7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1C:
00fed8 93ba      	ST   -Y,R27
00fed9 93aa      	ST   -Y,R26
00feda efaf      	LDI  R26,LOW(255)
00fedb dd93      	RCALL _SPI_transfer
00fedc 98c0      	CBI  0x18,0
00fedd 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x1D:
00fede efaf      	LDI  R26,LOW(255)
00fedf dd8f      	RCALL _SPI_transfer
00fee0 cfe8      	RJMP SUBOPT_0x19
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:17 WORDS
                 SUBOPT_0x1E:
                +
00fee1 85ea     +LDD R30 , Y + 10
00fee2 85fb     +LDD R31 , Y + 10 + 1
00fee3 856c     +LDD R22 , Y + 10 + 2
00fee4 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
                +
00fee5 e0a0     +LDI R26 , LOW ( 0x200 )
00fee6 e0b2     +LDI R27 , HIGH ( 0x200 )
00fee7 e080     +LDI R24 , BYTE3 ( 0x200 )
00fee8 e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
00fee9 940e ff55 	CALL __MULD12U
                +
00feeb 87ea     +STD Y + 10 , R30
00feec 87fb     +STD Y + 10 + 1 , R31
00feed 876c     +STD Y + 10 + 2 , R22
00feee 877d     +STD Y + 10 + 3 , R23
                 	__PUTD1S 10
00feef 81ae      	LDD  R26,Y+6
00fef0 81bf      	LDD  R27,Y+6+1
00fef1 efef      	LDI  R30,LOW(255)
00fef2 93ec      	ST   X,R30
00fef3 efaf      	LDI  R26,LOW(255)
00fef4 dd7a      	RCALL _SPI_transfer
00fef5 98c0      	CBI  0x18,0
00fef6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x1F:
00fef7 93ea      	ST   -Y,R30
                +
00fef8 85eb     +LDD R30 , Y + 11
00fef9 85fc     +LDD R31 , Y + 11 + 1
00fefa 856d     +LDD R22 , Y + 11 + 2
00fefb 857e     +LDD R23 , Y + 11 + 3
                 	__GETD1S 11
00fefc 940e ffcc 	CALL __PUTPARD1
00fefe e0a0      	LDI  R26,LOW(0)
00feff dd87      	RCALL _SD_command
00ff00 2f1e      	MOV  R17,R30
00ff01 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x20:
00ff02 01fa      	MOVW R30,R20
00ff03 9631      	ADIW R30,1
00ff04 01af      	MOVW R20,R30
00ff05 34e3      	CPI  R30,LOW(0xF43)
00ff06 e0af      	LDI  R26,HIGH(0xF43)
00ff07 07fa      	CPC  R31,R26
00ff08 9508      	RET
                 
                 
                 	.CSEG
                 _delay_ms:
00ff09 9610      	adiw r26,0
00ff0a f039      	breq __delay_ms1
                 __delay_ms0:
                +
00ff0b ec84     +LDI R24 , LOW ( 0x9C4 )
00ff0c e099     +LDI R25 , HIGH ( 0x9C4 )
                +__DELAY_USW_LOOP :
00ff0d 9701     +SBIW R24 , 1
00ff0e f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x9C4
00ff0f 95a8      	wdr
00ff10 9711      	sbiw r26,1
00ff11 f7c9      	brne __delay_ms0
                 __delay_ms1:
00ff12 9508      	ret
                 
                 __ADDD12:
00ff13 0fea      	ADD  R30,R26
00ff14 1ffb      	ADC  R31,R27
00ff15 1f68      	ADC  R22,R24
00ff16 1f79      	ADC  R23,R25
00ff17 9508      	RET
                 
                 __ORD12:
00ff18 2bea      	OR   R30,R26
00ff19 2bfb      	OR   R31,R27
00ff1a 2b68      	OR   R22,R24
00ff1b 2b79      	OR   R23,R25
00ff1c 9508      	RET
                 
                 __ANEGW1:
00ff1d 95f1      	NEG  R31
00ff1e 95e1      	NEG  R30
00ff1f 40f0      	SBCI R31,0
00ff20 9508      	RET
                 
                 __LSLD12:
00ff21 23ee      	TST  R30
00ff22 2e0e      	MOV  R0,R30
00ff23 01fd      	MOVW R30,R26
00ff24 01bc      	MOVW R22,R24
00ff25 f031      	BREQ __LSLD12R
                 __LSLD12L:
00ff26 0fee      	LSL  R30
00ff27 1fff      	ROL  R31
00ff28 1f66      	ROL  R22
00ff29 1f77      	ROL  R23
00ff2a 940a      	DEC  R0
00ff2b f7d1      	BRNE __LSLD12L
                 __LSLD12R:
00ff2c 9508      	RET
                 
                 __LSRD12:
00ff2d 23ee      	TST  R30
00ff2e 2e0e      	MOV  R0,R30
00ff2f 01fd      	MOVW R30,R26
00ff30 01bc      	MOVW R22,R24
00ff31 f031      	BREQ __LSRD12R
                 __LSRD12L:
00ff32 9576      	LSR  R23
00ff33 9567      	ROR  R22
00ff34 95f7      	ROR  R31
00ff35 95e7      	ROR  R30
00ff36 940a      	DEC  R0
00ff37 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
00ff38 9508      	RET
                 
                 __LSLD1:
00ff39 0fee      	LSL  R30
00ff3a 1fff      	ROL  R31
00ff3b 1f66      	ROL  R22
00ff3c 1f77      	ROL  R23
00ff3d 9508      	RET
                 
                 __LSRD16:
00ff3e 2fe6      	MOV  R30,R22
00ff3f 2ff7      	MOV  R31,R23
00ff40 e060      	LDI  R22,0
00ff41 e070      	LDI  R23,0
00ff42 9508      	RET
                 
                 __LSLD16:
00ff43 2f6e      	MOV  R22,R30
00ff44 2f7f      	MOV  R23,R31
00ff45 e0e0      	LDI  R30,0
00ff46 e0f0      	LDI  R31,0
00ff47 9508      	RET
                 
                 __CWD1:
00ff48 2f6f      	MOV  R22,R31
00ff49 0f66      	ADD  R22,R22
00ff4a 0b66      	SBC  R22,R22
00ff4b 2f76      	MOV  R23,R22
00ff4c 9508      	RET
                 
                 __MULW12U:
00ff4d 9ffa      	MUL  R31,R26
00ff4e 2df0      	MOV  R31,R0
00ff4f 9feb      	MUL  R30,R27
00ff50 0df0      	ADD  R31,R0
00ff51 9fea      	MUL  R30,R26
00ff52 2de0      	MOV  R30,R0
00ff53 0df1      	ADD  R31,R1
00ff54 9508      	RET
                 
                 __MULD12U:
00ff55 9f7a      	MUL  R23,R26
00ff56 2d70      	MOV  R23,R0
00ff57 9f6b      	MUL  R22,R27
00ff58 0d70      	ADD  R23,R0
00ff59 9ff8      	MUL  R31,R24
00ff5a 0d70      	ADD  R23,R0
00ff5b 9fe9      	MUL  R30,R25
00ff5c 0d70      	ADD  R23,R0
00ff5d 9f6a      	MUL  R22,R26
00ff5e 2d60      	MOV  R22,R0
00ff5f 0d71      	ADD  R23,R1
00ff60 9ffb      	MUL  R31,R27
00ff61 0d60      	ADD  R22,R0
00ff62 1d71      	ADC  R23,R1
00ff63 9fe8      	MUL  R30,R24
00ff64 0d60      	ADD  R22,R0
00ff65 1d71      	ADC  R23,R1
00ff66 2788      	CLR  R24
00ff67 9ffa      	MUL  R31,R26
00ff68 2df0      	MOV  R31,R0
00ff69 0d61      	ADD  R22,R1
00ff6a 1f78      	ADC  R23,R24
00ff6b 9feb      	MUL  R30,R27
00ff6c 0df0      	ADD  R31,R0
00ff6d 1d61      	ADC  R22,R1
00ff6e 1f78      	ADC  R23,R24
00ff6f 9fea      	MUL  R30,R26
00ff70 2de0      	MOV  R30,R0
00ff71 0df1      	ADD  R31,R1
00ff72 1f68      	ADC  R22,R24
00ff73 1f78      	ADC  R23,R24
00ff74 9508      	RET
                 
                 __MULB1W2U:
00ff75 2f6e      	MOV  R22,R30
00ff76 9f6a      	MUL  R22,R26
00ff77 01f0      	MOVW R30,R0
00ff78 9f6b      	MUL  R22,R27
00ff79 0df0      	ADD  R31,R0
00ff7a 9508      	RET
                 
                 __MULW12:
00ff7b d029      	RCALL __CHKSIGNW
00ff7c dfd0      	RCALL __MULW12U
00ff7d f40e      	BRTC __MULW121
00ff7e df9e      	RCALL __ANEGW1
                 __MULW121:
00ff7f 9508      	RET
                 
                 __DIVD21U:
00ff80 933f      	PUSH R19
00ff81 934f      	PUSH R20
00ff82 935f      	PUSH R21
00ff83 2400      	CLR  R0
00ff84 2411      	CLR  R1
00ff85 2744      	CLR  R20
00ff86 2755      	CLR  R21
00ff87 e230      	LDI  R19,32
                 __DIVD21U1:
00ff88 0faa      	LSL  R26
00ff89 1fbb      	ROL  R27
00ff8a 1f88      	ROL  R24
00ff8b 1f99      	ROL  R25
00ff8c 1c00      	ROL  R0
00ff8d 1c11      	ROL  R1
00ff8e 1f44      	ROL  R20
00ff8f 1f55      	ROL  R21
00ff90 1a0e      	SUB  R0,R30
00ff91 0a1f      	SBC  R1,R31
00ff92 0b46      	SBC  R20,R22
00ff93 0b57      	SBC  R21,R23
00ff94 f428      	BRCC __DIVD21U2
00ff95 0e0e      	ADD  R0,R30
00ff96 1e1f      	ADC  R1,R31
00ff97 1f46      	ADC  R20,R22
00ff98 1f57      	ADC  R21,R23
00ff99 c001      	RJMP __DIVD21U3
                 __DIVD21U2:
00ff9a 60a1      	SBR  R26,1
                 __DIVD21U3:
00ff9b 953a      	DEC  R19
00ff9c f759      	BRNE __DIVD21U1
00ff9d 01fd      	MOVW R30,R26
00ff9e 01bc      	MOVW R22,R24
00ff9f 01d0      	MOVW R26,R0
00ffa0 01ca      	MOVW R24,R20
00ffa1 915f      	POP  R21
00ffa2 914f      	POP  R20
00ffa3 913f      	POP  R19
00ffa4 9508      	RET
                 
                 __CHKSIGNW:
00ffa5 94e8      	CLT
00ffa6 fff7      	SBRS R31,7
00ffa7 c002      	RJMP __CHKSW1
00ffa8 df74      	RCALL __ANEGW1
00ffa9 9468      	SET
                 __CHKSW1:
00ffaa ffb7      	SBRS R27,7
00ffab c006      	RJMP __CHKSW2
00ffac 95a0      	COM  R26
00ffad 95b0      	COM  R27
00ffae 9611      	ADIW R26,1
00ffaf f800      	BLD  R0,0
00ffb0 9403      	INC  R0
00ffb1 fa00      	BST  R0,0
                 __CHKSW2:
00ffb2 9508      	RET
                 
                 __GETD1P_INC:
00ffb3 91ed      	LD   R30,X+
00ffb4 91fd      	LD   R31,X+
00ffb5 916d      	LD   R22,X+
00ffb6 917d      	LD   R23,X+
00ffb7 9508      	RET
                 
                 __PUTDP1_DEC:
00ffb8 937e      	ST   -X,R23
00ffb9 936e      	ST   -X,R22
00ffba 93fe      	ST   -X,R31
00ffbb 93ee      	ST   -X,R30
00ffbc 9508      	RET
                 
                 __GETD1S0:
00ffbd 81e8      	LD   R30,Y
00ffbe 81f9      	LDD  R31,Y+1
00ffbf 816a      	LDD  R22,Y+2
00ffc0 817b      	LDD  R23,Y+3
00ffc1 9508      	RET
                 
                 __GETD2S0:
00ffc2 81a8      	LD   R26,Y
00ffc3 81b9      	LDD  R27,Y+1
00ffc4 818a      	LDD  R24,Y+2
00ffc5 819b      	LDD  R25,Y+3
00ffc6 9508      	RET
                 
                 __PUTD1S0:
00ffc7 83e8      	ST   Y,R30
00ffc8 83f9      	STD  Y+1,R31
00ffc9 836a      	STD  Y+2,R22
00ffca 837b      	STD  Y+3,R23
00ffcb 9508      	RET
                 
                 __PUTPARD1:
00ffcc 937a      	ST   -Y,R23
00ffcd 936a      	ST   -Y,R22
00ffce 93fa      	ST   -Y,R31
00ffcf 93ea      	ST   -Y,R30
00ffd0 9508      	RET
                 
                 __PUTPARD2:
00ffd1 939a      	ST   -Y,R25
00ffd2 938a      	ST   -Y,R24
00ffd3 93ba      	ST   -Y,R27
00ffd4 93aa      	ST   -Y,R26
00ffd5 9508      	RET
                 
                 __CPD20:
00ffd6 9710      	SBIW R26,0
00ffd7 4080      	SBCI R24,0
00ffd8 4090      	SBCI R25,0
00ffd9 9508      	RET
                 
                 __CPD21:
00ffda 17ae      	CP   R26,R30
00ffdb 07bf      	CPC  R27,R31
00ffdc 0786      	CPC  R24,R22
00ffdd 0797      	CPC  R25,R23
00ffde 9508      	RET
                 
                 __SAVELOCR6:
00ffdf 935a      	ST   -Y,R21
                 __SAVELOCR5:
00ffe0 934a      	ST   -Y,R20
                 __SAVELOCR4:
00ffe1 933a      	ST   -Y,R19
                 __SAVELOCR3:
00ffe2 932a      	ST   -Y,R18
                 __SAVELOCR2:
00ffe3 931a      	ST   -Y,R17
00ffe4 930a      	ST   -Y,R16
00ffe5 9508      	RET
                 
                 __LOADLOCR6:
00ffe6 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
00ffe7 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
00ffe8 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
00ffe9 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
00ffea 8119      	LDD  R17,Y+1
00ffeb 8108      	LD   R16,Y
00ffec 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  50 r1 :  14 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   3 r9 :   0 r10:   0 r11:   4 r12:   5 r13:   2 r14:   0 r15:   0 
r16:  23 r17:  36 r18:  34 r19:  33 r20:  23 r21:  17 r22: 105 r23:  63 
r24:  48 r25:  29 r26: 180 r27:  83 r28:  19 r29:   5 r30: 422 r31: 139 
x  :  40 y  : 182 z  :  15 
Registers used: 25 out of 35 (71.4%)

ATmega128 instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  22 add   :  26 
adiw  :  21 and   :   0 andi  :  23 asr   :   0 bclr  :   0 bld   :   1 
brbc  :   0 brbs  :   0 brcc  :   1 brcs  :   0 break :   0 breq  :  27 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :   9 
brlt  :   0 brmi  :   0 brne  :  39 brpl  :   0 brsh  :  19 brtc  :   1 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   1 call  : 135 
cbi   :   6 cbr   :   0 clc   :   0 clh   :   0 cli   :   2 cln   :   0 
clr   :  17 cls   :   0 clt   :   1 clv   :   0 clz   :   0 com   :   2 
cp    :   6 cpc   :  32 cpi   :  49 cpse  :   0 dec   :   4 des   :   0 
elpm  :   9 eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   2 
ijmp  :   0 in    :   5 inc   :   2 jmp   :  43 ld    :  31 ldd   :  95 
ldi   : 236 lds   : 104 lpm   :   0 lsl   :   5 lsr   :   1 mov   :  37 
movw  :  49 mul   :  19 muls  :   0 mulsu :   0 neg   :   2 nop   :   0 
or    :  11 ori   :   2 out   :  16 pop   :   5 push  :   5 rcall :  72 
ret   :  68 reti  :   0 rjmp  :  66 rol   :  15 ror   :   3 sbc   :   4 
sbci  :  39 sbi   :   3 sbic  :   1 sbis  :   1 sbiw  :  12 sbr   :   1 
sbrc  :   0 sbrs  :   2 sec   :   0 seh   :   0 sei   :   1 sen   :   0 
ser   :   0 ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 
spm   :  18 st    :  81 std   :  21 sts   :  74 sub   :   1 subi  :  33 
swap  :   0 tst   :   2 wdr   :   4 
Instructions used: 66 out of 117 (56.4%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x01f000 0x01ffda   3990     68   4058  131072   3.1%
[.dseg] 0x000100 0x000b4f      0    591    591    4096  14.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 9 warnings
