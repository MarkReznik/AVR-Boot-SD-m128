
AVRASM ver. 2.1.30  F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm Fri Jul 19 14:51:04 2024

F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1100): warning: Register r4 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1101): warning: Register r5 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1102): warning: Register r6 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1103): warning: Register r7 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1104): warning: Register r9 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1105): warning: Register r8 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1106): warning: Register r11 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1107): warning: Register r12 already defined by the .DEF directive
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1108): warning: Register r13 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Debug
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 4.000000 MHz
                 ;Memory model           : Medium
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 2048 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_MEDIUM_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x10FF
                 	.EQU __DSTACK_SIZE=0x0800
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __GETBRPF
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETBRPF_INC
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z+
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test=R4
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test_msb=R5
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test=R6
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test_msb=R7
                 	.DEF _token=R9
                 	.DEF _SectorsPerCluster=R8
                 	.DEF _pagesCnt=R11
                 	.DEF _appPages=R12
                 	.DEF _appPages_msb=R13
                 
                 	.CSEG
                 	.ORG 0x00
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
000000 940c 0069 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0000 	JMP  0x00
00001a 940c 0000 	JMP  0x00
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 0000 	JMP  0x00
000022 940c 0000 	JMP  0x00
000024 940c 0000 	JMP  0x00
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
                 
                 _tbl10_G100:
000046 2710
000047 03e8
000048 0064
000049 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
00004a 0001      	.DB  0x1,0x0
                 _tbl16_G100:
00004b 1000
00004c 0100
00004d 0010
00004e 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
                 __REG_VARS:
00004f f9e0
000050 f9b4      	.DB  0xE0,0xF9,0xB4,0xF9
                 
                 _0x40000:
000051 2030
000052 2020
000053 2020
000054 2020      	.DB  0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20
000055 2020
000056 0020
000057 4c46
000058 5341      	.DB  0x20,0x20,0x20,0x0,0x46,0x4C,0x41,0x53
000059 2048
00005a 2020
F:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot_m128_v02\AVR-Boot-SD-m128\AVR106 BootSD_m128\Debug\List\Self_programming.asm(1166): warning: .cseg .db misalignment - padding zero byte
00005b 0000      	.DB  0x48,0x20,0x20,0x20,0x0
                 
                 __GLOBAL_INI_TBL:
00005c 0004      	.DW  0x04
00005d 0004      	.DW  0x04
00005e 009e 0000 	.DD  __REG_VARS*2
                 
000060 000c      	.DW  0x0C
000061 0900      	.DW  _0x4000E
000062 00a2 0000 	.DD  _0x40000*2
                 
000064 0009      	.DW  0x09
000065 090c      	.DW  _0x4000E+12
000066 00ae 0000 	.DD  _0x40000*2+12
                 
                 _0xFFFFFFFF:
000068 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
000069 94f8      	CLI
00006a 27ee      	CLR  R30
00006b bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
00006c e0f1      	LDI  R31,1
00006d bff5      	OUT  MCUCR,R31
00006e bfe5      	OUT  MCUCR,R30
00006f 93e0 006c 	STS  XMCRB,R30
                 
                 ;CLEAR R2-R14
000071 e08d      	LDI  R24,(14-2)+1
000072 e0a2      	LDI  R26,2
000073 27bb      	CLR  R27
                 __CLEAR_REG:
000074 93ed      	ST   X+,R30
000075 958a      	DEC  R24
000076 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000077 e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
000078 e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
000079 e0a0      	LDI  R26,LOW(__SRAM_START)
00007a e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
00007b 93ed      	ST   X+,R30
00007c 9701      	SBIW R24,1
00007d f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
00007e ebe8      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
00007f e0f0      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
000080 e0d0      	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
000081 bfdb      	OUT  RAMPZ,R29
000082 9187      	ELPM R24,Z+
000083 9197      	ELPM R25,Z+
000084 9700      	SBIW R24,0
000085 f081      	BREQ __GLOBAL_INI_END
000086 91a7      	ELPM R26,Z+
000087 91b7      	ELPM R27,Z+
000088 9007      	ELPM R0,Z+
000089 9017      	ELPM R1,Z+
00008a 91c7      	ELPM R28,Z+
00008b 91d7      	ELPM R29,Z+
00008c 01bf      	MOVW R22,R30
00008d b7db      	IN   R29,RAMPZ
00008e 01f0      	MOVW R30,R0
00008f bfcb      	OUT  RAMPZ,R28
                 __GLOBAL_INI_LOOP:
000090 9007      	ELPM R0,Z+
000091 920d      	ST   X+,R0
000092 9701      	SBIW R24,1
000093 f7e1      	BRNE __GLOBAL_INI_LOOP
000094 01fb      	MOVW R30,R22
000095 cfeb      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
000096 efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
000097 bfed      	OUT  SPL,R30
000098 e1e0      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
000099 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00009a e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00009b e0d9      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00009c 940c 01ee 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x900
                 
                 	.CSEG
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : All devices with bootloaders support.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains functions for easy reading and writing
                 ;*                       of Flash memory on parts having the "Self-programming"
                 ;*                       feature. The user functions are as follows:
                 ;*
                 ;*                       ReadFlashByte()
                 ;*                       ReadFlashPage()
                 ;*                       WriteFlashByte()
                 ;*                       WriteFlashPage()
                 ;*                       RecoverFlash()
                 ;*
                 ;*                       The remaining functions contained in this file are used
                 ;*                       by the functions listet above.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;//#include <inavr.h>
                 ;#include "Self_programming.h"
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include <delay.h>
                 ;
                 ;
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_W_Test)(void flash *addr)= (void(*)(void flash *)) 0x0F9E0;
                 ;void (*__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test)(void flash *addr, unsigned int data)= (void(*)(void flash *, unsigne ...
                 ;
                 ;
                 ;/*!
                 ;* Declare global struct variable in EEPROM if Flash recovery enabled.
                 ;* FlashBackup pageNumber holds Flash pageaddress (/PAGESIZE) the data in Flash
                 ;* recovery buffer should be written to if data need to be recovered.
                 ;* FlashBackup.status tells if data need to be recovered.
                 ;**/
                 ;#ifdef __FLASH_RECOVER
                 ;__eeprom struct {
                 ;  unsigned int  pageNumber;
                 ;  unsigned char status;
                 ;}FlashBackup = {0};
                 ;#endif
                 ;
                 ;void MY_FILL_TEMP_WORD(unsigned long addr,unsigned int data)
                 ; 0000 003A {
                 
                 	.CSEG
                 ; 0000 003B      _FILL_TEMP_WORD(addr,data);
                 ;	addr -> Y+2
                 ;	data -> Y+0
                 ; 0000 003C }
                 ;void MY_PAGE_ERASE(unsigned long addr)
                 ; 0000 003E {
                 ; 0000 003F      _PAGE_ERASE(addr);
                 ;	addr -> Y+0
                 ; 0000 0040 }
                 ;void MY_PAGE_WRITE(unsigned long addr)
                 ; 0000 0042 {
                 ; 0000 0043      _PAGE_WRITE(addr);
                 ;	addr -> Y+0
                 ; 0000 0044 }
                 ;/*!
                 ;* The function Returns one byte located on Flash address given by ucFlashStartAdr.
                 ;**/
                 ;unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0000 0048 unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 _ReadFlashByte:
                 ; .FSTART _ReadFlashByte
                 ; 0000 0049 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 004A   return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
00009e 940e 075d 	CALL __PUTPARD2
                 ;	flashStartAdr -> Y+0
0000a0 940e 059f 	CALL SUBOPT_0x0
                +
0000a2 bf6b     +OUT RAMPZ , R22
0000a3 91e6     +ELPM R30 , Z
                 	__GETBRPF 30
0000a4 940c 04a2 	JMP  _0x2060009
                 ; 0000 004B //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 004C } // Returns data from Flash
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads one Flash page from address flashStartAdr and stores data
                 ;* in array dataPage[]. The number of bytes stored is depending upon the
                 ;* Flash page size. The function returns FALSE if input address is not a Flash
                 ;* page address, else TRUE.
                 ;**/
                 ;unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 0054 unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 _ReadFlashPage:
                 ; .FSTART _ReadFlashPage
                 ; 0000 0055   unsigned int index;
                 ; 0000 0056   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
0000a6 93ba      	ST   -Y,R27
0000a7 93aa      	ST   -Y,R26
0000a8 931a      	ST   -Y,R17
0000a9 930a      	ST   -Y,R16
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
                +
0000aa 81ec     +LDD R30 , Y + 4
0000ab 81fd     +LDD R31 , Y + 4 + 1
0000ac 816e     +LDD R22 , Y + 4 + 2
0000ad 817f     +LDD R23 , Y + 4 + 3
                 	__GETD1S 4
0000ae 30e0      	CPI  R30,0
0000af f501      	BRNE _0x3
                 ; 0000 0057     for(index = 0; index < PAGESIZE; index++){
                +
0000b0 e000     +LDI R16 , LOW ( 0 )
0000b1 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x5:
                +
0000b2 3000     +CPI R16 , LOW ( 256 )
0000b3 e0e1     +LDI R30 , HIGH ( 256 )
0000b4 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
0000b5 f4b8      	BRSH _0x6
                 ; 0000 0058       dataPage[index] = ReadFlashByte(flashStartAdr + index);
0000b6 01f8      	MOVW R30,R16
0000b7 81aa      	LDD  R26,Y+2
0000b8 81bb      	LDD  R27,Y+2+1
0000b9 0fea      	ADD  R30,R26
0000ba 1ffb      	ADC  R31,R27
0000bb 93ff      	PUSH R31
0000bc 93ef      	PUSH R30
0000bd 01f8      	MOVW R30,R16
                +
0000be 81ac     +LDD R26 , Y + 4
0000bf 81bd     +LDD R27 , Y + 4 + 1
0000c0 818e     +LDD R24 , Y + 4 + 2
0000c1 819f     +LDD R25 , Y + 4 + 3
                 	__GETD2S 4
0000c2 2766      	CLR  R22
0000c3 2777      	CLR  R23
0000c4 940e 06bc 	CALL __ADDD21
0000c6 dfd7      	RCALL _ReadFlashByte
0000c7 91af      	POP  R26
0000c8 91bf      	POP  R27
0000c9 93ec      	ST   X,R30
                 ; 0000 0059     }
                +
0000ca 5f0f     +SUBI R16 , LOW ( - 1 )
0000cb 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0000cc cfe5      	RJMP _0x5
                 _0x6:
                 ; 0000 005A     return TRUE;                            // Return TRUE if valid page address
0000cd e0e1      	LDI  R30,LOW(1)
0000ce 940c 048c 	JMP  _0x206000A
                 ; 0000 005B   }
                 ; 0000 005C   else{
                 _0x3:
                 ; 0000 005D     return FALSE;                           // Return FALSE if not valid page address
0000d0 e0e0      	LDI  R30,LOW(0)
0000d1 940c 048c 	JMP  _0x206000A
                 ; 0000 005E   }
                 ; 0000 005F }
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function writes byte data to Flash address flashAddr. Returns FALSE if
                 ;* input address is not valid Flash byte address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0065 unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0066   MyAddressType  pageAdr;
                 ; 0000 0067   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 0068   if( AddressCheck( flashAddr & ~(PAGESIZE-1) )){
                 ;	flashAddr -> Y+7
                 ;	data -> Y+6
                 ;	pageAdr -> Y+2
                 ;	eepromInterruptSettings -> R17
                 ;	sregSettings -> R16
                 ; 0000 0069 
                 ; 0000 006A     eepromInterruptSettings= EECR & (1<<EERIE); // Stores EEPROM interrupt mask
                 ; 0000 006B     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
                 ; 0000 006C     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 ; 0000 006D 
                 ; 0000 006E     sregSettings= SREG;
                 ; 0000 006F     #asm("cli");
                 ; 0000 0070     pageAdr=flashAddr & ~(PAGESIZE-1);      // Gets Flash page address from byte address
                 ; 0000 0071 
                 ; 0000 0072     #ifdef __FLASH_RECOVER
                 ; 0000 0073     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 0074                                             // not contain data for writing
                 ; 0000 0075     while(EECR & (1<<EEWE));
                 ; 0000 0076     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0077     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 0078     FlashBackup.pageNumber = (unsigned int) (pageAdr/PAGESIZE); // Stores page address
                 ; 0000 0079                                                        // data should be written to
                 ; 0000 007A     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 007B                                                // contains unwritten data
                 ; 0000 007C     while(EECR & (1<<EEWE));
                 ; 0000 007D     #endif
                 ; 0000 007E 
                 ; 0000 007F     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0080 
                 ; 0000 0081 
                 ; 0000 0082     WriteBufToFlash(pageAdr);               // Writes to Flash
                 ; 0000 0083 
                 ; 0000 0084     #ifdef __FLASH_RECOVER
                 ; 0000 0085     FlashBackup.status = 0;                 // Indicates that Flash recovery buffer
                 ; 0000 0086                                             // does not contain unwritten data
                 ; 0000 0087     while(EECR & (1<<EEWE));
                 ; 0000 0088     #endif
                 ; 0000 0089 
                 ; 0000 008A     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 ; 0000 008B     SREG = sregSettings;
                 ; 0000 008C     return TRUE;                            // Return TRUE if address
                 ; 0000 008D                                             // valid for writing
                 ; 0000 008E   }
                 ; 0000 008F   else
                 ; 0000 0090     return FALSE;                           // Return FALSE if address not
                 ; 0000 0091                                             // valid for writing
                 ; 0000 0092 }
                 ;
                 ;/*!
                 ;* The function writes data from array dataPage[] to Flash page address
                 ;* flashStartAdr. The Number of bytes written is depending upon the Flash page
                 ;* size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
                 ;* page address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage)
                 ; 0000 009B {
                 _WriteFlashPage:
                 ; .FSTART _WriteFlashPage
                 ; 0000 009C   unsigned int index;
                 ; 0000 009D   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 009E   if( AddressCheck(flashStartAdr) ){
0000d3 93ba      	ST   -Y,R27
0000d4 93aa      	ST   -Y,R26
0000d5 940e 076d 	CALL __SAVELOCR4
                 ;	flashStartAdr -> Y+6
                 ;	*dataPage -> Y+4
                 ;	index -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	sregSettings -> R18
                +
0000d7 81ae     +LDD R26 , Y + 6
0000d8 81bf     +LDD R27 , Y + 6 + 1
0000d9 8588     +LDD R24 , Y + 6 + 2
0000da 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
0000db d058      	RCALL _AddressCheck
0000dc 30e0      	CPI  R30,0
0000dd f409      	BRNE PC+2
0000de c050      	RJMP _0xD
                 ; 0000 009F     eepromInterruptSettings = EECR & (1<<EERIE); // Stoes EEPROM interrupt mask
0000df b3ec      	IN   R30,0x1C
0000e0 70e8      	ANDI R30,LOW(0x8)
0000e1 2f3e      	MOV  R19,R30
                 ; 0000 00A0     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
0000e2 98e3      	CBI  0x1C,3
                 ; 0000 00A1     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 _0xE:
0000e3 99e1      	SBIC 0x1C,1
0000e4 cffe      	RJMP _0xE
                 ; 0000 00A2 
                 ; 0000 00A3     sregSettings= SREG;
0000e5 b72f      	IN   R18,63
                 ; 0000 00A4     #asm("cli");
0000e6 94f8      	cli
                 ; 0000 00A5 
                 ; 0000 00A6     #ifdef __FLASH_RECOVER
                 ; 0000 00A7     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00A8                                             // not contain data for writing
                 ; 0000 00A9     while(EECR & (1<<EEWE));
                 ; 0000 00AA 
                 ; 0000 00AB     //_ENABLE_RWW_SECTION();
                 ; 0000 00AC 
                 ; 0000 00AD     _WAIT_FOR_SPM();
                 ; 0000 00AE     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00AF 
                 ; 0000 00B0     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                 ; 0000 00B1       //_WAIT_FOR_SPM();
                 ; 0000 00B2       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B3       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B4     }
                 ; 0000 00B5 
                 ; 0000 00B6     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 00B7     FlashBackup.pageNumber=(unsigned int)(flashStartAdr/PAGESIZE);
                 ; 0000 00B8     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 00B9                                            // contains unwritten data
                 ; 0000 00BA     while(EECR & (1<<EEWE));
                 ; 0000 00BB     #endif
                 ; 0000 00BC 
                 ; 0000 00BD     if(index==0xFFF1)
0000e7 efe1      	LDI  R30,LOW(65521)
0000e8 efff      	LDI  R31,HIGH(65521)
0000e9 17e0      	CP   R30,R16
0000ea 07f1      	CPC  R31,R17
0000eb f491      	BRNE _0x11
                 ; 0000 00BE     {
                 ; 0000 00BF         __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
0000ec 940e 05a2 	CALL SUBOPT_0x1
0000ee e0a0      	LDI  R26,LOW(0)
0000ef e0b0      	LDI  R27,0
0000f0 940e 01b4 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00C0         __AddrToZ24ByteToSPMCR_SPM_W((void flash *)0x1EF00);
0000f2 940e 05a9 	CALL SUBOPT_0x2
0000f4 940e 01c4 	CALL ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0000 00C1         __AddrToZ24ByteToSPMCR_SPM_E((void flash *)0x1EF00);
0000f6 940e 05a9 	CALL SUBOPT_0x2
0000f8 940e 01d2 	CALL ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0000 00C2         __AddrToZ24ByteToSPMCR_SPM_EW((void flash *)0x1EF00);
0000fa 940e 05a9 	CALL SUBOPT_0x2
0000fc 940e 01e0 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 00C3     }
                 ; 0000 00C4     _WAIT_FOR_SPM();
                 _0x11:
                 _0x12:
0000fe 91e0 0068 	LDS  R30,104
000100 70e1      	ANDI R30,LOW(0x1)
000101 f7e1      	BRNE _0x12
                 ; 0000 00C5     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00C6     //_ENABLE_RWW_SECTION();
                 ; 0000 00C7 
                 ; 0000 00C8     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                +
000102 e000     +LDI R16 , LOW ( 0 )
000103 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x16:
                +
000104 3000     +CPI R16 , LOW ( 256 )
000105 e0e1     +LDI R30 , HIGH ( 256 )
000106 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
000107 f4e0      	BRSH _0x17
                 ; 0000 00C9       //_WAIT_FOR_SPM();
                 ; 0000 00CA       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00CB       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
000108 01f8      	MOVW R30,R16
000109 2766      	CLR  R22
00010a 2777      	CLR  R23
00010b 940e 0758 	CALL __PUTPARD1
00010d 01f8      	MOVW R30,R16
00010e 85a8      	LDD  R26,Y+8
00010f 85b9      	LDD  R27,Y+8+1
000110 0fae      	ADD  R26,R30
000111 1fbf      	ADC  R27,R31
000112 900c      	LD   R0,X
000113 2411      	CLR  R1
000114 9631      	ADIW R30,1
000115 85a8      	LDD  R26,Y+8
000116 85b9      	LDD  R27,Y+8+1
000117 0fae      	ADD  R26,R30
000118 1fbf      	ADC  R27,R31
000119 91ec      	LD   R30,X
00011a 2ffe      	MOV  R31,R30
00011b e0e0      	LDI  R30,0
00011c 01d0      	MOVW R26,R0
00011d 0fae      	ADD  R26,R30
00011e 1fbf      	ADC  R27,R31
00011f 940e 01b4 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00CC     }
                +
000121 5f0e     +SUBI R16 , LOW ( - 2 )
000122 4f1f     +SBCI R17 , HIGH ( - 2 )
                 	__ADDWRN 16,17,2
000123 cfe0      	RJMP _0x16
                 _0x17:
                 ; 0000 00CD     //_PAGE_WRITE( flashStartAdr );
                 ; 0000 00CE     WriteBufToFlash(flashStartAdr);         // Writes to Flash
                +
000124 81ae     +LDD R26 , Y + 6
000125 81bf     +LDD R27 , Y + 6 + 1
000126 8588     +LDD R24 , Y + 6 + 2
000127 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
000128 d025      	RCALL _WriteBufToFlash
                 ; 0000 00CF     #ifdef __FLASH_RECOVER
                 ; 0000 00D0       FlashBackup.status=0;                 // Inicate that Flash buffer does
                 ; 0000 00D1                                             // not contain data for writing
                 ; 0000 00D2       while(EECR & (1<<EEWE));
                 ; 0000 00D3     #endif
                 ; 0000 00D4 
                 ; 0000 00D5     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
000129 b3ec      	IN   R30,0x1C
00012a 2be3      	OR   R30,R19
00012b bbec      	OUT  0x1C,R30
                 ; 0000 00D6     SREG = sregSettings;
00012c bf2f      	OUT  0x3F,R18
                 ; 0000 00D7     return TRUE;                            // Return TRUE if address
00012d e0e1      	LDI  R30,LOW(1)
00012e c001      	RJMP _0x206000C
                 ; 0000 00D8                                             // valid for writing
                 ; 0000 00D9   }
                 ; 0000 00DA   else
                 _0xD:
                 ; 0000 00DB     return FALSE;                           // Return FALSE if not address not
00012f e0e0      	LDI  R30,LOW(0)
                 ; 0000 00DC                                             // valid for writing
                 ; 0000 00DD }
                 _0x206000C:
000130 940e 0774 	CALL __LOADLOCR4
000132 962a      	ADIW R28,10
000133 9508      	RET
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function checks if global variable FlashBackup.status indicates that Flash recovery
                 ;* buffer contains data that needs to be written to Flash. Writes data from
                 ;* Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
                 ;* This function should be called at program startup if FLASH recovery option
                 ;* is enabeled.
                 ;**/
                 ;unsigned char RecoverFlash(){
                 ; 0000 00E6 unsigned char RecoverFlash(){
                 ; 0000 00E7 #ifdef __FLASH_RECOVER
                 ; 0000 00E8   unsigned int index;
                 ; 0000 00E9   unsigned long flashStartAdr = (MyAddressType)FlashBackup.pageNumber * PAGESIZE;
                 ; 0000 00EA   if(FlashBackup.status == FLASH_BUFFER_FULL_ID){ // Checks if Flash recovery
                 ; 0000 00EB                                                   //  buffer contains data
                 ; 0000 00EC 
                 ; 0000 00ED     for(index=0; index < PAGESIZE; index+=2){     // Writes to Flash write buffer
                 ; 0000 00EE         _WAIT_FOR_SPM();
                 ; 0000 00EF         MY_FILL_TEMP_WORD( index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER+index)) );
                 ; 0000 00F0     }
                 ; 0000 00F1 
                 ; 0000 00F2 
                 ; 0000 00F3     //WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
                 ; 0000 00F4     _WAIT_FOR_SPM();
                 ; 0000 00F5     MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 00F6     _WAIT_FOR_SPM();
                 ; 0000 00F7     MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 00F8     _WAIT_FOR_SPM();
                 ; 0000 00F9     _ENABLE_RWW_SECTION();
                 ; 0000 00FA     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00FB                                             // not contain data for writing
                 ; 0000 00FC     while(EECR & (1<<EEWE));
                 ; 0000 00FD     return TRUE;                            // Returns TRUE if recovery has
                 ; 0000 00FE                                             // taken place
                 ; 0000 00FF   }
                 ; 0000 0100 #endif
                 ; 0000 0101   return FALSE;
                 ; 0000 0102 }
                 ;
                 ;
                 ;/*!
                 ;* The function checks if input argument is a valid Flash page address for
                 ;* writing. Returns TRUE only if:
                 ;* - Address points to the beginning of a Flash page
                 ;* - Address is within the limits defined in Self_programming.h
                 ;* - Address is not equal to page address used for buffring by the Flash recovery
                 ;*   functions (if enabled).
                 ;* Returns FALSE else.
                 ;**/
                 ;unsigned char AddressCheck(MyAddressType flashAdr){
                 ; 0000 010E unsigned char AddressCheck(MyAddressType flashAdr){
                 _AddressCheck:
                 ; .FSTART _AddressCheck
                 ; 0000 010F   #ifdef __FLASH_RECOVER
                 ; 0000 0110   // The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
                 ; 0000 0111   if( (flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
                 ; 0000 0112       (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE-1)) )
                 ; 0000 0113     return TRUE;                            // Address is a valid page address
                 ; 0000 0114   else
                 ; 0000 0115     return FALSE;                           // Address is not a valid page address
                 ; 0000 0116   #else
                 ; 0000 0117   if((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE-1) ) )
000134 940e 05ae 	CALL SUBOPT_0x3
                 ;	flashAdr -> Y+0
000136 940e 0762 	CALL __CPD20
000138 f070      	BRLO _0x1A
000139 940e 05b3 	CALL SUBOPT_0x4
                +
00013b 30a0     +CPI R26 , LOW ( 0x1F000 )
00013c efe0     +LDI R30 , HIGH ( 0x1F000 )
00013d 07be     +CPC R27 , R30
00013e e0e1     +LDI R30 , BYTE3 ( 0x1F000 )
00013f 078e     +CPC R24 , R30
000140 e0e0     +LDI R30 , BYTE4 ( 0x1F000 )
000141 079e     +CPC R25 , R30
                 	__CPD2N 0x1F000
000142 f420      	BRSH _0x1A
000143 940e 059f 	CALL SUBOPT_0x0
000145 30e0      	CPI  R30,0
000146 f009      	BREQ _0x1B
                 _0x1A:
000147 c003      	RJMP _0x19
                 _0x1B:
                 ; 0000 0118     return TRUE;                            // Address is a valid page address
000148 e0e1      	LDI  R30,LOW(1)
000149 940c 04a2 	JMP  _0x2060009
                 ; 0000 0119   else
                 _0x19:
                 ; 0000 011A   {
                 ; 0000 011B     /*
                 ; 0000 011C     while(1)
                 ; 0000 011D     {
                 ; 0000 011E       PORTC.5=0;
                 ; 0000 011F       delay_ms(500);
                 ; 0000 0120       PORTC.5=1;
                 ; 0000 0121       delay_ms(500);
                 ; 0000 0122     }
                 ; 0000 0123     */
                 ; 0000 0124     return FALSE;                           // Address is not a valid page address
00014b e0e0      	LDI  R30,LOW(0)
00014c 940c 04a2 	JMP  _0x2060009
                 ; 0000 0125   }
                 ; 0000 0126   #endif
                 ; 0000 0127 }
                 ; .FEND
                 ;
                 ;
                 ;/*!
                 ;* The function writes Flash temporary buffer to Flash page address given by
                 ;* input argument.
                 ;**/
                 ;
                 ;void WriteBufToFlash(MyAddressType flashStartAdr) {
                 ; 0000 012F void WriteBufToFlash(MyAddressType flashStartAdr) {
                 _WriteBufToFlash:
                 ; .FSTART _WriteBufToFlash
                 ; 0000 0130     //_WAIT_FOR_SPM();
                 ; 0000 0131     //MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 0132     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 0133     //_WAIT_FOR_SPM();
                 ; 0000 0134     //_ENABLE_RWW_SECTION();
                 ; 0000 0135     //MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 0136     _PAGE_WRITE( flashStartAdr );
00014e 940e 05ae 	CALL SUBOPT_0x3
                 ;	flashStartAdr -> Y+0
000150 940e 01e0 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 0137     //_WAIT_FOR_SPM();
                 ; 0000 0138     //_ENABLE_RWW_SECTION();
                 ; 0000 0139 /*
                 ; 0000 013A #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 013B   #ifdef __HAS_RAMPZ__
                 ; 0000 013C   RAMPZ = (unsigned char)(flashStartAdr >> 16);
                 ; 0000 013D   #endif
                 ; 0000 013E   _PAGE_ERASE(flashStartAdr);
                 ; 0000 013F   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0140   _PAGE_WRITE(flashStartAdr);
                 ; 0000 0141   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0142   #ifdef RWWSRE
                 ; 0000 0143   __DataToR0ByteToSPMCR_SPM( 0, (unsigned char)(1<<RWWSRE)|(1<<SPMEN)); // Enable RWW
                 ; 0000 0144   #endif
                 ; 0000 0145 #pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0146 */
                 ; 0000 0147 }
000152 940c 04a2 	JMP  _0x2060009
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads Flash page given by flashAddr, replaces one byte given by
                 ;* flashAddr with data, and stores entire page in Flash temporary buffer.
                 ;**/
                 ;void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014D void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014E //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 014F     unsigned int index, oddByte, pcWord;
                 ; 0000 0150 
                 ; 0000 0151     MyAddressType  pageAdr;
                 ; 0000 0152     oddByte=(unsigned char)flashAddr & 1;
                 ;	flashAddr -> Y+11
                 ;	data -> Y+10
                 ;	index -> R16,R17
                 ;	oddByte -> R18,R19
                 ;	pcWord -> R20,R21
                 ;	pageAdr -> Y+6
                 ; 0000 0153     pcWord=(unsigned int)flashAddr & (PAGESIZE-2); // Used when writing FLASH temp buffer
                 ; 0000 0154     pageAdr=flashAddr & ~(PAGESIZE-1);        // Get FLASH page address from byte address
                 ; 0000 0155     //while( SPMCR_REG & (1<<SPMEN) );
                 ; 0000 0156     //_ENABLE_RWW_SECTION();
                 ; 0000 0157 
                 ; 0000 0158     for(index=0; index < PAGESIZE; index+=2){
                 ; 0000 0159         if(index==pcWord){
                 ; 0000 015A           if(oddByte){
                 ; 0000 015B             //MY_FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015C             _FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015D           }                                     // Write odd byte in temporary buffer
                 ; 0000 015E           else{
                 ; 0000 015F             //MY_FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0160             _FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0161           }                                     // Write even byte in temporary buffer
                 ; 0000 0162         }
                 ; 0000 0163         else{
                 ; 0000 0164           //MY_FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0165           _FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0166         }                                       // Write Flash word directly to temporary buffer
                 ; 0000 0167     }
                 ; 0000 0168 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0169 }
                 ;/*****************************************************************************
                 ;*
                 ;* (C) 2010, HP InfoTech srl, www.hpinfotech.com
                 ;*
                 ;* File              : flash.c
                 ;* Compiler          : CodeVisionAVR V2.xx
                 ;* Revision          : $Revision: 1.0 $
                 ;* Date              : $Date: December 9, 2010 $
                 ;* Updated by        : $Author: HP InfoTech $
                 ;*
                 ;* Target platform   : All AVRs with bootloader support
                 ;*
                 ;* AppNote           : AVR109 - Self-programming
                 ;*
                 ;* Description       : Flash operations for AVR109 Self-programming
                 ;****************************************************************************/
                 ;
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;
                 ;//#define	SPMCR_REG	SPMCSR
                 ;
                 ;void dospmew(void)
                 ; 0001 0018 {
                 
                 	.CSEG
                 _dospmew:
                 ; .FSTART _dospmew
                 ; 0001 0019     #asm
                 ; 0001 001A          ldi   r22,$03
000154 e063               ldi   r22,$03
                 ; 0001 001B          WR_SPMCR_REG_R22
000155 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 001C          spm
000157 95e8               spm
                 ; 0001 001D     #endasm
                 ; 0001 001E     _WAIT_FOR_SPM();
                 _0x20003:
000158 91e0 0068 	LDS  R30,104
00015a 70e1      	ANDI R30,LOW(0x1)
00015b f7e1      	BRNE _0x20003
                 ; 0001 001F     #asm
                 ; 0001 0020         ldi   r22,$05
00015c e065              ldi   r22,$05
                 ; 0001 0021         WR_SPMCR_REG_R22
00015d 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0022         spm
00015f 95e8              spm
                 ; 0001 0023     #endasm
                 ; 0001 0024     _WAIT_FOR_SPM();
                 _0x20006:
000160 91e0 0068 	LDS  R30,104
000162 70e1      	ANDI R30,LOW(0x1)
000163 f7e1      	BRNE _0x20006
                 ; 0001 0025     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20009:
000164 91e0 0068 	LDS  R30,104
000166 74e0      	ANDI R30,LOW(0x40)
000167 f049      	BREQ _0x2000B
                 ; 0001 0026     {
                 ; 0001 0027     #asm
                 ; 0001 0028         ldi   r22,$11
000168 e161              ldi   r22,$11
                 ; 0001 0029         WR_SPMCR_REG_R22
000169 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 002A         spm
00016b 95e8              spm
                 ; 0001 002B     #endasm
                 ; 0001 002C         _WAIT_FOR_SPM();
                 _0x2000C:
00016c 91e0 0068 	LDS  R30,104
00016e 70e1      	ANDI R30,LOW(0x1)
00016f f7e1      	BRNE _0x2000C
                 ; 0001 002D     }
000170 cff3      	RJMP _0x20009
                 _0x2000B:
                 ; 0001 002E }
000171 9508      	RET
                 ; .FEND
                 ;
                 ;void dospmw(void)
                 ; 0001 0031 {
                 _dospmw:
                 ; .FSTART _dospmw
                 ; 0001 0032     #asm
                 ; 0001 0033         ldi   r22,$05
000172 e065              ldi   r22,$05
                 ; 0001 0034         WR_SPMCR_REG_R22
000173 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0035         spm
000175 95e8              spm
                 ; 0001 0036     #endasm
                 ; 0001 0037     _WAIT_FOR_SPM();
                 _0x2000F:
000176 91e0 0068 	LDS  R30,104
000178 70e1      	ANDI R30,LOW(0x1)
000179 f7e1      	BRNE _0x2000F
                 ; 0001 0038     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20012:
00017a 91e0 0068 	LDS  R30,104
00017c 74e0      	ANDI R30,LOW(0x40)
00017d f049      	BREQ _0x20014
                 ; 0001 0039     {
                 ; 0001 003A     #asm
                 ; 0001 003B         ldi   r22,$11
00017e e161              ldi   r22,$11
                 ; 0001 003C         WR_SPMCR_REG_R22
00017f 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 003D         spm
000181 95e8              spm
                 ; 0001 003E     #endasm
                 ; 0001 003F         _WAIT_FOR_SPM();
                 _0x20015:
000182 91e0 0068 	LDS  R30,104
000184 70e1      	ANDI R30,LOW(0x1)
000185 f7e1      	BRNE _0x20015
                 ; 0001 0040     }
000186 cff3      	RJMP _0x20012
                 _0x20014:
                 ; 0001 0041 }
000187 9508      	RET
                 ; .FEND
                 ;
                 ;void dospme(void)
                 ; 0001 0044 {
                 _dospme:
                 ; .FSTART _dospme
                 ; 0001 0045     #asm
                 ; 0001 0046         ldi   r22,$03
000188 e063              ldi   r22,$03
                 ; 0001 0047         WR_SPMCR_REG_R22
000189 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0048         spm
00018b 95e8              spm
                 ; 0001 0049     #endasm
                 ; 0001 004A     _WAIT_FOR_SPM();
                 _0x20018:
00018c 91e0 0068 	LDS  R30,104
00018e 70e1      	ANDI R30,LOW(0x1)
00018f f7e1      	BRNE _0x20018
                 ; 0001 004B     while( SPMCR_REG & (1<<RWWSB) )
                 _0x2001B:
000190 91e0 0068 	LDS  R30,104
000192 74e0      	ANDI R30,LOW(0x40)
000193 f049      	BREQ _0x2001D
                 ; 0001 004C     {
                 ; 0001 004D     #asm
                 ; 0001 004E         ldi   r22,$11
000194 e161              ldi   r22,$11
                 ; 0001 004F         WR_SPMCR_REG_R22
000195 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0050         spm
000197 95e8              spm
                 ; 0001 0051     #endasm
                 ; 0001 0052         _WAIT_FOR_SPM();
                 _0x2001E:
000198 91e0 0068 	LDS  R30,104
00019a 70e1      	ANDI R30,LOW(0x1)
00019b f7e1      	BRNE _0x2001E
                 ; 0001 0053     }
00019c cff3      	RJMP _0x2001B
                 _0x2001D:
                 ; 0001 0054 }
00019d 9508      	RET
                 ; .FEND
                 ;
                 ;void dospm(void)
                 ; 0001 0057 {
                 _dospm:
                 ; .FSTART _dospm
                 ; 0001 0058     #asm
                 ; 0001 0059          ldi   r22,$01
00019e e061               ldi   r22,$01
                 ; 0001 005A          WR_SPMCR_REG_R22
00019f 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 005B          spm
0001a1 95e8               spm
                 ; 0001 005C     #endasm
                 ; 0001 005D     _WAIT_FOR_SPM();
                 _0x20021:
0001a2 91e0 0068 	LDS  R30,104
0001a4 70e1      	ANDI R30,LOW(0x1)
0001a5 f7e1      	BRNE _0x20021
                 ; 0001 005E     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20024:
0001a6 91e0 0068 	LDS  R30,104
0001a8 74e0      	ANDI R30,LOW(0x40)
0001a9 f049      	BREQ _0x20026
                 ; 0001 005F     {
                 ; 0001 0060     #asm
                 ; 0001 0061         ldi   r22,$11
0001aa e161              ldi   r22,$11
                 ; 0001 0062         WR_SPMCR_REG_R22
0001ab 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0063         spm
0001ad 95e8              spm
                 ; 0001 0064     #endasm
                 ; 0001 0065         _WAIT_FOR_SPM();
                 _0x20027:
0001ae 91e0 0068 	LDS  R30,104
0001b0 70e1      	ANDI R30,LOW(0x1)
0001b1 f7e1      	BRNE _0x20027
                 ; 0001 0066     }
0001b2 cff3      	RJMP _0x20024
                 _0x20026:
                 ; 0001 0067 }
0001b3 9508      	RET
                 ; .FEND
                 ;
                 ;#pragma warn-
                 ;
                 ;unsigned char __AddrToZByteToSPMCR_LPM(void flash *addr, unsigned char ctrl)
                 ; 0001 006C {
                 ; 0001 006D #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 006E      ldd  r30,y+1
                 ; 0001 006F      ldd  r31,y+2
                 ; 0001 0070      ld   r22,y
                 ; 0001 0071      WR_SPMCR_REG_R22
                 ; 0001 0072      lpm
                 ; 0001 0073      mov  r30,r0
                 ; 0001 0074 #endasm
                 ; 0001 0075 }
                 ;
                 ;void __DataToR0ByteToSPMCR_SPM(unsigned char data, unsigned char ctrl)
                 ; 0001 0078 {
                 ; 0001 0079 #asm
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 007A      ldd  r0,y+1
                 ; 0001 007B      ld   r22,y
                 ; 0001 007C      WR_SPMCR_REG_R22
                 ; 0001 007D      spm
                 ; 0001 007E #endasm
                 ; 0001 007F }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 0082 {
                 ; 0001 0083     #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 0084          ldd  r30,y+3
                 ; 0001 0085          ldd  r31,y+4
                 ; 0001 0086          ldd  r0,y+1
                 ; 0001 0087          ldd  r1,y+2
                 ; 0001 0088          ld   r22,y
                 ; 0001 0089          WR_SPMCR_REG_R22
                 ; 0001 008A          spm
                 ; 0001 008B     #endasm
                 ; 0001 008C }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 008F {
                 ; 0001 0090 _WAIT_FOR_SPM();
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 ; 0001 0091     #asm
                 ; 0001 0092          ldd  r30,y+2
                 ; 0001 0093          ldd  r31,y+3
                 ; 0001 0094          ldd  r0,y+0
                 ; 0001 0095          ldd  r1,y+1
                 ; 0001 0096          //ldi   r22,LOW(1)
                 ; 0001 0097          //WR_SPMCR_REG_R22
                 ; 0001 0098          //spm
                 ; 0001 0099     #endasm
                 ; 0001 009A dospm();
                 ; 0001 009B }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 009E {
                 ; 0001 009F #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00A0      ldd  r30,y+1
                 ; 0001 00A1      ldd  r31,y+2
                 ; 0001 00A2      ld   r22,y
                 ; 0001 00A3      WR_SPMCR_REG_R22
                 ; 0001 00A4      spm
                 ; 0001 00A5 #endasm
                 ; 0001 00A6 }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00A9 {
                 ; 0001 00AA _WAIT_FOR_SPM();
                 ;	*addr -> Y+0
                 ; 0001 00AB #asm
                 ; 0001 00AC      ldd  r30,y+0
                 ; 0001 00AD      ldd  r31,y+1
                 ; 0001 00AE      //ld   r22,y
                 ; 0001 00AF      //WR_SPMCR_REG_R22
                 ; 0001 00B0      //spm
                 ; 0001 00B1 #endasm
                 ; 0001 00B2 dospmew();
                 ; 0001 00B3 }
                 ;
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 00B7 {
                 ; 0001 00B8 #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00B9      ldd  r30,y+3
                 ; 0001 00BA      ldd  r31,y+4
                 ; 0001 00BB      ldd  r22,y+5
                 ; 0001 00BC      out  rampz,r22
                 ; 0001 00BD      ldd  r0,y+1
                 ; 0001 00BE      ldd  r1,y+2
                 ; 0001 00BF      ld   r22,y
                 ; 0001 00C0      WR_SPMCR_REG_R22
                 ; 0001 00C1      spm
                 ; 0001 00C2 #endasm
                 ; 0001 00C3 }
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 00C6 {
                 ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F:
                 ; .FSTART ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0001 00C7 _WAIT_FOR_SPM();
0001b4 93ba      	ST   -Y,R27
0001b5 93aa      	ST   -Y,R26
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 _0x20030:
0001b6 91e0 0068 	LDS  R30,104
0001b8 70e1      	ANDI R30,LOW(0x1)
0001b9 f7e1      	BRNE _0x20030
                 ; 0001 00C8 #asm
                 ; 0001 00C9      ldd  r30,y+2
0001ba 81ea           ldd  r30,y+2
                 ; 0001 00CA      ldd  r31,y+3
0001bb 81fb           ldd  r31,y+3
                 ; 0001 00CB      ldd  r22,y+4
0001bc 816c           ldd  r22,y+4
                 ; 0001 00CC      out  rampz,r22
0001bd bf6b           out  rampz,r22
                 ; 0001 00CD      ldd  r0,y+0
0001be 8008           ldd  r0,y+0
                 ; 0001 00CE      ldd  r1,y+1
0001bf 8019           ldd  r1,y+1
                 ; 0001 00CF      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00D0      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00D1      //spm
                      //spm
                 ; 0001 00D2 #endasm
                 ; 0001 00D3 dospm();
0001c0 940e 019e 	CALL _dospm
                 ; 0001 00D4 }
0001c2 940c 053f 	JMP  _0x2060003
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 00D7 {
                 ; 0001 00D8 #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00D9      ldd  r30,y+1
                 ; 0001 00DA      ldd  r31,y+2
                 ; 0001 00DB      ldd  r22,y+3
                 ; 0001 00DC      out  rampz,r22
                 ; 0001 00DD      ld   r22,y
                 ; 0001 00DE      WR_SPMCR_REG_R22
                 ; 0001 00DF      spm
                 ; 0001 00E0 #endasm
                 ; 0001 00E1 }
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00E4 {
                 ___AddrToZ24ByteToSPMCR_SPM_W:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0001 00E5 _WAIT_FOR_SPM();
0001c4 940e 075d 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20033:
0001c6 91e0 0068 	LDS  R30,104
0001c8 70e1      	ANDI R30,LOW(0x1)
0001c9 f7e1      	BRNE _0x20033
                 ; 0001 00E6 #asm
                 ; 0001 00E7      ldd  r30,y+0
0001ca 81e8           ldd  r30,y+0
                 ; 0001 00E8      ldd  r31,y+1
0001cb 81f9           ldd  r31,y+1
                 ; 0001 00E9      ldd  r22,y+2
0001cc 816a           ldd  r22,y+2
                 ; 0001 00EA      out  rampz,r22
0001cd bf6b           out  rampz,r22
                 ; 0001 00EB      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00EC      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00ED      //spm
                      //spm
                 ; 0001 00EE #endasm
                 ; 0001 00EF dospmw();
0001ce 940e 0172 	CALL _dospmw
                 ; 0001 00F0 }
0001d0 940c 04a2 	JMP  _0x2060009
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_E(void flash *addr)
                 ; 0001 00F3 {
                 ___AddrToZ24ByteToSPMCR_SPM_E:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0001 00F4 _WAIT_FOR_SPM();
0001d2 940e 075d 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20036:
0001d4 91e0 0068 	LDS  R30,104
0001d6 70e1      	ANDI R30,LOW(0x1)
0001d7 f7e1      	BRNE _0x20036
                 ; 0001 00F5 #asm
                 ; 0001 00F6      ldd  r30,y+0
0001d8 81e8           ldd  r30,y+0
                 ; 0001 00F7      ldd  r31,y+1
0001d9 81f9           ldd  r31,y+1
                 ; 0001 00F8      ldd  r22,y+2
0001da 816a           ldd  r22,y+2
                 ; 0001 00F9      out  rampz,r22
0001db bf6b           out  rampz,r22
                 ; 0001 00FA      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00FB      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00FC      //spm
                      //spm
                 ; 0001 00FD #endasm
                 ; 0001 00FE dospme();
0001dc 940e 0188 	CALL _dospme
                 ; 0001 00FF }
0001de 940c 04a2 	JMP  _0x2060009
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_EW(void flash *addr)
                 ; 0001 0102 {
                 ___AddrToZ24ByteToSPMCR_SPM_EW:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0001 0103 _WAIT_FOR_SPM();
0001e0 940e 075d 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20039:
0001e2 91e0 0068 	LDS  R30,104
0001e4 70e1      	ANDI R30,LOW(0x1)
0001e5 f7e1      	BRNE _0x20039
                 ; 0001 0104 #asm
                 ; 0001 0105      ldd  r30,y+0
0001e6 81e8           ldd  r30,y+0
                 ; 0001 0106      ldd  r31,y+1
0001e7 81f9           ldd  r31,y+1
                 ; 0001 0107      ldd  r22,y+2
0001e8 816a           ldd  r22,y+2
                 ; 0001 0108      out  rampz,r22
0001e9 bf6b           out  rampz,r22
                 ; 0001 0109      //ld   r22,y
                      //ld   r22,y
                 ; 0001 010A      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 010B      //spm
                      //spm
                 ; 0001 010C #endasm
                 ; 0001 010D dospmew();
0001ea 940e 0154 	CALL _dospmew
                 ; 0001 010E }
0001ec 940c 04a2 	JMP  _0x2060009
                 ; .FEND
                 ;
                 ;#ifdef _WARNINGS_ON_
                 ;#pragma warn+
                 ;#endif
                 ;
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming_main.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : This example is written for ATmega128.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains an example program using the Flash R/W
                 ;*                       functions provided with the files Self_programming.h /
                 ;*                       Self_programming.c . The program should be compiled using
                 ;*                       a linker file (*.xcl) that is configured to place the
                 ;*                       entire program code into the Boot section of the Flash memory.
                 ;*                       Please refer to the application note document for more
                 ;*                       information.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;*****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include "Self_programming.h"
                 ;//#include <ff.h>
                 ;/* printf */
                 ;#include <stdio.h>
                 ;#include <string.h>
                 ;
                 ;#include "spi_sdcard.h"
                 ;
                 ;#define SDBUF_SIZE  512
                 ;#define PAGES_PER_SDBUF (SDBUF_SIZE/PAGESIZE)
                 ;
                 ;unsigned char result[5], sdBuf[SDBUF_SIZE], testBuf[PAGESIZE], token, SectorsPerCluster, pagesCnt;
                 ;unsigned long appStartAdr,adr,SectorsPerFat,fat_begin_lba;
                 ;unsigned long cluster_begin_lba,root_dir_first_cluster,fat_file_adr,fat_file_next_adr,filesize,readbytes;
                 ;unsigned int appPages,bytesChecksum,checksumCnt;
                 ;//(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ;//(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FA ...
                 ;//(unsigned char)sectors_per_cluster = BPB_SecPerClus;
                 ;//(unsigned long)root_dir_first_cluster = BPB_RootClus;
                 ;void testWrite();
                 ;void errorSD(unsigned char err);
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len);
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest);
                 ;void (*app_pointer)(void) = (void(*)(void))0x0000;
                 ;
                 ;void main( void ){
                 ; 0002 0038 void main( void ){
                 
                 	.CSEG
                 _main:
                 ; .FSTART _main
                 ; 0002 0039 
                 ; 0002 003A   unsigned int i,j;
                 ; 0002 003B 
                 ; 0002 003C /* globally enable interrupts */
                 ; 0002 003D #asm("sei")
                 ;	i -> R16,R17
                 ;	j -> R18,R19
0001ee 9478      	sei
                 ; 0002 003E 
                 ; 0002 003F   DDRC=0xFF;
0001ef efef      	LDI  R30,LOW(255)
0001f0 bbe4      	OUT  0x14,R30
                 ; 0002 0040   PORTC=0xFF;
0001f1 bbe5      	OUT  0x15,R30
                 ; 0002 0041   /*
                 ; 0002 0042     do
                 ; 0002 0043     {
                 ; 0002 0044       PORTC.6=0;
                 ; 0002 0045       delay_ms(500);
                 ; 0002 0046       PORTC.6=1;
                 ; 0002 0047       delay_ms(500);
                 ; 0002 0048     }while(1);
                 ; 0002 0049   */
                 ; 0002 004A   //init SD
                 ; 0002 004B   if((result[0]=SD_init())!=SD_SUCCESS)
0001f2 d310      	RCALL _SD_init
0001f3 93e0 0915 	STS  _result,R30
0001f5 30e0      	CPI  R30,0
0001f6 f011      	BREQ _0x40003
                 ; 0002 004C     errorSD(0);
0001f7 e0a0      	LDI  R26,LOW(0)
0001f8 d217      	RCALL _errorSD
                 ; 0002 004D 
                 ; 0002 004E   // read MBR get FAT start sector
                 ; 0002 004F   if((result[0]=SD_readSingleBlock(0, sdBuf, &token))!=SD_SUCCESS)
                 _0x40003:
0001f9 940e 05a2 	CALL SUBOPT_0x1
0001fb 940e 05b6 	CALL SUBOPT_0x5
0001fd f011      	BREQ _0x40004
                 ; 0002 0050     errorSD(1);
0001fe e0a1      	LDI  R26,LOW(1)
0001ff d210      	RCALL _errorSD
                 ; 0002 0051 
                 ; 0002 0052   adr=buf2num(&sdBuf[445+9],4);//FAT start sector. 1 sector = 512 bytes
                 _0x40004:
                +
000200 eee0     +LDI R30 , LOW ( _sdBuf + ( 454 ) )
000201 e0fa     +LDI R31 , HIGH ( _sdBuf + ( 454 ) )
                 	__POINTW1MN _sdBuf,454
000202 940e 05c2 	CALL SUBOPT_0x6
000204 940e 05c7 	CALL SUBOPT_0x7
                 ; 0002 0053 
                 ; 0002 0054   //load and read FAT ID (1st) sector. Get FAT info. Secors per Cluster and etc..
                 ; 0002 0055   if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
000206 940e 05d0 	CALL SUBOPT_0x8
000208 940e 05d9 	CALL SUBOPT_0x9
00020a f011      	BREQ _0x40005
                 ; 0002 0056     errorSD(2);
00020b e0a2      	LDI  R26,LOW(2)
00020c d203      	RCALL _errorSD
                 ; 0002 0057   }
                 ; 0002 0058 
                 ; 0002 0059   SectorsPerCluster=sdBuf[0x0D];// 8 sectors per cluster
                 _0x40005:
                +
00020d 9080 0927+LDS R8 , _sdBuf + ( 13 )
                 	__GETBRMN 8,_sdBuf,13
                 ; 0002 005A   SectorsPerFat=buf2num(&sdBuf[0x24],4); // 0xF10 for test sdcard
                +
00020f e3ee     +LDI R30 , LOW ( _sdBuf + ( 36 ) )
000210 e0f9     +LDI R31 , HIGH ( _sdBuf + ( 36 ) )
                 	__POINTW1MN _sdBuf,36
000211 940e 05c2 	CALL SUBOPT_0x6
000213 93e0 0c22 	STS  _SectorsPerFat,R30
000215 93f0 0c23 	STS  _SectorsPerFat+1,R31
000217 9360 0c24 	STS  _SectorsPerFat+2,R22
000219 9370 0c25 	STS  _SectorsPerFat+3,R23
                 ; 0002 005B 
                 ; 0002 005C   //read the FAT fils/directories info from Root Directory cluster (usually 2),Number_of_Reserved_Sectors (usually 0x20) ...
                 ; 0002 005D   //(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ; 0002 005E   fat_begin_lba=adr+0x20;//first sector of FAT data
00021b 940e 05d0 	CALL SUBOPT_0x8
                +
00021d 5ee0     +SUBI R30 , LOW ( - 32 )
00021e 4fff     +SBCI R31 , HIGH ( - 32 )
00021f 4f6f     +SBCI R22 , BYTE3 ( - 32 )
000220 4f7f     +SBCI R23 , BYTE4 ( - 32 )
                 	__ADDD1N 32
000221 93e0 0c26 	STS  _fat_begin_lba,R30
000223 93f0 0c27 	STS  _fat_begin_lba+1,R31
000225 9360 0c28 	STS  _fat_begin_lba+2,R22
000227 9370 0c29 	STS  _fat_begin_lba+3,R23
                 ; 0002 005F   //(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_ ...
                 ; 0002 0060   //Number_of_FATs always 2. Offset 0x10 8bit
                 ; 0002 0061   cluster_begin_lba=fat_begin_lba+(2*SectorsPerFat);//number of sector where data begin
000229 91e0 0c22 	LDS  R30,_SectorsPerFat
00022b 91f0 0c23 	LDS  R31,_SectorsPerFat+1
00022d 9160 0c24 	LDS  R22,_SectorsPerFat+2
00022f 9170 0c25 	LDS  R23,_SectorsPerFat+3
000231 940e 06ea 	CALL __LSLD1
000233 91a0 0c26 	LDS  R26,_fat_begin_lba
000235 91b0 0c27 	LDS  R27,_fat_begin_lba+1
000237 9180 0c28 	LDS  R24,_fat_begin_lba+2
000239 9190 0c29 	LDS  R25,_fat_begin_lba+3
00023b 940e 06b7 	CALL __ADDD12
00023d 93e0 0c2a 	STS  _cluster_begin_lba,R30
00023f 93f0 0c2b 	STS  _cluster_begin_lba+1,R31
000241 9360 0c2c 	STS  _cluster_begin_lba+2,R22
000243 9370 0c2d 	STS  _cluster_begin_lba+3,R23
                 ; 0002 0062   //read root dir (sector 2 but always offset 2 too then 0) to find folder 0 FAT reference. and find Flash.dat sector
                 ; 0002 0063   //lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
                 ; 0002 0064   adr=cluster_begin_lba +(2-2)*SectorsPerCluster;
000245 940e 05c7 	CALL SUBOPT_0x7
                 ; 0002 0065   //adr*=512UL;
                 ; 0002 0066   result[1]=0;
000247 e0e0      	LDI  R30,LOW(0)
                +
000248 93e0 0916+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
                 ; 0002 0067   for(i=0;i<SectorsPerCluster;i++)
                +
00024a e000     +LDI R16 , LOW ( 0 )
00024b e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x40007:
00024c 940e 05dc 	CALL SUBOPT_0xA
00024e f518      	BRSH _0x40008
                 ; 0002 0068   {
                 ; 0002 0069       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
00024f 940e 05e2 	CALL SUBOPT_0xB
000251 f011      	BREQ _0x40009
                 ; 0002 006A         errorSD(3);
000252 e0a3      	LDI  R26,LOW(3)
000253 d1bc      	RCALL _errorSD
                 ; 0002 006B       for(j=0;j<(16);j++)
                 _0x40009:
                +
000254 e020     +LDI R18 , LOW ( 0 )
000255 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x4000B:
                +
000256 3120     +CPI R18 , LOW ( 16 )
000257 e0e0     +LDI R30 , HIGH ( 16 )
000258 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
000259 f440      	BRSH _0x4000C
                 ; 0002 006C       {
                 ; 0002 006D            if((result[1]=compbuf("0          ",&sdBuf[j*32]))!=0)
                +
00025a e0e0     +LDI R30 , LOW ( _0x4000E + ( 0 ) )
00025b e0f9     +LDI R31 , HIGH ( _0x4000E + ( 0 ) )
                 	__POINTW1MN _0x4000E,0
00025c 940e 05e4 	CALL SUBOPT_0xC
00025e f419      	BRNE _0x4000C
                 ; 0002 006E            {
                 ; 0002 006F                 break;
                 ; 0002 0070            }
                 ; 0002 0071       }
                +
00025f 5f2f     +SUBI R18 , LOW ( - 1 )
000260 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
000261 cff4      	RJMP _0x4000B
                 _0x4000C:
                 ; 0002 0072       if(result[1]!=0)
                +
000262 91e0 0916+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
000264 30e0      	CPI  R30,0
000265 f039      	BREQ _0x4000F
                 ; 0002 0073       {
                 ; 0002 0074         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
000266 940e 05f4 	CALL SUBOPT_0xD
000268 940e 05fa 	CALL SUBOPT_0xE
                 ; 0002 0075         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
00026a 940e 060b 	CALL SUBOPT_0xF
                 ; 0002 0076         break;
00026c c005      	RJMP _0x40008
                 ; 0002 0077       }
                 ; 0002 0078       else
                 _0x4000F:
                 ; 0002 0079         adr++;
00026d 940e 0624 	CALL SUBOPT_0x10
                 ; 0002 007A   }
                +
00026f 5f0f     +SUBI R16 , LOW ( - 1 )
000270 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
000271 cfda      	RJMP _0x40007
                 _0x40008:
                 ; 0002 007B   adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
000272 940e 062f 	CALL SUBOPT_0x11
                 ; 0002 007C   for(i=0;i<SectorsPerCluster;i++)
                 _0x40012:
000274 940e 05dc 	CALL SUBOPT_0xA
000276 f598      	BRSH _0x40013
                 ; 0002 007D   {
                 ; 0002 007E       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
000277 940e 05e2 	CALL SUBOPT_0xB
000279 f011      	BREQ _0x40014
                 ; 0002 007F         errorSD(4);
00027a e0a4      	LDI  R26,LOW(4)
00027b d194      	RCALL _errorSD
                 ; 0002 0080       for(j=0;j<(16);j++)
                 _0x40014:
                +
00027c e020     +LDI R18 , LOW ( 0 )
00027d e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40016:
                +
00027e 3120     +CPI R18 , LOW ( 16 )
00027f e0e0     +LDI R30 , HIGH ( 16 )
000280 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
000281 f440      	BRSH _0x40017
                 ; 0002 0081       {
                 ; 0002 0082            if((result[1]=compbuf("FLASH   ",&sdBuf[j*32]))!=0)
                +
000282 e0ec     +LDI R30 , LOW ( _0x4000E + ( 12 ) )
000283 e0f9     +LDI R31 , HIGH ( _0x4000E + ( 12 ) )
                 	__POINTW1MN _0x4000E,12
000284 940e 05e4 	CALL SUBOPT_0xC
000286 f419      	BRNE _0x40017
                 ; 0002 0083            {
                 ; 0002 0084                 break;
                 ; 0002 0085            }
                 ; 0002 0086       }
                +
000287 5f2f     +SUBI R18 , LOW ( - 1 )
000288 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
000289 cff4      	RJMP _0x40016
                 _0x40017:
                 ; 0002 0087       if(result[1]!=0)
                +
00028a 91e0 0916+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00028c 30e0      	CPI  R30,0
00028d f0b9      	BREQ _0x40019
                 ; 0002 0088       {
                 ; 0002 0089         //read 1st number of cluster where data placed
                 ; 0002 008A         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
00028e 940e 05f4 	CALL SUBOPT_0xD
000290 940e 05fa 	CALL SUBOPT_0xE
                 ; 0002 008B         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
000292 940e 060b 	CALL SUBOPT_0xF
                 ; 0002 008C         filesize = buf2num(&sdBuf[j*32+0x1C],8);
000294 940e 05f4 	CALL SUBOPT_0xD
                +
000296 5cea     +SUBI R30 , LOW ( - _sdBuf - ( 28 ) )
000297 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 28 ) )
                 	__ADDW1MN _sdBuf,28
000298 93fa      	ST   -Y,R31
000299 93ea      	ST   -Y,R30
00029a e0a8      	LDI  R26,LOW(8)
00029b d184      	RCALL _buf2num
00029c 93e0 0c36 	STS  _filesize,R30
00029e 93f0 0c37 	STS  _filesize+1,R31
0002a0 9360 0c38 	STS  _filesize+2,R22
0002a2 9370 0c39 	STS  _filesize+3,R23
                 ; 0002 008D         break;
0002a4 c005      	RJMP _0x40013
                 ; 0002 008E       }
                 ; 0002 008F       else
                 _0x40019:
                 ; 0002 0090         adr++;
0002a5 940e 0624 	CALL SUBOPT_0x10
                 ; 0002 0091   }
                +
0002a7 5f0f     +SUBI R16 , LOW ( - 1 )
0002a8 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0002a9 cfca      	RJMP _0x40012
                 _0x40013:
                 ; 0002 0092 
                 ; 0002 0093   //check FAT for chain of clusters to read
                 ; 0002 0094   readbytes=0;
0002aa e0e0      	LDI  R30,LOW(0)
0002ab 93e0 0c3a 	STS  _readbytes,R30
0002ad 93e0 0c3b 	STS  _readbytes+1,R30
0002af 93e0 0c3c 	STS  _readbytes+2,R30
0002b1 93e0 0c3d 	STS  _readbytes+3,R30
                 ; 0002 0095   while(fat_file_adr != 0x0FFFFFFFUL)
                 _0x4001B:
0002b3 91a0 0c2e 	LDS  R26,_fat_file_adr
0002b5 91b0 0c2f 	LDS  R27,_fat_file_adr+1
0002b7 9180 0c30 	LDS  R24,_fat_file_adr+2
0002b9 9190 0c31 	LDS  R25,_fat_file_adr+3
0002bb 940e 0651 	CALL SUBOPT_0x12
0002bd f409      	BRNE PC+2
0002be c139      	RJMP _0x4001D
                 ; 0002 0096   {
                 ; 0002 0097     //read where next cluster from FAT, check that not EOF
                 ; 0002 0098     if((result[0]=SD_readSingleBlock(fat_begin_lba, sdBuf, &token))!=SD_SUCCESS)
0002bf 91e0 0c26 	LDS  R30,_fat_begin_lba
0002c1 91f0 0c27 	LDS  R31,_fat_begin_lba+1
0002c3 9160 0c28 	LDS  R22,_fat_begin_lba+2
0002c5 9170 0c29 	LDS  R23,_fat_begin_lba+3
0002c7 940e 05d9 	CALL SUBOPT_0x9
0002c9 f011      	BREQ _0x4001E
                 ; 0002 0099         errorSD(5);
0002ca e0a5      	LDI  R26,LOW(5)
0002cb d144      	RCALL _errorSD
                 ; 0002 009A     fat_file_next_adr=buf2num(&sdBuf[fat_file_adr*4],4);
                 _0x4001E:
0002cc 91a0 0c2e 	LDS  R26,_fat_file_adr
0002ce 91b0 0c2f 	LDS  R27,_fat_file_adr+1
0002d0 e0e4      	LDI  R30,LOW(4)
0002d1 940e 0726 	CALL __MULB1W2U
0002d3 5ee6      	SUBI R30,LOW(-_sdBuf)
0002d4 4ff6      	SBCI R31,HIGH(-_sdBuf)
0002d5 940e 05c2 	CALL SUBOPT_0x6
0002d7 93e0 0c32 	STS  _fat_file_next_adr,R30
0002d9 93f0 0c33 	STS  _fat_file_next_adr+1,R31
0002db 9360 0c34 	STS  _fat_file_next_adr+2,R22
0002dd 9370 0c35 	STS  _fat_file_next_adr+3,R23
                 ; 0002 009B 
                 ; 0002 009C     adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
0002df 940e 062f 	CALL SUBOPT_0x11
                 ; 0002 009D     for(i=0;i<SectorsPerCluster;i++)
                 _0x40020:
0002e1 940e 05dc 	CALL SUBOPT_0xA
0002e3 f008      	BRLO PC+2
0002e4 c102      	RJMP _0x40021
                 ; 0002 009E     {
                 ; 0002 009F         //read data from next sector of file cluster
                 ; 0002 00A0         if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
0002e5 940e 05e2 	CALL SUBOPT_0xB
0002e7 f011      	BREQ _0x40022
                 ; 0002 00A1             errorSD(6);
0002e8 e0a6      	LDI  R26,LOW(6)
0002e9 d126      	RCALL _errorSD
                 ; 0002 00A2         //address 2000 = start adr flash app 3 bytes, flash pages 2 bytes, checksum 2 bytes
                 ; 0002 00A3         //app bytes starts from 2048, roll 0x88
                 ; 0002 00A4         for(j=0;j<512;j++)
                 _0x40022:
                +
0002ea e020     +LDI R18 , LOW ( 0 )
0002eb e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40024:
                +
0002ec 3020     +CPI R18 , LOW ( 512 )
0002ed e0e2     +LDI R30 , HIGH ( 512 )
0002ee 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
0002ef f548      	BRSH _0x40025
                 ; 0002 00A5         {
                 ; 0002 00A6             sdBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
0002f0 01f9      	MOVW R30,R18
0002f1 5ee6      	SUBI R30,LOW(-_sdBuf)
0002f2 4ff6      	SBCI R31,HIGH(-_sdBuf)
0002f3 01bf      	MOVW R22,R30
0002f4 940e 0659 	CALL SUBOPT_0x13
0002f6 0fee      	LSL  R30
0002f7 2e0e      	MOV  R0,R30
0002f8 940e 0659 	CALL SUBOPT_0x13
0002fa 1fee      	ROL  R30
0002fb e0e0      	LDI  R30,0
0002fc 1fee      	ROL  R30
0002fd 29e0      	OR   R30,R0
0002fe 01db      	MOVW R26,R22
0002ff 93ec      	ST   X,R30
                 ; 0002 00A7             sdBuf[j]^=0x88;  //XOR
000300 01f9      	MOVW R30,R18
000301 5ee6      	SUBI R30,LOW(-_sdBuf)
000302 4ff6      	SBCI R31,HIGH(-_sdBuf)
000303 010f      	MOVW R0,R30
000304 81a0      	LD   R26,Z
000305 e8e8      	LDI  R30,LOW(136)
000306 27ea      	EOR  R30,R26
000307 01d0      	MOVW R26,R0
000308 93ec      	ST   X,R30
                 ; 0002 00A8             checksumCnt+=sdBuf[j];
000309 940e 0659 	CALL SUBOPT_0x13
00030b e0f0      	LDI  R31,0
00030c 91a0 0c40 	LDS  R26,_checksumCnt
00030e 91b0 0c41 	LDS  R27,_checksumCnt+1
000310 0fea      	ADD  R30,R26
000311 1ffb      	ADC  R31,R27
000312 93e0 0c40 	STS  _checksumCnt,R30
000314 93f0 0c41 	STS  _checksumCnt+1,R31
                 ; 0002 00A9         }
                +
000316 5f2f     +SUBI R18 , LOW ( - 1 )
000317 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
000318 cfd3      	RJMP _0x40024
                 _0x40025:
                 ; 0002 00AA         readbytes+=512;
000319 91e0 0c3a 	LDS  R30,_readbytes
00031b 91f0 0c3b 	LDS  R31,_readbytes+1
00031d 9160 0c3c 	LDS  R22,_readbytes+2
00031f 9170 0c3d 	LDS  R23,_readbytes+3
                +
000321 50e0     +SUBI R30 , LOW ( - 512 )
000322 4ffe     +SBCI R31 , HIGH ( - 512 )
000323 4f6f     +SBCI R22 , BYTE3 ( - 512 )
000324 4f7f     +SBCI R23 , BYTE4 ( - 512 )
                 	__ADDD1N 512
000325 93e0 0c3a 	STS  _readbytes,R30
000327 93f0 0c3b 	STS  _readbytes+1,R31
000329 9360 0c3c 	STS  _readbytes+2,R22
00032b 9370 0c3d 	STS  _readbytes+3,R23
                 ; 0002 00AB         //read app data
                 ; 0002 00AC         if(readbytes>2048)
00032d 940e 065f 	CALL SUBOPT_0x14
                +
00032f 30a1     +CPI R26 , LOW ( 0x801 )
000330 e0e8     +LDI R30 , HIGH ( 0x801 )
000331 07be     +CPC R27 , R30
000332 e0e0     +LDI R30 , BYTE3 ( 0x801 )
000333 078e     +CPC R24 , R30
000334 e0e0     +LDI R30 , BYTE4 ( 0x801 )
000335 079e     +CPC R25 , R30
                 	__CPD2N 0x801
000336 f1c8      	BRLO _0x40026
                 ; 0002 00AD         {
                 ; 0002 00AE            for(pagesCnt=0;pagesCnt<PAGES_PER_SDBUF;pagesCnt++)
000337 24bb      	CLR  R11
                 _0x40028:
000338 e0e2      	LDI  R30,LOW(2)
000339 16be      	CP   R11,R30
00033a f5a0      	BRSH _0x40029
                 ; 0002 00AF            {
                 ; 0002 00B0                if(WriteFlashPage(appStartAdr, &sdBuf[pagesCnt*PAGESIZE])==0)
00033b 940e 0668 	CALL SUBOPT_0x15
00033d 940e 0758 	CALL __PUTPARD1
00033f 2dab      	MOV  R26,R11
000340 e0b0      	LDI  R27,0
000341 e0e0      	LDI  R30,LOW(256)
000342 e0f1      	LDI  R31,HIGH(256)
000343 940e 072c 	CALL __MULW12
000345 5ee6      	SUBI R30,LOW(-_sdBuf)
000346 4ff6      	SBCI R31,HIGH(-_sdBuf)
000347 01df      	MOVW R26,R30
000348 940e 00d3 	CALL _WriteFlashPage
00034a 30e0      	CPI  R30,0
00034b f439      	BRNE _0x4002A
                 ; 0002 00B1                {
                 ; 0002 00B2                     //while(1)
                 ; 0002 00B3                     do
                 _0x4002C:
                 ; 0002 00B4                     {
                 ; 0002 00B5                       PORTC.6=0;
00034c 98ae      	CBI  0x15,6
                 ; 0002 00B6                       delay_ms(500);
00034d 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 00B7                       PORTC.6=1;
00034f 9aae      	SBI  0x15,6
                 ; 0002 00B8                       delay_ms(500);
000350 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 00B9                     }while(1);
000352 cff9      	RJMP _0x4002C
                 ; 0002 00BA                }
                 ; 0002 00BB                appStartAdr+=PAGESIZE;
                 _0x4002A:
000353 940e 0668 	CALL SUBOPT_0x15
                +
000355 50e0     +SUBI R30 , LOW ( - 256 )
000356 4fff     +SBCI R31 , HIGH ( - 256 )
000357 4f6f     +SBCI R22 , BYTE3 ( - 256 )
000358 4f7f     +SBCI R23 , BYTE4 ( - 256 )
                 	__ADDD1N 256
000359 940e 0675 	CALL SUBOPT_0x17
                 ; 0002 00BC                appPages--;
00035b 01f6      	MOVW R30,R12
00035c 9731      	SBIW R30,1
00035d 016f      	MOVW R12,R30
                 ; 0002 00BD                if(appPages==0)
00035e 2c0c      	MOV  R0,R12
00035f 280d      	OR   R0,R13
000360 f461      	BRNE _0x40032
                 ; 0002 00BE                {
                 ; 0002 00BF                     app_pointer();
                +
000361 91e0 0c42+LDS R30 , _app_pointer + ( 0 )
000363 91f0 0c43+LDS R31 , _app_pointer + ( 0 ) + 1
000365 9509     +ICALL
                 	__CALL1MN _app_pointer,0
                 ; 0002 00C0                     do
                 _0x40034:
                 ; 0002 00C1                     {
                 ; 0002 00C2                       PORTC.5=0;
000366 98ad      	CBI  0x15,5
                 ; 0002 00C3                       delay_ms(500);
000367 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 00C4                       PORTC.5=1;
000369 9aad      	SBI  0x15,5
                 ; 0002 00C5                       delay_ms(500);
00036a 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 00C6                     }while(1);
00036c cff9      	RJMP _0x40034
                 ; 0002 00C7                }
                 ; 0002 00C8            }
                 _0x40032:
00036d 94b3      	INC  R11
00036e cfc9      	RJMP _0x40028
                 _0x40029:
                 ; 0002 00C9         }
                 ; 0002 00CA         //read app start adr, num of pages, checksum
                 ; 0002 00CB         else if(readbytes>=2000)//Offset=512-48=464
00036f c048      	RJMP _0x4003A
                 _0x40026:
000370 940e 065f 	CALL SUBOPT_0x14
                +
000372 3da0     +CPI R26 , LOW ( 0x7D0 )
000373 e0e7     +LDI R30 , HIGH ( 0x7D0 )
000374 07be     +CPC R27 , R30
000375 e0e0     +LDI R30 , BYTE3 ( 0x7D0 )
000376 078e     +CPC R24 , R30
000377 e0e0     +LDI R30 , BYTE4 ( 0x7D0 )
000378 079e     +CPC R25 , R30
                 	__CPD2N 0x7D0
000379 f1f0      	BRLO _0x4003B
                 ; 0002 00CC         {
                 ; 0002 00CD            appStartAdr=(unsigned long)sdBuf[464]<<16;
                +
00037a 91e0 0aea+LDS R30 , _sdBuf + ( 464 )
                 	__GETB1MN _sdBuf,464
00037c e0f0      	LDI  R31,0
00037d 940e 06f9 	CALL __CWD1
00037f 940e 06f4 	CALL __LSLD16
000381 940e 0675 	CALL SUBOPT_0x17
                 ; 0002 00CE            appStartAdr|=(unsigned long)sdBuf[465]<<8;
                +
000383 91e0 0aeb+LDS R30 , _sdBuf + ( 465 )
                 	__GETB1MN _sdBuf,465
000385 e0f0      	LDI  R31,0
000386 940e 06f9 	CALL __CWD1
000388 01df      	MOVW R26,R30
000389 01cb      	MOVW R24,R22
00038a e0e8      	LDI  R30,LOW(8)
00038b 940e 06d2 	CALL __LSLD12
00038d 940e 067e 	CALL SUBOPT_0x18
                 ; 0002 00CF            appStartAdr|=(unsigned long)sdBuf[466];
                +
00038f 91e0 0aec+LDS R30 , _sdBuf + ( 466 )
                 	__GETB1MN _sdBuf,466
000391 e0f0      	LDI  R31,0
000392 940e 06f9 	CALL __CWD1
000394 940e 067e 	CALL SUBOPT_0x18
                 ; 0002 00D0            appPages=(unsigned int)sdBuf[467]<<8;
                +
000396 91f0 0aed+LDS R31 , _sdBuf + ( 467 )
                 	__GETBRMN 31,_sdBuf,467
000398 e0e0      	LDI  R30,LOW(0)
000399 016f      	MOVW R12,R30
                 ; 0002 00D1            appPages|=(unsigned int)sdBuf[468];
                +
00039a 91e0 0aee+LDS R30 , _sdBuf + ( 468 )
                 	__GETB1MN _sdBuf,468
00039c e0f0      	LDI  R31,0
                +
00039d 2ace     +OR R12 , R30
00039e 2adf     +OR R13 , R31
                 	__ORWRR 12,13,30,31
                 ; 0002 00D2            bytesChecksum=(unsigned int)sdBuf[469]<<8;
                +
00039f 91f0 0aef+LDS R31 , _sdBuf + ( 469 )
                 	__GETBRMN 31,_sdBuf,469
0003a1 e0e0      	LDI  R30,LOW(0)
0003a2 93e0 0c3e 	STS  _bytesChecksum,R30
0003a4 93f0 0c3f 	STS  _bytesChecksum+1,R31
                 ; 0002 00D3            bytesChecksum|=(unsigned int)sdBuf[470];
                +
0003a6 91e0 0af0+LDS R30 , _sdBuf + ( 470 )
                 	__GETB1MN _sdBuf,470
0003a8 e0f0      	LDI  R31,0
0003a9 91a0 0c3e 	LDS  R26,_bytesChecksum
0003ab 91b0 0c3f 	LDS  R27,_bytesChecksum+1
0003ad 2bea      	OR   R30,R26
0003ae 2bfb      	OR   R31,R27
0003af 93e0 0c3e 	STS  _bytesChecksum,R30
0003b1 93f0 0c3f 	STS  _bytesChecksum+1,R31
                 ; 0002 00D4            checksumCnt=0;
0003b3 e0e0      	LDI  R30,LOW(0)
0003b4 93e0 0c40 	STS  _checksumCnt,R30
0003b6 93e0 0c41 	STS  _checksumCnt+1,R30
                 ; 0002 00D5         }
                 ; 0002 00D6         if(fat_file_next_adr == 0x0FFFFFFFUL)
                 _0x4003B:
                 _0x4003A:
0003b8 91a0 0c32 	LDS  R26,_fat_file_next_adr
0003ba 91b0 0c33 	LDS  R27,_fat_file_next_adr+1
0003bc 9180 0c34 	LDS  R24,_fat_file_next_adr+2
0003be 9190 0c35 	LDS  R25,_fat_file_next_adr+3
0003c0 940e 0651 	CALL SUBOPT_0x12
0003c2 f4f9      	BRNE _0x4003C
                 ; 0002 00D7             if(readbytes >= filesize)
0003c3 91e0 0c36 	LDS  R30,_filesize
0003c5 91f0 0c37 	LDS  R31,_filesize+1
0003c7 9160 0c38 	LDS  R22,_filesize+2
0003c9 9170 0c39 	LDS  R23,_filesize+3
0003cb 940e 065f 	CALL SUBOPT_0x14
0003cd 940e 0766 	CALL __CPD21
0003cf f4b8      	BRSH _0x40021
                 ; 0002 00D8             {
                 ; 0002 00D9                 break;
                 ; 0002 00DA             }
                 ; 0002 00DB             else
                 ; 0002 00DC             {
                 ; 0002 00DD 
                 ; 0002 00DE                 if(  WriteFlashPage(0x1EF00, sdBuf))//;     // Writes testbuffer1 to Flash page 2
0003d0 940e 0689 	CALL SUBOPT_0x19
0003d2 e1aa      	LDI  R26,LOW(_sdBuf)
0003d3 e0b9      	LDI  R27,HIGH(_sdBuf)
0003d4 940e 00d3 	CALL _WriteFlashPage
0003d6 30e0      	CPI  R30,0
0003d7 f009      	BREQ _0x4003F
                 ; 0002 00DF                     PORTC.5=0;                                          // Function returns TRUE
0003d8 98ad      	CBI  0x15,5
                 ; 0002 00E0                 if(  ReadFlashPage (0x1EF00, testBuf))//;      // Reads back Flash page 2 to TestBuffer2
                 _0x4003F:
0003d9 940e 0689 	CALL SUBOPT_0x19
0003db e1aa      	LDI  R26,LOW(_testBuf)
0003dc e0bb      	LDI  R27,HIGH(_testBuf)
0003dd 940e 00a6 	CALL _ReadFlashPage
0003df 30e0      	CPI  R30,0
0003e0 f009      	BREQ _0x40042
                 ; 0002 00E1                     PORTC.6=0;
0003e1 98ae      	CBI  0x15,6
                 ; 0002 00E2             }
                 _0x40042:
                 ; 0002 00E3 
                 ; 0002 00E4         adr++;
                 _0x4003C:
0003e2 940e 0624 	CALL SUBOPT_0x10
                 ; 0002 00E5     }
                +
0003e4 5f0f     +SUBI R16 , LOW ( - 1 )
0003e5 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
0003e6 cefa      	RJMP _0x40020
                 _0x40021:
                 ; 0002 00E6     fat_file_adr = fat_file_next_adr;
0003e7 91e0 0c32 	LDS  R30,_fat_file_next_adr
0003e9 91f0 0c33 	LDS  R31,_fat_file_next_adr+1
0003eb 9160 0c34 	LDS  R22,_fat_file_next_adr+2
0003ed 9170 0c35 	LDS  R23,_fat_file_next_adr+3
0003ef 93e0 0c2e 	STS  _fat_file_adr,R30
0003f1 93f0 0c2f 	STS  _fat_file_adr+1,R31
0003f3 9360 0c30 	STS  _fat_file_adr+2,R22
0003f5 9370 0c31 	STS  _fat_file_adr+3,R23
                 ; 0002 00E7   }
0003f7 cebb      	RJMP _0x4001B
                 _0x4001D:
                 ; 0002 00E8 
                 ; 0002 00E9 
                 ; 0002 00EA   while(1);
                 _0x40045:
0003f8 cfff      	RJMP _0x40045
                 ; 0002 00EB   //static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
                 ; 0002 00EC   //if(PORTA==0x55)
                 ; 0002 00ED     //testWrite();                                          // Returns TRUE
                 ; 0002 00EE   //__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
                 ; 0002 00EF   //__AddrToZ24ByteToSPMCR_SPM_W((void flash *)0);
                 ; 0002 00F0   /*
                 ; 0002 00F1   unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
                 ; 0002 00F2   unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                 ; 0002 00F3                                             // code stack
                 ; 0002 00F4   int index;
                 ; 0002 00F5 
                 ; 0002 00F6   DDRC=0xFF;
                 ; 0002 00F7   PORTC=0xFF;
                 ; 0002 00F8   //DDRC=0x00;
                 ; 0002 00F9   //PORTC=0x00;
                 ; 0002 00FA   //MCUCR |= (1<<IVSEL);
                 ; 0002 00FB                         // Move interrupt vectors to boot
                 ; 0002 00FC   //RecoverFlash();
                 ; 0002 00FD 
                 ; 0002 00FE   dospm();
                 ; 0002 00FF 
                 ; 0002 0100   for(index=0; index<PAGESIZE; index++){
                 ; 0002 0101     testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
                 ; 0002 0102   }
                 ; 0002 0103   PORTC.4=0;
                 ; 0002 0104   //for(;;){
                 ; 0002 0105   if(  WriteFlashPage(0x1000, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
                 ; 0002 0106     PORTC.5=0;                                          // Function returns TRUE
                 ; 0002 0107   if(  ReadFlashPage(0x1000, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
                 ; 0002 0108     PORTC.6=0;                                          // Function returns TRUE
                 ; 0002 0109   if(  WriteFlashByte(0x1004, 0x38))//;            // Writes 0x38 to byte address 0x204
                 ; 0002 010A     PORTC.5=0;                                          // Same as byte 4 on page 2
                 ; 0002 010B   */
                 ; 0002 010C 
                 ; 0002 010D   //}
                 ; 0002 010E }
                 _0x40048:
0003f9 cfff      	RJMP _0x40048
                 ; .FEND
                 
                 	.DSEG
                 _0x4000E:
000900           	.BYTE 0x15
                 ;
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest)
                 ; 0002 0111 {
                 
                 	.CSEG
                 _compbuf:
                 ; .FSTART _compbuf
                 ; 0002 0112     while(*src)
0003fa 93ba      	ST   -Y,R27
0003fb 93aa      	ST   -Y,R26
                 ;	*src -> Y+2
                 ;	*dest -> Y+0
                 _0x40049:
0003fc 81aa      	LDD  R26,Y+2
0003fd 81bb      	LDD  R27,Y+2+1
0003fe 91ec      	LD   R30,X
0003ff 30e0      	CPI  R30,0
000400 f069      	BREQ _0x4004B
                 ; 0002 0113     {
                 ; 0002 0114         if(*src++ != *dest++)
000401 900d      	LD   R0,X+
000402 83aa      	STD  Y+2,R26
000403 83bb      	STD  Y+2+1,R27
000404 81a8      	LD   R26,Y
000405 81b9      	LDD  R27,Y+1
000406 91ed      	LD   R30,X+
000407 83a8      	ST   Y,R26
000408 83b9      	STD  Y+1,R27
000409 15e0      	CP   R30,R0
00040a f011      	BREQ _0x4004C
                 ; 0002 0115             return 0;
00040b e0e0      	LDI  R30,LOW(0)
00040c c095      	RJMP _0x2060009
                 ; 0002 0116         //src++;dest++;
                 ; 0002 0117         //len--;
                 ; 0002 0118     }
                 _0x4004C:
00040d cfee      	RJMP _0x40049
                 _0x4004B:
                 ; 0002 0119     return 1;
00040e e0e1      	LDI  R30,LOW(1)
00040f c092      	RJMP _0x2060009
                 ; 0002 011A }
                 ; .FEND
                 ;
                 ;void errorSD(unsigned char err)
                 ; 0002 011D {
                 _errorSD:
                 ; .FSTART _errorSD
                 ; 0002 011E     /*
                 ; 0002 011F     insigned int dly=0;
                 ; 0002 0120     if(err==1){
                 ; 0002 0121         dly=200;
                 ; 0002 0122     }
                 ; 0002 0123     else if(err==2){
                 ; 0002 0124         dly=500;
                 ; 0002 0125     }
                 ; 0002 0126     else if(err==3){
                 ; 0002 0127         dly=500;
                 ; 0002 0128     }
                 ; 0002 0129     */
                 ; 0002 012A     do{
000410 93aa      	ST   -Y,R26
                 ;	err -> Y+0
                 _0x4004E:
                 ; 0002 012B        PORTC &= ~(1<<err);
000411 b215      	IN   R1,21
000412 81e8      	LD   R30,Y
000413 e0a1      	LDI  R26,LOW(1)
000414 940e 06ca 	CALL __LSLB12
000416 95e0      	COM  R30
000417 21e1      	AND  R30,R1
000418 bbe5      	OUT  0x15,R30
                 ; 0002 012C        delay_ms(500);
000419 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 012D        PORTC = 0xFF;
00041b efef      	LDI  R30,LOW(255)
00041c bbe5      	OUT  0x15,R30
                 ; 0002 012E        delay_ms(500);
00041d 940e 0671 	CALL SUBOPT_0x16
                 ; 0002 012F     }
                 ; 0002 0130 
                 ; 0002 0131     //PORTC.1=0;
                 ; 0002 0132     while(1);
00041f cff1      	RJMP _0x4004E
                 ; 0002 0133 }
                 ; .FEND
                 ;
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len)
                 ; 0002 0136 {
                 _buf2num:
                 ; .FSTART _buf2num
                 ; 0002 0137     unsigned long num=0;
                 ; 0002 0138     //unsigned char i;
                 ; 0002 0139     for(;len>0;len--)
000420 93aa      	ST   -Y,R26
000421 9724      	SBIW R28,4
000422 e0e0      	LDI  R30,LOW(0)
000423 83e8      	ST   Y,R30
000424 83e9      	STD  Y+1,R30
000425 83ea      	STD  Y+2,R30
000426 83eb      	STD  Y+3,R30
                 ;	*buf -> Y+5
                 ;	len -> Y+4
                 ;	num -> Y+0
                 _0x40051:
000427 81ac      	LDD  R26,Y+4
000428 30a1      	CPI  R26,LOW(0x1)
000429 f0e0      	BRLO _0x40052
                 ; 0002 013A     {
                 ; 0002 013B         num<<=8;
00042a 940e 05b3 	CALL SUBOPT_0x4
00042c e0e8      	LDI  R30,LOW(8)
00042d 940e 06d2 	CALL __LSLD12
00042f 940e 0753 	CALL __PUTD1S0
                 ; 0002 013C         num|=buf[len-1];
000431 81ec      	LDD  R30,Y+4
000432 e0f0      	LDI  R31,0
000433 9731      	SBIW R30,1
000434 81ad      	LDD  R26,Y+5
000435 81be      	LDD  R27,Y+5+1
000436 0fae      	ADD  R26,R30
000437 1fbf      	ADC  R27,R31
000438 91ec      	LD   R30,X
000439 940e 05b3 	CALL SUBOPT_0x4
00043b 27ff      	CLR  R31
00043c 2766      	CLR  R22
00043d 2777      	CLR  R23
00043e 940e 06c1 	CALL __ORD12
000440 940e 0753 	CALL __PUTD1S0
                 ; 0002 013D     }
000442 81ec      	LDD  R30,Y+4
000443 50e1      	SUBI R30,LOW(1)
000444 83ec      	STD  Y+4,R30
000445 cfe1      	RJMP _0x40051
                 _0x40052:
                 ; 0002 013E     return num;
000446 940e 059f 	CALL SUBOPT_0x0
000448 9627      	ADIW R28,7
000449 9508      	RET
                 ; 0002 013F }
                 ; .FEND
                 ;
                 ;
                 ;void testWrite()
                 ; 0002 0143 {
                 ; 0002 0144   unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
                 ; 0002 0145   unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                 ; 0002 0146                                             // code stack
                 ; 0002 0147 
                 ; 0002 0148 
                 ; 0002 0149   static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
                 ; 0002 014A   int index;
                 ; 0002 014B 
                 ; 0002 014C   //DDRC=0xFF;
                 ; 0002 014D   //PORTC=0xFF;
                 ; 0002 014E   //DDRC=0x00;
                 ; 0002 014F   //PORTC=0x00;
                 ; 0002 0150   //MCUCR |= (1<<IVSEL);
                 ; 0002 0151                         // Move interrupt vectors to boot
                 ; 0002 0152   //RecoverFlash();
                 ; 0002 0153 
                 ; 0002 0154   //dospm();
                 ; 0002 0155 
                 ; 0002 0156   for(index=0; index<PAGESIZE; index++){
                 ;	testBuffer1 -> Y+258
                 ;	testBuffer2 -> Y+2
                 ;	index -> R16,R17
                 ; 0002 0157     testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
                 ; 0002 0158   }
                 ; 0002 0159   PORTC.4=0;
                 ; 0002 015A   //for(;;){
                 ; 0002 015B   if(  WriteFlashPage(0x1EF00, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
                 ; 0002 015C     PORTC.5=0;                                          // Function returns TRUE
                 ; 0002 015D   if(  ReadFlashPage(0x1EF00, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
                 ; 0002 015E     PORTC.6=0;                                          // Function returns TRUE
                 ; 0002 015F   if(  WriteFlashByte(0x1EF04, 0x38))//;            // Writes 0x38 to byte address 0x204
                 ; 0002 0160     PORTC.5=1;                                          // Same as byte 4 on page 2
                 ; 0002 0161   testChar = ReadFlashByte(0x1EF04);        // Reads back value from address 0x204
                 ; 0002 0162 
                 ; 0002 0163   if(testChar==0x38)
                 ; 0002 0164   {
                 ; 0002 0165     while(1)
                 ; 0002 0166     {
                 ; 0002 0167       PORTC.6=0;
                 ; 0002 0168       delay_ms(500);
                 ; 0002 0169       PORTC.6=1;
                 ; 0002 016A       delay_ms(500);;
                 ; 0002 016B     }
                 ; 0002 016C   }
                 ; 0002 016D }
                 ;#include "spi_sdcard.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;
                 ;
                 ;
                 ;void SPI_init()
                 ; 0003 0007 {
                 
                 	.CSEG
                 _SPI_init:
                 ; .FSTART _SPI_init
                 ; 0003 0008     // set CS, MOSI and SCK to output
                 ; 0003 0009     DDR_SPI = (1 << CS) | (1 << MOSI) | (1 << SCK);
00044a e0e7      	LDI  R30,LOW(7)
00044b bbe7      	OUT  0x17,R30
                 ; 0003 000A     PORT_SPI|=(1 << CS);
00044c 9ac0      	SBI  0x18,0
                 ; 0003 000B     // enable pull up resistor in MISO
                 ; 0003 000C     DDR_SPI &= ~(1 << MISO);
00044d 98bb      	CBI  0x17,3
                 ; 0003 000D     PORT_SPI &= ~(1 << MISO);
00044e 98c3      	CBI  0x18,3
                 ; 0003 000E     //PORT_SPI |= (1 << MISO);
                 ; 0003 000F 
                 ; 0003 0010     // enable SPI, set as master, and clock to fosc/128
                 ; 0003 0011     SPCR = (1 << SPE) | (1 << MSTR) | (0 << SPR1) | (0 << SPR0);
00044f e5e0      	LDI  R30,LOW(80)
000450 b9ed      	OUT  0xD,R30
                 ; 0003 0012 }
000451 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SPI_transfer(unsigned char data)
                 ; 0003 0015 {
                 _SPI_transfer:
                 ; .FSTART _SPI_transfer
                 ; 0003 0016     // load data into register
                 ; 0003 0017     SPDR = data;
000452 93aa      	ST   -Y,R26
                 ;	data -> Y+0
000453 81e8      	LD   R30,Y
000454 b9ef      	OUT  0xF,R30
                 ; 0003 0018 
                 ; 0003 0019     // Wait for transmission complete
                 ; 0003 001A     while(!(SPSR & (1 << SPIF)));
                 _0x60003:
000455 9b77      	SBIS 0xE,7
000456 cffe      	RJMP _0x60003
                 ; 0003 001B 
                 ; 0003 001C     // return SPDR
                 ; 0003 001D     return SPDR;
000457 b1ef      	IN   R30,0xF
                 _0x206000B:
000458 9621      	ADIW R28,1
000459 9508      	RET
                 ; 0003 001E }
                 ; .FEND
                 ;
                 ;
                 ;void SD_powerUpSeq()
                 ; 0003 0022 {
                 _SD_powerUpSeq:
                 ; .FSTART _SD_powerUpSeq
                 ; 0003 0023     unsigned char i;
                 ; 0003 0024 
                 ; 0003 0025     SPI_init();
00045a 931a      	ST   -Y,R17
                 ;	i -> R17
00045b dfee      	RCALL _SPI_init
                 ; 0003 0026 
                 ; 0003 0027     // make sure card is deselected
                 ; 0003 0028     CS_DISABLE();
00045c 9ac0      	SBI  0x18,0
                 ; 0003 0029 
                 ; 0003 002A     // give SD card time to power up
                 ; 0003 002B     delay_ms(1);
00045d e0a1      	LDI  R26,LOW(1)
00045e e0b0      	LDI  R27,0
00045f 940e 06ad 	CALL _delay_ms
                 ; 0003 002C 
                 ; 0003 002D     // send 80 clock cycles to synchronize
                 ; 0003 002E     for(i = 0; i < 10; i++)
000461 e010      	LDI  R17,LOW(0)
                 _0x60007:
000462 301a      	CPI  R17,10
000463 f420      	BRSH _0x60008
                 ; 0003 002F         SPI_transfer(0xFF);
000464 efaf      	LDI  R26,LOW(255)
000465 dfec      	RCALL _SPI_transfer
000466 5f1f      	SUBI R17,-1
000467 cffa      	RJMP _0x60007
                 _0x60008:
                 ; 0003 0032 PORTB |= (1 << 0       );
000468 940e 0690 	CALL SUBOPT_0x1A
                 ; 0003 0033     SPI_transfer(0xFF);
                 ; 0003 0034 }
00046a c096      	RJMP _0x2060006
                 ; .FEND
                 ;
                 ;unsigned char SD_command(unsigned char cmd, unsigned long arg, unsigned char crc)
                 ; 0003 0037 {
                 _SD_command:
                 ; .FSTART _SD_command
                 ; 0003 0038     unsigned char res,count;
                 ; 0003 0039     // transmit command to sd card
                 ; 0003 003A     SPI_transfer(cmd|0x40);
00046b 93aa      	ST   -Y,R26
00046c 931a      	ST   -Y,R17
00046d 930a      	ST   -Y,R16
                 ;	cmd -> Y+7
                 ;	arg -> Y+3
                 ;	crc -> Y+2
                 ;	res -> R17
                 ;	count -> R16
00046e 81ef      	LDD  R30,Y+7
00046f 64e0      	ORI  R30,0x40
000470 940e 0694 	CALL SUBOPT_0x1B
                 ; 0003 003B 
                 ; 0003 003C     // transmit argument
                 ; 0003 003D     SPI_transfer((unsigned char)(arg >> 24));
000472 e1e8      	LDI  R30,LOW(24)
000473 940e 06de 	CALL __LSRD12
000475 2fae      	MOV  R26,R30
000476 dfdb      	RCALL _SPI_transfer
                 ; 0003 003E     SPI_transfer((unsigned char)(arg >> 16));
                +
000477 81eb     +LDD R30 , Y + 3
000478 81fc     +LDD R31 , Y + 3 + 1
000479 816d     +LDD R22 , Y + 3 + 2
00047a 817e     +LDD R23 , Y + 3 + 3
                 	__GETD1S 3
00047b 940e 06ef 	CALL __LSRD16
00047d 940e 0694 	CALL SUBOPT_0x1B
                 ; 0003 003F     SPI_transfer((unsigned char)(arg >> 8));
00047f e0e8      	LDI  R30,LOW(8)
000480 940e 06de 	CALL __LSRD12
000482 2fae      	MOV  R26,R30
000483 dfce      	RCALL _SPI_transfer
                 ; 0003 0040     SPI_transfer((unsigned char)(arg));
000484 81ab      	LDD  R26,Y+3
000485 dfcc      	RCALL _SPI_transfer
                 ; 0003 0041 
                 ; 0003 0042     // transmit crc
                 ; 0003 0043     SPI_transfer(crc|0x01);
000486 81ea      	LDD  R30,Y+2
000487 60e1      	ORI  R30,1
000488 2fae      	MOV  R26,R30
000489 dfc8      	RCALL _SPI_transfer
                 ; 0003 0044 
                 ; 0003 0045     //wait response R1
                 ; 0003 0046     res = SD_readRes1();
00048a d005      	RCALL _SD_readRes1
00048b 2f1e      	MOV  R17,R30
                 ; 0003 0047     /*
                 ; 0003 0048     do {
                 ; 0003 0049      res=SPI_transfer(0xFF);;
                 ; 0003 004A      count++;
                 ; 0003 004B     } while ( ((res&0x80)!=0x00)&&(count<0xff) );
                 ; 0003 004C     */
                 ; 0003 004D     return res;
                 _0x206000A:
00048c 8119      	LDD  R17,Y+1
00048d 8108      	LDD  R16,Y+0
00048e 9628      	ADIW R28,8
00048f 9508      	RET
                 ; 0003 004E }
                 ; .FEND
                 ;
                 ;
                 ;unsigned char SD_readRes1()
                 ; 0003 0052 {
                 _SD_readRes1:
                 ; .FSTART _SD_readRes1
                 ; 0003 0053     unsigned char res1;
                 ; 0003 0054     unsigned int i = 0;
                 ; 0003 0055 
                 ; 0003 0056     // keep polling until actual data received
                 ; 0003 0057     //while((res1 = SPI_transfer(0xFF)) == 0xFF)
                 ; 0003 0058     while(((res1 = SPI_transfer(0xFF))&0x80) != 0x00)
000490 940e 076d 	CALL __SAVELOCR4
                 ;	res1 -> R17
                 ;	i -> R18,R19
                +
000492 e020     +LDI R18 , LOW ( 0 )
000493 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60009:
000494 efaf      	LDI  R26,LOW(255)
000495 dfbc      	RCALL _SPI_transfer
000496 2f1e      	MOV  R17,R30
000497 78e0      	ANDI R30,LOW(0x80)
000498 f031      	BREQ _0x6000B
                 ; 0003 0059     {
                 ; 0003 005A         i++;
                +
000499 5f2f     +SUBI R18 , LOW ( - 1 )
00049a 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                 ; 0003 005B 
                 ; 0003 005C         // if no data received for (254)8 bytes, break
                 ; 0003 005D         if(i > 0x1FF) break;
                +
00049b 3020     +CPI R18 , LOW ( 512 )
00049c e0e2     +LDI R30 , HIGH ( 512 )
00049d 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00049e f3a8      	BRLO _0x60009
                 ; 0003 005E     }
                 _0x6000B:
                 ; 0003 005F 
                 ; 0003 0060     return res1;
00049f 2fe1      	MOV  R30,R17
0004a0 940e 0774 	CALL __LOADLOCR4
                 _0x2060009:
0004a2 9624      	ADIW R28,4
0004a3 9508      	RET
                 ; 0003 0061 }
                 ; .FEND
                 ;
                 ;unsigned char SD_goIdleState()
                 ; 0003 0064 {
                 _SD_goIdleState:
                 ; .FSTART _SD_goIdleState
                 ; 0003 0065     unsigned char res1;
                 ; 0003 0066     // assert chip select
                 ; 0003 0067     SPI_transfer(0xFF);
0004a4 940e 069c 	CALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 0068     CS_ENABLE();
                 ; 0003 0069     //SPI_transfer(0xFF);
                 ; 0003 006A 
                 ; 0003 006B     // send CMD0
                 ; 0003 006C     res1 = SD_command(CMD0, CMD0_ARG, CMD0_CRC);
0004a6 e0e0      	LDI  R30,LOW(0)
0004a7 93ea      	ST   -Y,R30
0004a8 940e 05a2 	CALL SUBOPT_0x1
0004aa e9a4      	LDI  R26,LOW(148)
0004ab c050      	RJMP _0x2060005
                 ; 0003 006D 
                 ; 0003 006E     // read response
                 ; 0003 006F     //res1 = SD_readRes1();
                 ; 0003 0070 
                 ; 0003 0071     // deassert chip select
                 ; 0003 0072     SPI_transfer(0xFF);
                 ; 0003 0073     CS_DISABLE();
                 ; 0003 0074     SPI_transfer(0xFF);
                 ; 0003 0075 
                 ; 0003 0076     return res1;
                 ; 0003 0077 }
                 ; .FEND
                 ;
                 ;void SD_readRes7(unsigned char *res)
                 ; 0003 007A {
                 _SD_readRes7:
                 ; .FSTART _SD_readRes7
                 ; 0003 007B     // read response 1 in R7
                 ; 0003 007C     //res[0] = SD_readRes1();
                 ; 0003 007D 
                 ; 0003 007E     // if error reading R1, return
                 ; 0003 007F     if(res[0] > 1) return;
0004ac 93ba      	ST   -Y,R27
0004ad 93aa      	ST   -Y,R26
                 ;	*res -> Y+0
0004ae 81a8      	LD   R26,Y
0004af 81b9      	LDD  R27,Y+1
0004b0 91ac      	LD   R26,X
0004b1 30a2      	CPI  R26,LOW(0x2)
0004b2 f598      	BRSH _0x2060008
                 ; 0003 0080 
                 ; 0003 0081     // read remaining bytes
                 ; 0003 0082     res[1] = SPI_transfer(0xFF);
0004b3 efaf      	LDI  R26,LOW(255)
0004b4 df9d      	RCALL _SPI_transfer
                +
0004b5 81a8     +LDD R26 , Y + 0
0004b6 81b9     +LDD R27 , Y + 0 + 1
0004b7 9611     +ADIW R26 , 1
0004b8 93ec     +ST X , R30
                 	__PUTB1SNS 0,1
                 ; 0003 0083     res[2] = SPI_transfer(0xFF);
0004b9 efaf      	LDI  R26,LOW(255)
0004ba df97      	RCALL _SPI_transfer
                +
0004bb 81a8     +LDD R26 , Y + 0
0004bc 81b9     +LDD R27 , Y + 0 + 1
0004bd 9612     +ADIW R26 , 2
0004be 93ec     +ST X , R30
                 	__PUTB1SNS 0,2
                 ; 0003 0084     res[3] = SPI_transfer(0xFF);
0004bf efaf      	LDI  R26,LOW(255)
0004c0 df91      	RCALL _SPI_transfer
                +
0004c1 81a8     +LDD R26 , Y + 0
0004c2 81b9     +LDD R27 , Y + 0 + 1
0004c3 9613     +ADIW R26 , 3
0004c4 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
                 ; 0003 0085     res[4] = SPI_transfer(0xFF);
0004c5 efaf      	LDI  R26,LOW(255)
0004c6 df8b      	RCALL _SPI_transfer
                +
0004c7 81a8     +LDD R26 , Y + 0
0004c8 81b9     +LDD R27 , Y + 0 + 1
0004c9 9614     +ADIW R26 , 4
0004ca 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
                 ; 0003 0086 }
0004cb c01a      	RJMP _0x2060008
                 ; .FEND
                 ;
                 ;void SD_sendIfCond(unsigned char *res)
                 ; 0003 0089 {
                 _SD_sendIfCond:
                 ; .FSTART _SD_sendIfCond
                 ; 0003 008A     // assert chip select
                 ; 0003 008B     SPI_transfer(0xFF);
0004cc 940e 06a2 	CALL SUBOPT_0x1D
                 ;	*res -> Y+0
                 ; 0003 008C     CS_ENABLE();
                 ; 0003 008D     //SPI_transfer(0xFF);
                 ; 0003 008E 
                 ; 0003 008F     // send CMD8
                 ; 0003 0090     res[0]=SD_command(CMD8, CMD8_ARG, CMD8_CRC);
0004ce e0e8      	LDI  R30,LOW(8)
0004cf 93ea      	ST   -Y,R30
                +
0004d0 eaea     +LDI R30 , LOW ( 0x1AA )
0004d1 e0f1     +LDI R31 , HIGH ( 0x1AA )
0004d2 e060     +LDI R22 , BYTE3 ( 0x1AA )
0004d3 e070     +LDI R23 , BYTE4 ( 0x1AA )
                 	__GETD1N 0x1AA
0004d4 940e 0758 	CALL __PUTPARD1
0004d6 e8a6      	LDI  R26,LOW(134)
0004d7 c007      	RJMP _0x2060007
                 ; 0003 0091 
                 ; 0003 0092     // read response
                 ; 0003 0093     SD_readRes7(res);
                 ; 0003 0094 
                 ; 0003 0095     // deassert chip select
                 ; 0003 0096     SPI_transfer(0xFF);
                 ; 0003 0097     CS_DISABLE();
                 ; 0003 0098     SPI_transfer(0xFF);
                 ; 0003 0099 }
                 ; .FEND
                 ;
                 ;/*
                 ;void SD_readRes3_7(unsigned char *res)
                 ;{
                 ;    // read R1
                 ;    //res[0] = SD_readRes1();
                 ;
                 ;    // if error reading R1, return
                 ;    if(res[0] > 1) return;
                 ;
                 ;    // read remaining bytes
                 ;    res[1] = SPI_transfer(0xFF);
                 ;    res[2] = SPI_transfer(0xFF);
                 ;    res[3] = SPI_transfer(0xFF);
                 ;    res[4] = SPI_transfer(0xFF);
                 ;}
                 ;*/
                 ;
                 ;void SD_readOCR(unsigned char *res)
                 ; 0003 00AD {
                 _SD_readOCR:
                 ; .FSTART _SD_readOCR
                 ; 0003 00AE     // assert chip select
                 ; 0003 00AF     SPI_transfer(0xFF);
0004d8 940e 06a2 	CALL SUBOPT_0x1D
                 ;	*res -> Y+0
                 ; 0003 00B0     CS_ENABLE();
                 ; 0003 00B1     //SPI_transfer(0xFF);
                 ; 0003 00B2 
                 ; 0003 00B3     // send CMD58
                 ; 0003 00B4     res[0] = SD_command(CMD58, CMD58_ARG, CMD58_CRC);
0004da e3ea      	LDI  R30,LOW(58)
0004db 93ea      	ST   -Y,R30
0004dc 940e 05a2 	CALL SUBOPT_0x1
0004de e0a0      	LDI  R26,LOW(0)
                 _0x2060007:
0004df df8b      	RCALL _SD_command
0004e0 81a8      	LD   R26,Y
0004e1 81b9      	LDD  R27,Y+1
0004e2 93ec      	ST   X,R30
                 ; 0003 00B5 
                 ; 0003 00B6     // read response
                 ; 0003 00B7     //SD_readRes3_7(res);
                 ; 0003 00B8     SD_readRes7(res);
0004e3 dfc8      	RCALL _SD_readRes7
                 ; 0003 00B9 
                 ; 0003 00BA     // deassert chip select
                 ; 0003 00BB     SPI_transfer(0xFF);
0004e4 940e 06a9 	CALL SUBOPT_0x1E
                 ; 0003 00BC     CS_DISABLE();
                 ; 0003 00BD     SPI_transfer(0xFF);
                 ; 0003 00BE }
                 _0x2060008:
0004e6 9622      	ADIW R28,2
0004e7 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SD_sendApp()
                 ; 0003 00C1 {
                 _SD_sendApp:
                 ; .FSTART _SD_sendApp
                 ; 0003 00C2     unsigned char res1;
                 ; 0003 00C3     // assert chip select
                 ; 0003 00C4     SPI_transfer(0xFF);
0004e8 940e 069c 	CALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 00C5     CS_ENABLE();
                 ; 0003 00C6     //SPI_transfer(0xFF);
                 ; 0003 00C7 
                 ; 0003 00C8     // send CMD0
                 ; 0003 00C9     res1 = SD_command(CMD55, CMD55_ARG, CMD55_CRC);
0004ea e3e7      	LDI  R30,LOW(55)
0004eb 93ea      	ST   -Y,R30
                +
0004ec e0e0     +LDI R30 , LOW ( 0x0 )
0004ed e0f0     +LDI R31 , HIGH ( 0x0 )
0004ee e060     +LDI R22 , BYTE3 ( 0x0 )
0004ef e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
0004f0 c008      	RJMP _0x2060004
                 ; 0003 00CA 
                 ; 0003 00CB     // read response
                 ; 0003 00CC     //res1 = SD_readRes1();
                 ; 0003 00CD 
                 ; 0003 00CE     // deassert chip select
                 ; 0003 00CF     SPI_transfer(0xFF);
                 ; 0003 00D0     CS_DISABLE();
                 ; 0003 00D1     SPI_transfer(0xFF);
                 ; 0003 00D2 
                 ; 0003 00D3     return res1;
                 ; 0003 00D4 }
                 ; .FEND
                 ;
                 ;unsigned char SD_sendOpCond()
                 ; 0003 00D7 {
                 _SD_sendOpCond:
                 ; .FSTART _SD_sendOpCond
                 ; 0003 00D8     unsigned char res1;
                 ; 0003 00D9     // assert chip select
                 ; 0003 00DA     SPI_transfer(0xFF);
0004f1 940e 069c 	CALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 00DB     CS_ENABLE();
                 ; 0003 00DC     //SPI_transfer(0xFF);
                 ; 0003 00DD 
                 ; 0003 00DE     // send CMD0
                 ; 0003 00DF     res1 =  SD_command(ACMD41, ACMD41_ARG, ACMD41_CRC);
0004f3 e2e9      	LDI  R30,LOW(41)
0004f4 93ea      	ST   -Y,R30
                +
0004f5 e0e0     +LDI R30 , LOW ( 0x40000000 )
0004f6 e0f0     +LDI R31 , HIGH ( 0x40000000 )
0004f7 e060     +LDI R22 , BYTE3 ( 0x40000000 )
0004f8 e470     +LDI R23 , BYTE4 ( 0x40000000 )
                 	__GETD1N 0x40000000
                 _0x2060004:
0004f9 940e 0758 	CALL __PUTPARD1
0004fb e0a0      	LDI  R26,LOW(0)
                 _0x2060005:
0004fc df6e      	RCALL _SD_command
0004fd 2f1e      	MOV  R17,R30
                 ; 0003 00E0 
                 ; 0003 00E1     // read response
                 ; 0003 00E2     //res1 = SD_readRes1();
                 ; 0003 00E3 
                 ; 0003 00E4     // deassert chip select
                 ; 0003 00E5     SPI_transfer(0xFF);
0004fe 940e 06a9 	CALL SUBOPT_0x1E
                 ; 0003 00E6     CS_DISABLE();
                 ; 0003 00E7     SPI_transfer(0xFF);
                 ; 0003 00E8 
                 ; 0003 00E9     return res1;
000500 2fe1      	MOV  R30,R17
                 _0x2060006:
000501 9119      	LD   R17,Y+
000502 9508      	RET
                 ; 0003 00EA }
                 ; .FEND
                 ;
                 ;unsigned char SD_init()
                 ; 0003 00ED {
                 _SD_init:
                 ; .FSTART _SD_init
                 ; 0003 00EE     unsigned char res[5], cmdAttempts = 0;
                 ; 0003 00EF 
                 ; 0003 00F0     SD_powerUpSeq();
000503 9725      	SBIW R28,5
000504 931a      	ST   -Y,R17
                 ;	res -> Y+1
                 ;	cmdAttempts -> R17
000505 e010      	LDI  R17,0
000506 df53      	RCALL _SD_powerUpSeq
                 ; 0003 00F1 
                 ; 0003 00F2     // command card to idle
                 ; 0003 00F3     while((res[0] = SD_goIdleState()) != 0x01)
                 _0x6000E:
000507 df9c      	RCALL _SD_goIdleState
000508 83e9      	STD  Y+1,R30
000509 30e1      	CPI  R30,LOW(0x1)
00050a f031      	BREQ _0x60010
                 ; 0003 00F4     {
                 ; 0003 00F5         cmdAttempts++;
00050b 5f1f      	SUBI R17,-1
                 ; 0003 00F6         if(cmdAttempts > 100) return SD_ERROR;
00050c 3615      	CPI  R17,101
00050d f010      	BRLO _0x60011
00050e e0e1      	LDI  R30,LOW(1)
00050f c02e      	RJMP _0x2060002
                 ; 0003 00F7     }
                 _0x60011:
000510 cff6      	RJMP _0x6000E
                 _0x60010:
                 ; 0003 00F8 
                 ; 0003 00F9     // send interface conditions
                 ; 0003 00FA     SD_sendIfCond(res);
000511 01de      	MOVW R26,R28
000512 9611      	ADIW R26,1
000513 dfb8      	RCALL _SD_sendIfCond
                 ; 0003 00FB     if(res[0] != 0x01)
000514 81a9      	LDD  R26,Y+1
000515 30a1      	CPI  R26,LOW(0x1)
000516 f011      	BREQ _0x60012
                 ; 0003 00FC     {
                 ; 0003 00FD         return SD_ERROR;
000517 e0e1      	LDI  R30,LOW(1)
000518 c025      	RJMP _0x2060002
                 ; 0003 00FE     }
                 ; 0003 00FF 
                 ; 0003 0100     // check echo pattern
                 ; 0003 0101     if(res[4] != 0xAA)
                 _0x60012:
000519 81ad      	LDD  R26,Y+5
00051a 3aaa      	CPI  R26,LOW(0xAA)
00051b f011      	BREQ _0x60013
                 ; 0003 0102     {
                 ; 0003 0103         return SD_ERROR;
00051c e0e1      	LDI  R30,LOW(1)
00051d c020      	RJMP _0x2060002
                 ; 0003 0104     }
                 ; 0003 0105 
                 ; 0003 0106     // attempt to initialize card
                 ; 0003 0107     cmdAttempts = 0;
                 _0x60013:
00051e e010      	LDI  R17,LOW(0)
                 ; 0003 0108     do
                 _0x60015:
                 ; 0003 0109     {
                 ; 0003 010A         if(cmdAttempts > 100) return SD_ERROR;
00051f 3615      	CPI  R17,101
000520 f010      	BRLO _0x60017
000521 e0e1      	LDI  R30,LOW(1)
000522 c01b      	RJMP _0x2060002
                 ; 0003 010B 
                 ; 0003 010C         // send app cmd
                 ; 0003 010D         res[0] = SD_sendApp();
                 _0x60017:
000523 dfc4      	RCALL _SD_sendApp
000524 83e9      	STD  Y+1,R30
                 ; 0003 010E 
                 ; 0003 010F         // if no error in response
                 ; 0003 0110         if(res[0] < 2)
000525 81a9      	LDD  R26,Y+1
000526 30a2      	CPI  R26,LOW(0x2)
000527 f410      	BRSH _0x60018
                 ; 0003 0111         {
                 ; 0003 0112             res[0] = SD_sendOpCond();
000528 dfc8      	RCALL _SD_sendOpCond
000529 83e9      	STD  Y+1,R30
                 ; 0003 0113         }
                 ; 0003 0114 
                 ; 0003 0115         // wait
                 ; 0003 0116         if(res[0] != SD_READY)
                 _0x60018:
00052a 81e9      	LDD  R30,Y+1
00052b 30e0      	CPI  R30,0
00052c f021      	BREQ _0x60019
                 ; 0003 0117             delay_ms(10);
00052d e0aa      	LDI  R26,LOW(10)
00052e e0b0      	LDI  R27,0
00052f 940e 06ad 	CALL _delay_ms
                 ; 0003 0118 
                 ; 0003 0119         cmdAttempts++;
                 _0x60019:
000531 5f1f      	SUBI R17,-1
                 ; 0003 011A     }
                 ; 0003 011B     while(res[0] != SD_READY);
000532 81e9      	LDD  R30,Y+1
000533 30e0      	CPI  R30,0
000534 f751      	BRNE _0x60015
                 ; 0003 011C 
                 ; 0003 011D     // read OCR
                 ; 0003 011E     SD_readOCR(res);
000535 01de      	MOVW R26,R28
000536 9611      	ADIW R26,1
000537 dfa0      	RCALL _SD_readOCR
                 ; 0003 011F 
                 ; 0003 0120     // check card is ready
                 ; 0003 0121     if(!(res[1] & 0x80)) return SD_ERROR;
000538 81ea      	LDD  R30,Y+2
000539 78e0      	ANDI R30,LOW(0x80)
00053a f411      	BRNE _0x6001A
00053b e0e1      	LDI  R30,LOW(1)
00053c c001      	RJMP _0x2060002
                 ; 0003 0122 
                 ; 0003 0123     return SD_SUCCESS;
                 _0x6001A:
00053d e0e0      	LDI  R30,LOW(0)
                 _0x2060002:
00053e 8118      	LDD  R17,Y+0
                 _0x2060003:
00053f 9626      	ADIW R28,6
000540 9508      	RET
                 ; 0003 0124 }
                 ; .FEND
                 ;
                 ;#define CMD17                   17
                 ;#define CMD17_CRC               0x00
                 ;#define SD_MAX_READ_ATTEMPTS    1563
                 ;
                 ;/*******************************************************************************
                 ; Read single 512 byte block
                 ; token = 0xFE - Successful read
                 ; token = 0x0X - Data error
                 ; token = 0xFF - Timeout
                 ;*******************************************************************************/
                 ;unsigned char SD_readSingleBlock(unsigned long addr, unsigned char *buf, unsigned char *token)
                 ; 0003 0131 {
                 _SD_readSingleBlock:
                 ; .FSTART _SD_readSingleBlock
                 ; 0003 0132     unsigned char res1, read;
                 ; 0003 0133     unsigned int i, readAttempts;
                 ; 0003 0134     addr*=512UL;
000541 93ba      	ST   -Y,R27
000542 93aa      	ST   -Y,R26
000543 940e 076b 	CALL __SAVELOCR6
                 ;	addr -> Y+10
                 ;	*buf -> Y+8
                 ;	*token -> Y+6
                 ;	res1 -> R17
                 ;	read -> R16
                 ;	i -> R18,R19
                 ;	readAttempts -> R20,R21
                +
000545 85ea     +LDD R30 , Y + 10
000546 85fb     +LDD R31 , Y + 10 + 1
000547 856c     +LDD R22 , Y + 10 + 2
000548 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
                +
000549 e0a0     +LDI R26 , LOW ( 0x200 )
00054a e0b2     +LDI R27 , HIGH ( 0x200 )
00054b e080     +LDI R24 , BYTE3 ( 0x200 )
00054c e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
00054d 940e 0706 	CALL __MULD12U
                +
00054f 87ea     +STD Y + 10 , R30
000550 87fb     +STD Y + 10 + 1 , R31
000551 876c     +STD Y + 10 + 2 , R22
000552 877d     +STD Y + 10 + 3 , R23
                 	__PUTD1S 10
                 ; 0003 0135     // set token to none
                 ; 0003 0136     *token = 0xFF;
000553 81ae      	LDD  R26,Y+6
000554 81bf      	LDD  R27,Y+6+1
000555 efef      	LDI  R30,LOW(255)
000556 93ec      	ST   X,R30
                 ; 0003 0137 
                 ; 0003 0138     // assert chip select
                 ; 0003 0139     SPI_transfer(0xFF);
000557 efaf      	LDI  R26,LOW(255)
000558 def9      	RCALL _SPI_transfer
                 ; 0003 013A     CS_ENABLE();
000559 98c0      	CBI  0x18,0
                 ; 0003 013B     //SPI_transfer(0xFF);
                 ; 0003 013C 
                 ; 0003 013D     // send CMD17
                 ; 0003 013E     res1 = SD_command(CMD17, addr, CMD17_CRC);
00055a e1e1      	LDI  R30,LOW(17)
00055b 93ea      	ST   -Y,R30
                +
00055c 85eb     +LDD R30 , Y + 11
00055d 85fc     +LDD R31 , Y + 11 + 1
00055e 856d     +LDD R22 , Y + 11 + 2
00055f 857e     +LDD R23 , Y + 11 + 3
                 	__GETD1S 11
000560 940e 0758 	CALL __PUTPARD1
000562 e0a0      	LDI  R26,LOW(0)
000563 df07      	RCALL _SD_command
000564 2f1e      	MOV  R17,R30
                 ; 0003 013F 
                 ; 0003 0140     // read R1
                 ; 0003 0141     //res1 = SD_readRes1();
                 ; 0003 0142 
                 ; 0003 0143     // if response received from card
                 ; 0003 0144     if(res1 != 0xFF)
000565 3f1f      	CPI  R17,255
000566 f169      	BREQ _0x6001B
                 ; 0003 0145     {
                 ; 0003 0146         // wait for a response token (timeout = 100ms)
                 ; 0003 0147         readAttempts = 0;
                +
000567 e040     +LDI R20 , LOW ( 0 )
000568 e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 0148         while(++readAttempts != SD_MAX_READ_ATTEMPTS)
                 _0x6001C:
000569 01fa      	MOVW R30,R20
00056a 9631      	ADIW R30,1
00056b 01af      	MOVW R20,R30
00056c 31eb      	CPI  R30,LOW(0x61B)
00056d e0a6      	LDI  R26,HIGH(0x61B)
00056e 07fa      	CPC  R31,R26
00056f f029      	BREQ _0x6001E
                 ; 0003 0149             if((read = SPI_transfer(0xFF)) != 0xFF) break;
000570 efaf      	LDI  R26,LOW(255)
000571 dee0      	RCALL _SPI_transfer
000572 2f0e      	MOV  R16,R30
000573 3fef      	CPI  R30,LOW(0xFF)
000574 f3a1      	BREQ _0x6001C
                 ; 0003 014A 
                 ; 0003 014B         // if response token is 0xFE
                 ; 0003 014C         if(read == 0xFE)
                 _0x6001E:
000575 3f0e      	CPI  R16,254
000576 f4d1      	BRNE _0x60020
                 ; 0003 014D         {
                 ; 0003 014E             // read 512 byte block
                 ; 0003 014F             for(i = 0; i < 512; i++) *buf++ = SPI_transfer(0xFF);
                +
000577 e020     +LDI R18 , LOW ( 0 )
000578 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60022:
                +
000579 3020     +CPI R18 , LOW ( 512 )
00057a e0e2     +LDI R30 , HIGH ( 512 )
00057b 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00057c f480      	BRSH _0x60023
00057d 85e8      	LDD  R30,Y+8
00057e 85f9      	LDD  R31,Y+8+1
00057f 9631      	ADIW R30,1
000580 87e8      	STD  Y+8,R30
000581 87f9      	STD  Y+8+1,R31
000582 9731      	SBIW R30,1
000583 93ff      	PUSH R31
000584 93ef      	PUSH R30
000585 efaf      	LDI  R26,LOW(255)
000586 decb      	RCALL _SPI_transfer
000587 91af      	POP  R26
000588 91bf      	POP  R27
000589 93ec      	ST   X,R30
                +
00058a 5f2f     +SUBI R18 , LOW ( - 1 )
00058b 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00058c cfec      	RJMP _0x60022
                 _0x60023:
                 ; 0003 0152 SPI_transfer(0xFF);
00058d efaf      	LDI  R26,LOW(255)
00058e dec3      	RCALL _SPI_transfer
                 ; 0003 0153             SPI_transfer(0xFF);
00058f efaf      	LDI  R26,LOW(255)
000590 dec1      	RCALL _SPI_transfer
                 ; 0003 0154         }
                 ; 0003 0155 
                 ; 0003 0156         // set token to card response
                 ; 0003 0157         *token = read;
                 _0x60020:
000591 81ae      	LDD  R26,Y+6
000592 81bf      	LDD  R27,Y+6+1
000593 930c      	ST   X,R16
                 ; 0003 0158     }
                 ; 0003 0159 
                 ; 0003 015A     // deassert chip select
                 ; 0003 015B     SPI_transfer(0xFF);
                 _0x6001B:
000594 940e 06a9 	CALL SUBOPT_0x1E
                 ; 0003 015C     CS_DISABLE();
                 ; 0003 015D     SPI_transfer(0xFF);
                 ; 0003 015E     if(read==0xFE)
000596 3f0e      	CPI  R16,254
000597 f411      	BRNE _0x60024
                 ; 0003 015F         return res1;
000598 2fe1      	MOV  R30,R17
000599 c001      	RJMP _0x2060001
                 ; 0003 0160     else
                 _0x60024:
                 ; 0003 0161         return SD_ERROR;
00059a e0e1      	LDI  R30,LOW(1)
                 ; 0003 0162 }
                 _0x2060001:
00059b 940e 0772 	CALL __LOADLOCR6
00059d 962e      	ADIW R28,14
00059e 9508      	RET
                 ; .FEND
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.CSEG
                 
                 	.DSEG
                 _result:
000915           	.BYTE 0x5
                 _sdBuf:
00091a           	.BYTE 0x200
                 _testBuf:
000b1a           	.BYTE 0x100
                 _appStartAdr:
000c1a           	.BYTE 0x4
                 _adr:
000c1e           	.BYTE 0x4
                 _SectorsPerFat:
000c22           	.BYTE 0x4
                 _fat_begin_lba:
000c26           	.BYTE 0x4
                 _cluster_begin_lba:
000c2a           	.BYTE 0x4
                 _fat_file_adr:
000c2e           	.BYTE 0x4
                 _fat_file_next_adr:
000c32           	.BYTE 0x4
                 _filesize:
000c36           	.BYTE 0x4
                 _readbytes:
000c3a           	.BYTE 0x4
                 _bytesChecksum:
000c3e           	.BYTE 0x2
                 _checksumCnt:
000c40           	.BYTE 0x2
                 _app_pointer:
000c42           	.BYTE 0x2
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
00059f 940e 0749 	CALL __GETD1S0
0005a1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x1:
                +
0005a2 e0e0     +LDI R30 , LOW ( 0x0 )
0005a3 e0f0     +LDI R31 , HIGH ( 0x0 )
0005a4 e060     +LDI R22 , BYTE3 ( 0x0 )
0005a5 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
0005a6 940e 0758 	CALL __PUTPARD1
0005a8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2:
                +
0005a9 e0a0     +LDI R26 , LOW ( 0x1EF00 )
0005aa eebf     +LDI R27 , HIGH ( 0x1EF00 )
0005ab e081     +LDI R24 , BYTE3 ( 0x1EF00 )
0005ac e090     +LDI R25 , BYTE4 ( 0x1EF00 )
                 	__GETD2N 0x1EF00
0005ad 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3:
0005ae 940e 075d 	CALL __PUTPARD2
0005b0 940e 074e 	CALL __GETD2S0
0005b2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4:
0005b3 940e 074e 	CALL __GETD2S0
0005b5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:42 WORDS
                 SUBOPT_0x5:
0005b6 e1ea      	LDI  R30,LOW(_sdBuf)
0005b7 e0f9      	LDI  R31,HIGH(_sdBuf)
0005b8 93fa      	ST   -Y,R31
0005b9 93ea      	ST   -Y,R30
0005ba e0a9      	LDI  R26,LOW(9)
0005bb e0b0      	LDI  R27,HIGH(9)
0005bc 940e 0541 	CALL _SD_readSingleBlock
0005be 93e0 0915 	STS  _result,R30
0005c0 30e0      	CPI  R30,0
0005c1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x6:
0005c2 93fa      	ST   -Y,R31
0005c3 93ea      	ST   -Y,R30
0005c4 e0a4      	LDI  R26,LOW(4)
0005c5 940c 0420 	JMP  _buf2num
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x7:
0005c7 93e0 0c1e 	STS  _adr,R30
0005c9 93f0 0c1f 	STS  _adr+1,R31
0005cb 9360 0c20 	STS  _adr+2,R22
0005cd 9370 0c21 	STS  _adr+3,R23
0005cf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
                 SUBOPT_0x8:
0005d0 91e0 0c1e 	LDS  R30,_adr
0005d2 91f0 0c1f 	LDS  R31,_adr+1
0005d4 9160 0c20 	LDS  R22,_adr+2
0005d6 9170 0c21 	LDS  R23,_adr+3
0005d8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x9:
0005d9 940e 0758 	CALL __PUTPARD1
0005db cfda      	RJMP SUBOPT_0x5
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xA:
0005dc 2de8      	MOV  R30,R8
0005dd 01d8      	MOVW R26,R16
0005de e0f0      	LDI  R31,0
0005df 17ae      	CP   R26,R30
0005e0 07bf      	CPC  R27,R31
0005e1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xB:
0005e2 dfed      	RCALL SUBOPT_0x8
0005e3 cff5      	RJMP SUBOPT_0x9
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0xC:
0005e4 93fa      	ST   -Y,R31
0005e5 93ea      	ST   -Y,R30
                +
0005e6 e2a0     +LDI R26 , 32
0005e7 9fa2     +MUL R26 , R18
0005e8 01f0     +MOVW R30 , R0
0005e9 9fa3     +MUL R26 , R19
0005ea 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
0005eb 5ee6      	SUBI R30,LOW(-_sdBuf)
0005ec 4ff6      	SBCI R31,HIGH(-_sdBuf)
0005ed 01df      	MOVW R26,R30
0005ee 940e 03fa 	CALL _compbuf
                +
0005f0 93e0 0916+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
0005f2 30e0      	CPI  R30,0
0005f3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0xD:
                +
0005f4 e2a0     +LDI R26 , 32
0005f5 9fa2     +MUL R26 , R18
0005f6 01f0     +MOVW R30 , R0
0005f7 9fa3     +MUL R26 , R19
0005f8 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
0005f9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xE:
                +
0005fa 5de2     +SUBI R30 , LOW ( - _sdBuf - ( 20 ) )
0005fb 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 20 ) )
                 	__ADDW1MN _sdBuf,20
0005fc 81e0      	LD   R30,Z
0005fd e0f0      	LDI  R31,0
0005fe 940e 06f9 	CALL __CWD1
000600 940e 06f4 	CALL __LSLD16
000602 93e0 0c2e 	STS  _fat_file_adr,R30
000604 93f0 0c2f 	STS  _fat_file_adr+1,R31
000606 9360 0c30 	STS  _fat_file_adr+2,R22
000608 9370 0c31 	STS  _fat_file_adr+3,R23
00060a cfe9      	RJMP SUBOPT_0xD
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:19 WORDS
                 SUBOPT_0xF:
                +
00060b 5cec     +SUBI R30 , LOW ( - _sdBuf - ( 26 ) )
00060c 4ff6     +SBCI R31 , HIGH ( - _sdBuf - ( 26 ) )
                 	__ADDW1MN _sdBuf,26
00060d 81e0      	LD   R30,Z
00060e e0f0      	LDI  R31,0
00060f 940e 06f9 	CALL __CWD1
000611 91a0 0c2e 	LDS  R26,_fat_file_adr
000613 91b0 0c2f 	LDS  R27,_fat_file_adr+1
000615 9180 0c30 	LDS  R24,_fat_file_adr+2
000617 9190 0c31 	LDS  R25,_fat_file_adr+3
000619 940e 06c1 	CALL __ORD12
00061b 93e0 0c2e 	STS  _fat_file_adr,R30
00061d 93f0 0c2f 	STS  _fat_file_adr+1,R31
00061f 9360 0c30 	STS  _fat_file_adr+2,R22
000621 9370 0c31 	STS  _fat_file_adr+3,R23
000623 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x10:
000624 e1ae      	LDI  R26,LOW(_adr)
000625 e0bc      	LDI  R27,HIGH(_adr)
000626 940e 073f 	CALL __GETD1P_INC
                +
000628 5fef     +SUBI R30 , LOW ( - 1 )
000629 4fff     +SBCI R31 , HIGH ( - 1 )
00062a 4f6f     +SBCI R22 , BYTE3 ( - 1 )
00062b 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
00062c 940e 0744 	CALL __PUTDP1_DEC
00062e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:29 WORDS
                 SUBOPT_0x11:
00062f 91e0 0c2e 	LDS  R30,_fat_file_adr
000631 91f0 0c2f 	LDS  R31,_fat_file_adr+1
000633 9160 0c30 	LDS  R22,_fat_file_adr+2
000635 9170 0c31 	LDS  R23,_fat_file_adr+3
                +
000637 50e2     +SUBI R30 , LOW ( 2 )
000638 40f0     +SBCI R31 , HIGH ( 2 )
000639 4060     +SBCI R22 , BYTE3 ( 2 )
00063a 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
00063b 01df      	MOVW R26,R30
00063c 01cb      	MOVW R24,R22
00063d 2de8      	MOV  R30,R8
00063e e0f0      	LDI  R31,0
00063f 940e 06f9 	CALL __CWD1
000641 940e 0706 	CALL __MULD12U
000643 91a0 0c2a 	LDS  R26,_cluster_begin_lba
000645 91b0 0c2b 	LDS  R27,_cluster_begin_lba+1
000647 9180 0c2c 	LDS  R24,_cluster_begin_lba+2
000649 9190 0c2d 	LDS  R25,_cluster_begin_lba+3
00064b 940e 06b7 	CALL __ADDD12
00064d df79      	RCALL SUBOPT_0x7
                +
00064e e000     +LDI R16 , LOW ( 0 )
00064f e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
000650 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x12:
                +
000651 3faf     +CPI R26 , LOW ( 0xFFFFFFF )
000652 efef     +LDI R30 , HIGH ( 0xFFFFFFF )
000653 07be     +CPC R27 , R30
000654 efef     +LDI R30 , BYTE3 ( 0xFFFFFFF )
000655 078e     +CPC R24 , R30
000656 e0ef     +LDI R30 , BYTE4 ( 0xFFFFFFF )
000657 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFFFFF
000658 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x13:
000659 e1aa      	LDI  R26,LOW(_sdBuf)
00065a e0b9      	LDI  R27,HIGH(_sdBuf)
00065b 0fa2      	ADD  R26,R18
00065c 1fb3      	ADC  R27,R19
00065d 91ec      	LD   R30,X
00065e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x14:
00065f 91a0 0c3a 	LDS  R26,_readbytes
000661 91b0 0c3b 	LDS  R27,_readbytes+1
000663 9180 0c3c 	LDS  R24,_readbytes+2
000665 9190 0c3d 	LDS  R25,_readbytes+3
000667 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x15:
000668 91e0 0c1a 	LDS  R30,_appStartAdr
00066a 91f0 0c1b 	LDS  R31,_appStartAdr+1
00066c 9160 0c1c 	LDS  R22,_appStartAdr+2
00066e 9170 0c1d 	LDS  R23,_appStartAdr+3
000670 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x16:
000671 efa4      	LDI  R26,LOW(500)
000672 e0b1      	LDI  R27,HIGH(500)
000673 940c 06ad 	JMP  _delay_ms
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x17:
000675 93e0 0c1a 	STS  _appStartAdr,R30
000677 93f0 0c1b 	STS  _appStartAdr+1,R31
000679 9360 0c1c 	STS  _appStartAdr+2,R22
00067b 9370 0c1d 	STS  _appStartAdr+3,R23
00067d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x18:
00067e 91a0 0c1a 	LDS  R26,_appStartAdr
000680 91b0 0c1b 	LDS  R27,_appStartAdr+1
000682 9180 0c1c 	LDS  R24,_appStartAdr+2
000684 9190 0c1d 	LDS  R25,_appStartAdr+3
000686 940e 06c1 	CALL __ORD12
000688 cfec      	RJMP SUBOPT_0x17
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x19:
                +
000689 e0e0     +LDI R30 , LOW ( 0x1EF00 )
00068a eeff     +LDI R31 , HIGH ( 0x1EF00 )
00068b e061     +LDI R22 , BYTE3 ( 0x1EF00 )
00068c e070     +LDI R23 , BYTE4 ( 0x1EF00 )
                 	__GETD1N 0x1EF00
00068d 940e 0758 	CALL __PUTPARD1
00068f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1A:
000690 9ac0      	SBI  0x18,0
000691 efaf      	LDI  R26,LOW(255)
000692 940c 0452 	JMP  _SPI_transfer
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1B:
000694 2fae      	MOV  R26,R30
000695 940e 0452 	CALL _SPI_transfer
                +
000697 81ab     +LDD R26 , Y + 3
000698 81bc     +LDD R27 , Y + 3 + 1
000699 818d     +LDD R24 , Y + 3 + 2
00069a 819e     +LDD R25 , Y + 3 + 3
                 	__GETD2S 3
00069b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1C:
00069c 931a      	ST   -Y,R17
00069d efaf      	LDI  R26,LOW(255)
00069e 940e 0452 	CALL _SPI_transfer
0006a0 98c0      	CBI  0x18,0
0006a1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1D:
0006a2 93ba      	ST   -Y,R27
0006a3 93aa      	ST   -Y,R26
0006a4 efaf      	LDI  R26,LOW(255)
0006a5 940e 0452 	CALL _SPI_transfer
0006a7 98c0      	CBI  0x18,0
0006a8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1E:
0006a9 efaf      	LDI  R26,LOW(255)
0006aa 940e 0452 	CALL _SPI_transfer
0006ac cfe3      	RJMP SUBOPT_0x1A
                 
                 
                 	.CSEG
                 _delay_ms:
0006ad 9610      	adiw r26,0
0006ae f039      	breq __delay_ms1
                 __delay_ms0:
                +
0006af ee88     +LDI R24 , LOW ( 0x3E8 )
0006b0 e093     +LDI R25 , HIGH ( 0x3E8 )
                +__DELAY_USW_LOOP :
0006b1 9701     +SBIW R24 , 1
0006b2 f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x3E8
0006b3 95a8      	wdr
0006b4 9711      	sbiw r26,1
0006b5 f7c9      	brne __delay_ms0
                 __delay_ms1:
0006b6 9508      	ret
                 
                 __ADDD12:
0006b7 0fea      	ADD  R30,R26
0006b8 1ffb      	ADC  R31,R27
0006b9 1f68      	ADC  R22,R24
0006ba 1f79      	ADC  R23,R25
0006bb 9508      	RET
                 
                 __ADDD21:
0006bc 0fae      	ADD  R26,R30
0006bd 1fbf      	ADC  R27,R31
0006be 1f86      	ADC  R24,R22
0006bf 1f97      	ADC  R25,R23
0006c0 9508      	RET
                 
                 __ORD12:
0006c1 2bea      	OR   R30,R26
0006c2 2bfb      	OR   R31,R27
0006c3 2b68      	OR   R22,R24
0006c4 2b79      	OR   R23,R25
0006c5 9508      	RET
                 
                 __ANEGW1:
0006c6 95f1      	NEG  R31
0006c7 95e1      	NEG  R30
0006c8 40f0      	SBCI R31,0
0006c9 9508      	RET
                 
                 __LSLB12:
0006ca 23ee      	TST  R30
0006cb 2e0e      	MOV  R0,R30
0006cc 2fea      	MOV  R30,R26
0006cd f019      	BREQ __LSLB12R
                 __LSLB12L:
0006ce 0fee      	LSL  R30
0006cf 940a      	DEC  R0
0006d0 f7e9      	BRNE __LSLB12L
                 __LSLB12R:
0006d1 9508      	RET
                 
                 __LSLD12:
0006d2 23ee      	TST  R30
0006d3 2e0e      	MOV  R0,R30
0006d4 01fd      	MOVW R30,R26
0006d5 01bc      	MOVW R22,R24
0006d6 f031      	BREQ __LSLD12R
                 __LSLD12L:
0006d7 0fee      	LSL  R30
0006d8 1fff      	ROL  R31
0006d9 1f66      	ROL  R22
0006da 1f77      	ROL  R23
0006db 940a      	DEC  R0
0006dc f7d1      	BRNE __LSLD12L
                 __LSLD12R:
0006dd 9508      	RET
                 
                 __LSRD12:
0006de 23ee      	TST  R30
0006df 2e0e      	MOV  R0,R30
0006e0 01fd      	MOVW R30,R26
0006e1 01bc      	MOVW R22,R24
0006e2 f031      	BREQ __LSRD12R
                 __LSRD12L:
0006e3 9576      	LSR  R23
0006e4 9567      	ROR  R22
0006e5 95f7      	ROR  R31
0006e6 95e7      	ROR  R30
0006e7 940a      	DEC  R0
0006e8 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
0006e9 9508      	RET
                 
                 __LSLD1:
0006ea 0fee      	LSL  R30
0006eb 1fff      	ROL  R31
0006ec 1f66      	ROL  R22
0006ed 1f77      	ROL  R23
0006ee 9508      	RET
                 
                 __LSRD16:
0006ef 2fe6      	MOV  R30,R22
0006f0 2ff7      	MOV  R31,R23
0006f1 e060      	LDI  R22,0
0006f2 e070      	LDI  R23,0
0006f3 9508      	RET
                 
                 __LSLD16:
0006f4 2f6e      	MOV  R22,R30
0006f5 2f7f      	MOV  R23,R31
0006f6 e0e0      	LDI  R30,0
0006f7 e0f0      	LDI  R31,0
0006f8 9508      	RET
                 
                 __CWD1:
0006f9 2f6f      	MOV  R22,R31
0006fa 0f66      	ADD  R22,R22
0006fb 0b66      	SBC  R22,R22
0006fc 2f76      	MOV  R23,R22
0006fd 9508      	RET
                 
                 __MULW12U:
0006fe 9ffa      	MUL  R31,R26
0006ff 2df0      	MOV  R31,R0
000700 9feb      	MUL  R30,R27
000701 0df0      	ADD  R31,R0
000702 9fea      	MUL  R30,R26
000703 2de0      	MOV  R30,R0
000704 0df1      	ADD  R31,R1
000705 9508      	RET
                 
                 __MULD12U:
000706 9f7a      	MUL  R23,R26
000707 2d70      	MOV  R23,R0
000708 9f6b      	MUL  R22,R27
000709 0d70      	ADD  R23,R0
00070a 9ff8      	MUL  R31,R24
00070b 0d70      	ADD  R23,R0
00070c 9fe9      	MUL  R30,R25
00070d 0d70      	ADD  R23,R0
00070e 9f6a      	MUL  R22,R26
00070f 2d60      	MOV  R22,R0
000710 0d71      	ADD  R23,R1
000711 9ffb      	MUL  R31,R27
000712 0d60      	ADD  R22,R0
000713 1d71      	ADC  R23,R1
000714 9fe8      	MUL  R30,R24
000715 0d60      	ADD  R22,R0
000716 1d71      	ADC  R23,R1
000717 2788      	CLR  R24
000718 9ffa      	MUL  R31,R26
000719 2df0      	MOV  R31,R0
00071a 0d61      	ADD  R22,R1
00071b 1f78      	ADC  R23,R24
00071c 9feb      	MUL  R30,R27
00071d 0df0      	ADD  R31,R0
00071e 1d61      	ADC  R22,R1
00071f 1f78      	ADC  R23,R24
000720 9fea      	MUL  R30,R26
000721 2de0      	MOV  R30,R0
000722 0df1      	ADD  R31,R1
000723 1f68      	ADC  R22,R24
000724 1f78      	ADC  R23,R24
000725 9508      	RET
                 
                 __MULB1W2U:
000726 2f6e      	MOV  R22,R30
000727 9f6a      	MUL  R22,R26
000728 01f0      	MOVW R30,R0
000729 9f6b      	MUL  R22,R27
00072a 0df0      	ADD  R31,R0
00072b 9508      	RET
                 
                 __MULW12:
00072c d004      	RCALL __CHKSIGNW
00072d dfd0      	RCALL __MULW12U
00072e f40e      	BRTC __MULW121
00072f df96      	RCALL __ANEGW1
                 __MULW121:
000730 9508      	RET
                 
                 __CHKSIGNW:
000731 94e8      	CLT
000732 fff7      	SBRS R31,7
000733 c002      	RJMP __CHKSW1
000734 df91      	RCALL __ANEGW1
000735 9468      	SET
                 __CHKSW1:
000736 ffb7      	SBRS R27,7
000737 c006      	RJMP __CHKSW2
000738 95a0      	COM  R26
000739 95b0      	COM  R27
00073a 9611      	ADIW R26,1
00073b f800      	BLD  R0,0
00073c 9403      	INC  R0
00073d fa00      	BST  R0,0
                 __CHKSW2:
00073e 9508      	RET
                 
                 __GETD1P_INC:
00073f 91ed      	LD   R30,X+
000740 91fd      	LD   R31,X+
000741 916d      	LD   R22,X+
000742 917d      	LD   R23,X+
000743 9508      	RET
                 
                 __PUTDP1_DEC:
000744 937e      	ST   -X,R23
000745 936e      	ST   -X,R22
000746 93fe      	ST   -X,R31
000747 93ee      	ST   -X,R30
000748 9508      	RET
                 
                 __GETD1S0:
000749 81e8      	LD   R30,Y
00074a 81f9      	LDD  R31,Y+1
00074b 816a      	LDD  R22,Y+2
00074c 817b      	LDD  R23,Y+3
00074d 9508      	RET
                 
                 __GETD2S0:
00074e 81a8      	LD   R26,Y
00074f 81b9      	LDD  R27,Y+1
000750 818a      	LDD  R24,Y+2
000751 819b      	LDD  R25,Y+3
000752 9508      	RET
                 
                 __PUTD1S0:
000753 83e8      	ST   Y,R30
000754 83f9      	STD  Y+1,R31
000755 836a      	STD  Y+2,R22
000756 837b      	STD  Y+3,R23
000757 9508      	RET
                 
                 __PUTPARD1:
000758 937a      	ST   -Y,R23
000759 936a      	ST   -Y,R22
00075a 93fa      	ST   -Y,R31
00075b 93ea      	ST   -Y,R30
00075c 9508      	RET
                 
                 __PUTPARD2:
00075d 939a      	ST   -Y,R25
00075e 938a      	ST   -Y,R24
00075f 93ba      	ST   -Y,R27
000760 93aa      	ST   -Y,R26
000761 9508      	RET
                 
                 __CPD20:
000762 9710      	SBIW R26,0
000763 4080      	SBCI R24,0
000764 4090      	SBCI R25,0
000765 9508      	RET
                 
                 __CPD21:
000766 17ae      	CP   R26,R30
000767 07bf      	CPC  R27,R31
000768 0786      	CPC  R24,R22
000769 0797      	CPC  R25,R23
00076a 9508      	RET
                 
                 __SAVELOCR6:
00076b 935a      	ST   -Y,R21
                 __SAVELOCR5:
00076c 934a      	ST   -Y,R20
                 __SAVELOCR4:
00076d 933a      	ST   -Y,R19
                 __SAVELOCR3:
00076e 932a      	ST   -Y,R18
                 __SAVELOCR2:
00076f 931a      	ST   -Y,R17
000770 930a      	ST   -Y,R16
000771 9508      	RET
                 
                 __LOADLOCR6:
000772 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
000773 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
000774 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
000775 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
000776 8119      	LDD  R17,Y+1
000777 8108      	LD   R16,Y
000778 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  43 r1 :  12 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   3 r9 :   0 r10:   0 r11:   4 r12:   5 r13:   2 r14:   0 r15:   0 
r16:  26 r17:  39 r18:  24 r19:  22 r20:   5 r21:   3 r22: 104 r23:  64 
r24:  44 r25:  28 r26: 163 r27:  80 r28:  15 r29:   5 r30: 384 r31: 126 
x  :  30 y  : 183 z  :  13 
Registers used: 25 out of 35 (71.4%)

ATmega128 instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  20 add   :  24 
adiw  :  19 and   :   1 andi  :  21 asr   :   0 bclr  :   0 bld   :   1 
brbc  :   0 brbs  :   0 brcc  :   0 brcs  :   0 break :   0 breq  :  31 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :   8 
brlt  :   0 brmi  :   0 brne  :  35 brpl  :   0 brsh  :  14 brtc  :   1 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   1 call  : 152 
cbi   :  10 cbr   :   0 clc   :   0 clh   :   0 cli   :   2 cln   :   0 
clr   :  12 cls   :   0 clt   :   1 clv   :   0 clz   :   0 com   :   3 
cp    :   5 cpc   :  25 cpi   :  39 cpse  :   0 dec   :   4 des   :   0 
elpm  :  10 eor   :   1 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   1 
ijmp  :   0 in    :   6 inc   :   2 jmp   :  49 ld    :  24 ldd   :  99 
ldi   : 217 lds   :  96 lpm   :   0 lsl   :   4 lsr   :   1 mov   :  36 
movw  :  35 mul   :  19 muls  :   0 mulsu :   0 neg   :   2 nop   :   0 
or    :  11 ori   :   2 out   :  21 pop   :   4 push  :   4 rcall :  45 
ret   :  65 reti  :   0 rjmp  :  55 rol   :   8 ror   :   3 sbc   :   1 
sbci  :  36 sbi   :   5 sbic  :   1 sbis  :   1 sbiw  :  11 sbr   :   0 
sbrc  :   0 sbrs  :   2 sec   :   0 seh   :   0 sei   :   1 sen   :   0 
ser   :   0 ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 
spm   :  18 st    :  74 std   :  19 sts   :  70 sub   :   0 subi  :  27 
swap  :   0 tst   :   3 wdr   :   1 
Instructions used: 64 out of 117 (54.7%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000ef2   3756     70   3826  131072   2.9%
[.dseg] 0x000100 0x000c44      0    836    836    4096  20.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 10 warnings
