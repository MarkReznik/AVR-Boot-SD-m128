
AVRASM ver. 2.1.30  D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm Sat Mar 14 21:21:03 2020

D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1100): warning: Register r4 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1101): warning: Register r5 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1102): warning: Register r6 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1103): warning: Register r7 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1104): warning: Register r9 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1105): warning: Register r8 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1106): warning: Register r11 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1107): warning: Register r12 already defined by the .DEF directive
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1108): warning: Register r13 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V3.12 Advanced
                 ;(C) Copyright 1998-2014 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Build configuration    : Debug
                 ;Chip type              : ATmega128
                 ;Program type           : Boot Loader
                 ;Clock frequency        : 8.000000 MHz
                 ;Memory model           : Medium
                 ;Optimize for           : Size
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External RAM size      : 0
                 ;Data Stack size        : 1024 byte(s)
                 ;Heap size              : 0 byte(s)
                 ;Promote 'char' to 'int': Yes
                 ;'char' is unsigned     : Yes
                 ;8 bit enums            : Yes
                 ;Global 'const' stored in FLASH: Yes
                 ;Enhanced function parameter passing: Yes
                 ;Enhanced core instructions: On
                 ;Automatic register allocation for global variables: On
                 ;Smart register allocation: On
                 
                 	#define _MODEL_MEDIUM_
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	#define CALL_SUPPORTED 1
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0100
                 	.EQU __SRAM_END=0x10FF
                 	.EQU __DSTACK_SIZE=0x0400
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD2FN
                 	LDI  R26,LOW(2*@0+(@1))
                 	LDI  R27,HIGH(2*@0+(@1))
                 	LDI  R24,BYTE3(2*@0+(@1))
                 	LDI  R25,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __GETBRPF
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETBRPF_INC
                 	OUT  RAMPZ,R22
                 	ELPM R@0,Z+
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	PUSH R26
                 	PUSH R27
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	CALL __EEPROMRDW
                 	POP  R27
                 	POP  R26
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EX
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	CALL __EEPROMRDD
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R30,SPL
                 	IN   R31,SPH
                 	ADIW R30,@0+1
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test=R4
                 	.DEF ___AddrToZ24ByteToSPMCR_SPM_W_Test_msb=R5
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test=R6
                 	.DEF ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test_msb=R7
                 	.DEF _token=R9
                 	.DEF _SectorsPerCluster=R8
                 	.DEF _pagesCnt=R11
                 	.DEF _appPages=R12
                 	.DEF _appPages_msb=R13
                 
                 	.CSEG
                 	.ORG 0x00
000000 940c f800 	JMP  0xF800
                 
                 	.ORG 0xF800
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
00f800 940c f860 	JMP  __RESET
00f802 940c f800 	JMP  0xF800
00f804 940c f800 	JMP  0xF800
00f806 940c f800 	JMP  0xF800
00f808 940c f800 	JMP  0xF800
00f80a 940c f800 	JMP  0xF800
00f80c 940c f800 	JMP  0xF800
00f80e 940c f800 	JMP  0xF800
00f810 940c f800 	JMP  0xF800
00f812 940c f800 	JMP  0xF800
00f814 940c f800 	JMP  0xF800
00f816 940c f800 	JMP  0xF800
00f818 940c f800 	JMP  0xF800
00f81a 940c f800 	JMP  0xF800
00f81c 940c f800 	JMP  0xF800
00f81e 940c f800 	JMP  0xF800
00f820 940c f800 	JMP  0xF800
00f822 940c f800 	JMP  0xF800
00f824 940c f800 	JMP  0xF800
00f826 940c f800 	JMP  0xF800
00f828 940c f800 	JMP  0xF800
00f82a 940c f800 	JMP  0xF800
00f82c 940c f800 	JMP  0xF800
00f82e 940c f800 	JMP  0xF800
00f830 940c f800 	JMP  0xF800
00f832 940c f800 	JMP  0xF800
00f834 940c f800 	JMP  0xF800
00f836 940c f800 	JMP  0xF800
00f838 940c f800 	JMP  0xF800
00f83a 940c f800 	JMP  0xF800
00f83c 940c f800 	JMP  0xF800
00f83e 940c f800 	JMP  0xF800
00f840 940c f800 	JMP  0xF800
00f842 940c f800 	JMP  0xF800
00f844 940c f800 	JMP  0xF800
                 
                 ;GLOBAL REGISTER VARIABLES INITIALIZATION
                 __REG_VARS:
00f846 f9e0
00f847 f9b4      	.DB  0xE0,0xF9,0xB4,0xF9
                 
                 _0x40000:
00f848 2030
00f849 2020
00f84a 2020
00f84b 2020      	.DB  0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20
00f84c 2020
00f84d 0020
00f84e 4c46
00f84f 5341      	.DB  0x20,0x20,0x20,0x0,0x46,0x4C,0x41,0x53
00f850 2048
00f851 2020
D:\MyProjects\My_AVR_Programmer\AVRbootSD\AVR106 AppBoot\AVR106 BootSD\Debug\List\Self_programming.asm(1163): warning: .cseg .db misalignment - padding zero byte
00f852 0000      	.DB  0x48,0x20,0x20,0x20,0x0
                 
                 __GLOBAL_INI_TBL:
00f853 0004      	.DW  0x04
00f854 0004      	.DW  0x04
00f855 f08c 0001 	.DD  __REG_VARS*2
                 
00f857 000c      	.DW  0x0C
00f858 0500      	.DW  _0x4000E
00f859 f090 0001 	.DD  _0x40000*2
                 
00f85b 0009      	.DW  0x09
00f85c 050c      	.DW  _0x4000E+12
00f85d f09c 0001 	.DD  _0x40000*2+12
                 
                 _0xFFFFFFFF:
00f85f 0000      	.DW  0
                 
                 #define __GLOBAL_INI_TBL_PRESENT 1
                 
                 __RESET:
00f860 94f8      	CLI
00f861 27ee      	CLR  R30
00f862 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF THE BOOT LOADER
00f863 e0f1      	LDI  R31,1
00f864 bff5      	OUT  MCUCR,R31
00f865 e0f2      	LDI  R31,2
00f866 bff5      	OUT  MCUCR,R31
00f867 93e0 006c 	STS  XMCRB,R30
                 
                 ;CLEAR R2-R14
00f869 e08d      	LDI  R24,(14-2)+1
00f86a e0a2      	LDI  R26,2
00f86b 27bb      	CLR  R27
                 __CLEAR_REG:
00f86c 93ed      	ST   X+,R30
00f86d 958a      	DEC  R24
00f86e f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
00f86f e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
00f870 e190      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
00f871 e0a0      	LDI  R26,LOW(__SRAM_START)
00f872 e0b1      	LDI  R27,HIGH(__SRAM_START)
                 __CLEAR_SRAM:
00f873 93ed      	ST   X+,R30
00f874 9701      	SBIW R24,1
00f875 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
00f876 eae6      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
00f877 eff0      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
00f878 e0d1      	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00f879 bfdb      	OUT  RAMPZ,R29
00f87a 9187      	ELPM R24,Z+
00f87b 9197      	ELPM R25,Z+
00f87c 9700      	SBIW R24,0
00f87d f081      	BREQ __GLOBAL_INI_END
00f87e 91a7      	ELPM R26,Z+
00f87f 91b7      	ELPM R27,Z+
00f880 9007      	ELPM R0,Z+
00f881 9017      	ELPM R1,Z+
00f882 91c7      	ELPM R28,Z+
00f883 91d7      	ELPM R29,Z+
00f884 01bf      	MOVW R22,R30
00f885 b7db      	IN   R29,RAMPZ
00f886 01f0      	MOVW R30,R0
00f887 bfcb      	OUT  RAMPZ,R28
                 __GLOBAL_INI_LOOP:
00f888 9007      	ELPM R0,Z+
00f889 920d      	ST   X+,R0
00f88a 9701      	SBIW R24,1
00f88b f7e1      	BRNE __GLOBAL_INI_LOOP
00f88c 01fb      	MOVW R30,R22
00f88d cfeb      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
00f88e efef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
00f88f bfed      	OUT  SPL,R30
00f890 e1e0      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
00f891 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00f892 e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00f893 e0d5      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00f894 940c f9e6 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x500
                 
                 	.CSEG
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : All devices with bootloaders support.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains functions for easy reading and writing
                 ;*                       of Flash memory on parts having the "Self-programming"
                 ;*                       feature. The user functions are as follows:
                 ;*
                 ;*                       ReadFlashByte()
                 ;*                       ReadFlashPage()
                 ;*                       WriteFlashByte()
                 ;*                       WriteFlashPage()
                 ;*                       RecoverFlash()
                 ;*
                 ;*                       The remaining functions contained in this file are used
                 ;*                       by the functions listet above.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;//#include <inavr.h>
                 ;#include "Self_programming.h"
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include <delay.h>
                 ;
                 ;
                 ;void (*__AddrToZ24ByteToSPMCR_SPM_W_Test)(void flash *addr)= (void(*)(void flash *)) 0x0F9E0;
                 ;void (*__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F_Test)(void flash *addr, unsigned int data)= (void(*)(void flash *, unsigne ...
                 ;
                 ;
                 ;/*!
                 ;* Declare global struct variable in EEPROM if Flash recovery enabled.
                 ;* FlashBackup pageNumber holds Flash pageaddress (/PAGESIZE) the data in Flash
                 ;* recovery buffer should be written to if data need to be recovered.
                 ;* FlashBackup.status tells if data need to be recovered.
                 ;**/
                 ;#ifdef __FLASH_RECOVER
                 ;__eeprom struct {
                 ;  unsigned int  pageNumber;
                 ;  unsigned char status;
                 ;}FlashBackup = {0};
                 ;#endif
                 ;
                 ;void MY_FILL_TEMP_WORD(unsigned long addr,unsigned int data)
                 ; 0000 003A {
                 
                 	.CSEG
                 ; 0000 003B      _FILL_TEMP_WORD(addr,data);
                 ;	addr -> Y+2
                 ;	data -> Y+0
                 ; 0000 003C }
                 ;void MY_PAGE_ERASE(unsigned long addr)
                 ; 0000 003E {
                 ; 0000 003F      _PAGE_ERASE(addr);
                 ;	addr -> Y+0
                 ; 0000 0040 }
                 ;void MY_PAGE_WRITE(unsigned long addr)
                 ; 0000 0042 {
                 ; 0000 0043      _PAGE_WRITE(addr);
                 ;	addr -> Y+0
                 ; 0000 0044 }
                 ;/*!
                 ;* The function Returns one byte located on Flash address given by ucFlashStartAdr.
                 ;**/
                 ;unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 ; 0000 0048 unsigned char ReadFlashByte(MyAddressType flashStartAdr){
                 _ReadFlashByte:
                 ; .FSTART _ReadFlashByte
                 ; 0000 0049 //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 004A   return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
00f896 940e fefe 	CALL __PUTPARD2
                 ;	flashStartAdr -> Y+0
00f898 940e fd50 	CALL SUBOPT_0x0
                +
00f89a bf6b     +OUT RAMPZ , R22
00f89b 91e6     +ELPM R30 , Z
                 	__GETBRPF 30
00f89c 940c fc5d 	JMP  _0x2000009
                 ; 0000 004B //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 004C } // Returns data from Flash
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads one Flash page from address flashStartAdr and stores data
                 ;* in array dataPage[]. The number of bytes stored is depending upon the
                 ;* Flash page size. The function returns FALSE if input address is not a Flash
                 ;* page address, else TRUE.
                 ;**/
                 ;unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 ; 0000 0054 unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage){
                 _ReadFlashPage:
                 ; .FSTART _ReadFlashPage
                 ; 0000 0055   unsigned int index;
                 ; 0000 0056   if(!(flashStartAdr & (PAGESIZE-1))){      // If input address is a page address
00f89e 93ba      	ST   -Y,R27
00f89f 93aa      	ST   -Y,R26
00f8a0 931a      	ST   -Y,R17
00f8a1 930a      	ST   -Y,R16
                 ;	flashStartAdr -> Y+4
                 ;	*dataPage -> Y+2
                 ;	index -> R16,R17
                +
00f8a2 81ec     +LDD R30 , Y + 4
00f8a3 81fd     +LDD R31 , Y + 4 + 1
00f8a4 816e     +LDD R22 , Y + 4 + 2
00f8a5 817f     +LDD R23 , Y + 4 + 3
                 	__GETD1S 4
00f8a6 30e0      	CPI  R30,0
00f8a7 f501      	BRNE _0x3
                 ; 0000 0057     for(index = 0; index < PAGESIZE; index++){
                +
00f8a8 e000     +LDI R16 , LOW ( 0 )
00f8a9 e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x5:
                +
00f8aa 3000     +CPI R16 , LOW ( 256 )
00f8ab e0e1     +LDI R30 , HIGH ( 256 )
00f8ac 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
00f8ad f4b8      	BRSH _0x6
                 ; 0000 0058       dataPage[index] = ReadFlashByte(flashStartAdr + index);
00f8ae 01f8      	MOVW R30,R16
00f8af 81aa      	LDD  R26,Y+2
00f8b0 81bb      	LDD  R27,Y+2+1
00f8b1 0fea      	ADD  R30,R26
00f8b2 1ffb      	ADC  R31,R27
00f8b3 93ff      	PUSH R31
00f8b4 93ef      	PUSH R30
00f8b5 01f8      	MOVW R30,R16
                +
00f8b6 81ac     +LDD R26 , Y + 4
00f8b7 81bd     +LDD R27 , Y + 4 + 1
00f8b8 818e     +LDD R24 , Y + 4 + 2
00f8b9 819f     +LDD R25 , Y + 4 + 3
                 	__GETD2S 4
00f8ba 2766      	CLR  R22
00f8bb 2777      	CLR  R23
00f8bc 940e fe65 	CALL __ADDD21
00f8be dfd7      	RCALL _ReadFlashByte
00f8bf 91af      	POP  R26
00f8c0 91bf      	POP  R27
00f8c1 93ec      	ST   X,R30
                 ; 0000 0059     }
                +
00f8c2 5f0f     +SUBI R16 , LOW ( - 1 )
00f8c3 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00f8c4 cfe5      	RJMP _0x5
                 _0x6:
                 ; 0000 005A     return TRUE;                            // Return TRUE if valid page address
00f8c5 e0e1      	LDI  R30,LOW(1)
00f8c6 940c fc47 	JMP  _0x200000A
                 ; 0000 005B   }
                 ; 0000 005C   else{
                 _0x3:
                 ; 0000 005D     return FALSE;                           // Return FALSE if not valid page address
00f8c8 e0e0      	LDI  R30,LOW(0)
00f8c9 940c fc47 	JMP  _0x200000A
                 ; 0000 005E   }
                 ; 0000 005F }
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function writes byte data to Flash address flashAddr. Returns FALSE if
                 ;* input address is not valid Flash byte address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0065 unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data){
                 ; 0000 0066   MyAddressType  pageAdr;
                 ; 0000 0067   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 0068   if( AddressCheck( flashAddr & ~(PAGESIZE-1) )){
                 ;	flashAddr -> Y+7
                 ;	data -> Y+6
                 ;	pageAdr -> Y+2
                 ;	eepromInterruptSettings -> R17
                 ;	sregSettings -> R16
                 ; 0000 0069 
                 ; 0000 006A     eepromInterruptSettings= EECR & (1<<EERIE); // Stores EEPROM interrupt mask
                 ; 0000 006B     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
                 ; 0000 006C     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 ; 0000 006D 
                 ; 0000 006E     sregSettings= SREG;
                 ; 0000 006F     #asm("cli");
                 ; 0000 0070     pageAdr=flashAddr & ~(PAGESIZE-1);      // Gets Flash page address from byte address
                 ; 0000 0071 
                 ; 0000 0072     #ifdef __FLASH_RECOVER
                 ; 0000 0073     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 0074                                             // not contain data for writing
                 ; 0000 0075     while(EECR & (1<<EEWE));
                 ; 0000 0076     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0077     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 0078     FlashBackup.pageNumber = (unsigned int) (pageAdr/PAGESIZE); // Stores page address
                 ; 0000 0079                                                        // data should be written to
                 ; 0000 007A     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 007B                                                // contains unwritten data
                 ; 0000 007C     while(EECR & (1<<EEWE));
                 ; 0000 007D     #endif
                 ; 0000 007E 
                 ; 0000 007F     LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
                 ; 0000 0080 
                 ; 0000 0081 
                 ; 0000 0082     WriteBufToFlash(pageAdr);               // Writes to Flash
                 ; 0000 0083 
                 ; 0000 0084     #ifdef __FLASH_RECOVER
                 ; 0000 0085     FlashBackup.status = 0;                 // Indicates that Flash recovery buffer
                 ; 0000 0086                                             // does not contain unwritten data
                 ; 0000 0087     while(EECR & (1<<EEWE));
                 ; 0000 0088     #endif
                 ; 0000 0089 
                 ; 0000 008A     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
                 ; 0000 008B     SREG = sregSettings;
                 ; 0000 008C     return TRUE;                            // Return TRUE if address
                 ; 0000 008D                                             // valid for writing
                 ; 0000 008E   }
                 ; 0000 008F   else
                 ; 0000 0090     return FALSE;                           // Return FALSE if address not
                 ; 0000 0091                                             // valid for writing
                 ; 0000 0092 }
                 ;
                 ;/*!
                 ;* The function writes data from array dataPage[] to Flash page address
                 ;* flashStartAdr. The Number of bytes written is depending upon the Flash page
                 ;* size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
                 ;* page address for writing, else TRUE.
                 ;**/
                 ;unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage)
                 ; 0000 009B {
                 _WriteFlashPage:
                 ; .FSTART _WriteFlashPage
                 ; 0000 009C   unsigned int index;
                 ; 0000 009D   unsigned char eepromInterruptSettings,sregSettings;
                 ; 0000 009E   if( AddressCheck(flashStartAdr) ){
00f8cb 93ba      	ST   -Y,R27
00f8cc 93aa      	ST   -Y,R26
00f8cd 940e ff0e 	CALL __SAVELOCR4
                 ;	flashStartAdr -> Y+6
                 ;	*dataPage -> Y+4
                 ;	index -> R16,R17
                 ;	eepromInterruptSettings -> R19
                 ;	sregSettings -> R18
                +
00f8cf 81ae     +LDD R26 , Y + 6
00f8d0 81bf     +LDD R27 , Y + 6 + 1
00f8d1 8588     +LDD R24 , Y + 6 + 2
00f8d2 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
00f8d3 d058      	RCALL _AddressCheck
00f8d4 30e0      	CPI  R30,0
00f8d5 f409      	BRNE PC+2
00f8d6 c050      	RJMP _0xD
                 ; 0000 009F     eepromInterruptSettings = EECR & (1<<EERIE); // Stoes EEPROM interrupt mask
00f8d7 b3ec      	IN   R30,0x1C
00f8d8 70e8      	ANDI R30,LOW(0x8)
00f8d9 2f3e      	MOV  R19,R30
                 ; 0000 00A0     EECR &= ~(1<<EERIE);                    // Disable EEPROM interrupt
00f8da 98e3      	CBI  0x1C,3
                 ; 0000 00A1     while(EECR & (1<<EEWE));                // Wait if ongoing EEPROM write
                 _0xE:
00f8db 99e1      	SBIC 0x1C,1
00f8dc cffe      	RJMP _0xE
                 ; 0000 00A2 
                 ; 0000 00A3     sregSettings= SREG;
00f8dd b72f      	IN   R18,63
                 ; 0000 00A4     #asm("cli");
00f8de 94f8      	cli
                 ; 0000 00A5 
                 ; 0000 00A6     #ifdef __FLASH_RECOVER
                 ; 0000 00A7     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00A8                                             // not contain data for writing
                 ; 0000 00A9     while(EECR & (1<<EEWE));
                 ; 0000 00AA 
                 ; 0000 00AB     //_ENABLE_RWW_SECTION();
                 ; 0000 00AC 
                 ; 0000 00AD     _WAIT_FOR_SPM();
                 ; 0000 00AE     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00AF 
                 ; 0000 00B0     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                 ; 0000 00B1       //_WAIT_FOR_SPM();
                 ; 0000 00B2       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B3       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00B4     }
                 ; 0000 00B5 
                 ; 0000 00B6     WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
                 ; 0000 00B7     FlashBackup.pageNumber=(unsigned int)(flashStartAdr/PAGESIZE);
                 ; 0000 00B8     FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
                 ; 0000 00B9                                            // contains unwritten data
                 ; 0000 00BA     while(EECR & (1<<EEWE));
                 ; 0000 00BB     #endif
                 ; 0000 00BC 
                 ; 0000 00BD     if(index==0xFFF1)
00f8df efe1      	LDI  R30,LOW(65521)
00f8e0 efff      	LDI  R31,HIGH(65521)
00f8e1 17e0      	CP   R30,R16
00f8e2 07f1      	CPC  R31,R17
00f8e3 f491      	BRNE _0x11
                 ; 0000 00BE     {
                 ; 0000 00BF         __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
00f8e4 940e fd53 	CALL SUBOPT_0x1
00f8e6 e0a0      	LDI  R26,LOW(0)
00f8e7 e0b0      	LDI  R27,0
00f8e8 940e f9ac 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00C0         __AddrToZ24ByteToSPMCR_SPM_W((void flash *)0x1EF00);
00f8ea 940e fd5a 	CALL SUBOPT_0x2
00f8ec 940e f9bc 	CALL ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0000 00C1         __AddrToZ24ByteToSPMCR_SPM_E((void flash *)0x1EF00);
00f8ee 940e fd5a 	CALL SUBOPT_0x2
00f8f0 940e f9ca 	CALL ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0000 00C2         __AddrToZ24ByteToSPMCR_SPM_EW((void flash *)0x1EF00);
00f8f2 940e fd5a 	CALL SUBOPT_0x2
00f8f4 940e f9d8 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 00C3     }
                 ; 0000 00C4     _WAIT_FOR_SPM();
                 _0x11:
                 _0x12:
00f8f6 91e0 0068 	LDS  R30,104
00f8f8 70e1      	ANDI R30,LOW(0x1)
00f8f9 f7e1      	BRNE _0x12
                 ; 0000 00C5     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 00C6     //_ENABLE_RWW_SECTION();
                 ; 0000 00C7 
                 ; 0000 00C8     for(index = 0; index < PAGESIZE; index+=2){ // Fills Flash write buffer
                +
00f8fa e000     +LDI R16 , LOW ( 0 )
00f8fb e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x16:
                +
00f8fc 3000     +CPI R16 , LOW ( 256 )
00f8fd e0e1     +LDI R30 , HIGH ( 256 )
00f8fe 071e     +CPC R17 , R30
                 	__CPWRN 16,17,256
00f8ff f4e0      	BRSH _0x17
                 ; 0000 00C9       //_WAIT_FOR_SPM();
                 ; 0000 00CA       //MY_FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
                 ; 0000 00CB       _FILL_TEMP_WORD(index, (unsigned int)dataPage[index]+((unsigned int)dataPage[index+1] << 8));
00f900 01f8      	MOVW R30,R16
00f901 2766      	CLR  R22
00f902 2777      	CLR  R23
00f903 940e fef9 	CALL __PUTPARD1
00f905 01f8      	MOVW R30,R16
00f906 85a8      	LDD  R26,Y+8
00f907 85b9      	LDD  R27,Y+8+1
00f908 0fae      	ADD  R26,R30
00f909 1fbf      	ADC  R27,R31
00f90a 900c      	LD   R0,X
00f90b 2411      	CLR  R1
00f90c 9631      	ADIW R30,1
00f90d 85a8      	LDD  R26,Y+8
00f90e 85b9      	LDD  R27,Y+8+1
00f90f 0fae      	ADD  R26,R30
00f910 1fbf      	ADC  R27,R31
00f911 91ec      	LD   R30,X
00f912 2ffe      	MOV  R31,R30
00f913 e0e0      	LDI  R30,0
00f914 01d0      	MOVW R26,R0
00f915 0fae      	ADD  R26,R30
00f916 1fbf      	ADC  R27,R31
00f917 940e f9ac 	CALL ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0000 00CC     }
                +
00f919 5f0e     +SUBI R16 , LOW ( - 2 )
00f91a 4f1f     +SBCI R17 , HIGH ( - 2 )
                 	__ADDWRN 16,17,2
00f91b cfe0      	RJMP _0x16
                 _0x17:
                 ; 0000 00CD     //_PAGE_WRITE( flashStartAdr );
                 ; 0000 00CE     WriteBufToFlash(flashStartAdr);         // Writes to Flash
                +
00f91c 81ae     +LDD R26 , Y + 6
00f91d 81bf     +LDD R27 , Y + 6 + 1
00f91e 8588     +LDD R24 , Y + 6 + 2
00f91f 8599     +LDD R25 , Y + 6 + 3
                 	__GETD2S 6
00f920 d025      	RCALL _WriteBufToFlash
                 ; 0000 00CF     #ifdef __FLASH_RECOVER
                 ; 0000 00D0       FlashBackup.status=0;                 // Inicate that Flash buffer does
                 ; 0000 00D1                                             // not contain data for writing
                 ; 0000 00D2       while(EECR & (1<<EEWE));
                 ; 0000 00D3     #endif
                 ; 0000 00D4 
                 ; 0000 00D5     EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
00f921 b3ec      	IN   R30,0x1C
00f922 2be3      	OR   R30,R19
00f923 bbec      	OUT  0x1C,R30
                 ; 0000 00D6     SREG = sregSettings;
00f924 bf2f      	OUT  0x3F,R18
                 ; 0000 00D7     return TRUE;                            // Return TRUE if address
00f925 e0e1      	LDI  R30,LOW(1)
00f926 c001      	RJMP _0x200000B
                 ; 0000 00D8                                             // valid for writing
                 ; 0000 00D9   }
                 ; 0000 00DA   else
                 _0xD:
                 ; 0000 00DB     return FALSE;                           // Return FALSE if not address not
00f927 e0e0      	LDI  R30,LOW(0)
                 ; 0000 00DC                                             // valid for writing
                 ; 0000 00DD }
                 _0x200000B:
00f928 940e ff15 	CALL __LOADLOCR4
00f92a 962a      	ADIW R28,10
00f92b 9508      	RET
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function checks if global variable FlashBackup.status indicates that Flash recovery
                 ;* buffer contains data that needs to be written to Flash. Writes data from
                 ;* Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
                 ;* This function should be called at program startup if FLASH recovery option
                 ;* is enabeled.
                 ;**/
                 ;unsigned char RecoverFlash(){
                 ; 0000 00E6 unsigned char RecoverFlash(){
                 ; 0000 00E7 #ifdef __FLASH_RECOVER
                 ; 0000 00E8   unsigned int index;
                 ; 0000 00E9   unsigned long flashStartAdr = (MyAddressType)FlashBackup.pageNumber * PAGESIZE;
                 ; 0000 00EA   if(FlashBackup.status == FLASH_BUFFER_FULL_ID){ // Checks if Flash recovery
                 ; 0000 00EB                                                   //  buffer contains data
                 ; 0000 00EC 
                 ; 0000 00ED     for(index=0; index < PAGESIZE; index+=2){     // Writes to Flash write buffer
                 ; 0000 00EE         _WAIT_FOR_SPM();
                 ; 0000 00EF         MY_FILL_TEMP_WORD( index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER+index)) );
                 ; 0000 00F0     }
                 ; 0000 00F1 
                 ; 0000 00F2 
                 ; 0000 00F3     //WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
                 ; 0000 00F4     _WAIT_FOR_SPM();
                 ; 0000 00F5     MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 00F6     _WAIT_FOR_SPM();
                 ; 0000 00F7     MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 00F8     _WAIT_FOR_SPM();
                 ; 0000 00F9     _ENABLE_RWW_SECTION();
                 ; 0000 00FA     FlashBackup.status=0;                   // Inicate that Flash buffer does
                 ; 0000 00FB                                             // not contain data for writing
                 ; 0000 00FC     while(EECR & (1<<EEWE));
                 ; 0000 00FD     return TRUE;                            // Returns TRUE if recovery has
                 ; 0000 00FE                                             // taken place
                 ; 0000 00FF   }
                 ; 0000 0100 #endif
                 ; 0000 0101   return FALSE;
                 ; 0000 0102 }
                 ;
                 ;
                 ;/*!
                 ;* The function checks if input argument is a valid Flash page address for
                 ;* writing. Returns TRUE only if:
                 ;* - Address points to the beginning of a Flash page
                 ;* - Address is within the limits defined in Self_programming.h
                 ;* - Address is not equal to page address used for buffring by the Flash recovery
                 ;*   functions (if enabled).
                 ;* Returns FALSE else.
                 ;**/
                 ;unsigned char AddressCheck(MyAddressType flashAdr){
                 ; 0000 010E unsigned char AddressCheck(MyAddressType flashAdr){
                 _AddressCheck:
                 ; .FSTART _AddressCheck
                 ; 0000 010F   #ifdef __FLASH_RECOVER
                 ; 0000 0110   // The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
                 ; 0000 0111   if( (flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
                 ; 0000 0112       (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE-1)) )
                 ; 0000 0113     return TRUE;                            // Address is a valid page address
                 ; 0000 0114   else
                 ; 0000 0115     return FALSE;                           // Address is not a valid page address
                 ; 0000 0116   #else
                 ; 0000 0117   if((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE-1) ) )
00f92c 940e fd5f 	CALL SUBOPT_0x3
                 ;	flashAdr -> Y+0
00f92e 940e ff03 	CALL __CPD20
00f930 f070      	BRLO _0x1A
00f931 940e fd64 	CALL SUBOPT_0x4
                +
00f933 30a0     +CPI R26 , LOW ( 0x1F000 )
00f934 efe0     +LDI R30 , HIGH ( 0x1F000 )
00f935 07be     +CPC R27 , R30
00f936 e0e1     +LDI R30 , BYTE3 ( 0x1F000 )
00f937 078e     +CPC R24 , R30
00f938 e0e0     +LDI R30 , BYTE4 ( 0x1F000 )
00f939 079e     +CPC R25 , R30
                 	__CPD2N 0x1F000
00f93a f420      	BRSH _0x1A
00f93b 940e fd50 	CALL SUBOPT_0x0
00f93d 30e0      	CPI  R30,0
00f93e f009      	BREQ _0x1B
                 _0x1A:
00f93f c003      	RJMP _0x19
                 _0x1B:
                 ; 0000 0118     return TRUE;                            // Address is a valid page address
00f940 e0e1      	LDI  R30,LOW(1)
00f941 940c fc5d 	JMP  _0x2000009
                 ; 0000 0119   else
                 _0x19:
                 ; 0000 011A   {
                 ; 0000 011B     /*
                 ; 0000 011C     while(1)
                 ; 0000 011D     {
                 ; 0000 011E       PORTC.5=0;
                 ; 0000 011F       delay_ms(500);
                 ; 0000 0120       PORTC.5=1;
                 ; 0000 0121       delay_ms(500);
                 ; 0000 0122     }
                 ; 0000 0123     */
                 ; 0000 0124     return FALSE;                           // Address is not a valid page address
00f943 e0e0      	LDI  R30,LOW(0)
00f944 940c fc5d 	JMP  _0x2000009
                 ; 0000 0125   }
                 ; 0000 0126   #endif
                 ; 0000 0127 }
                 ; .FEND
                 ;
                 ;
                 ;/*!
                 ;* The function writes Flash temporary buffer to Flash page address given by
                 ;* input argument.
                 ;**/
                 ;
                 ;void WriteBufToFlash(MyAddressType flashStartAdr) {
                 ; 0000 012F void WriteBufToFlash(MyAddressType flashStartAdr) {
                 _WriteBufToFlash:
                 ; .FSTART _WriteBufToFlash
                 ; 0000 0130     //_WAIT_FOR_SPM();
                 ; 0000 0131     //MY_PAGE_ERASE( flashStartAdr );
                 ; 0000 0132     //_PAGE_ERASE( flashStartAdr );
                 ; 0000 0133     //_WAIT_FOR_SPM();
                 ; 0000 0134     //_ENABLE_RWW_SECTION();
                 ; 0000 0135     //MY_PAGE_WRITE( flashStartAdr );
                 ; 0000 0136     _PAGE_WRITE( flashStartAdr );
00f946 940e fd5f 	CALL SUBOPT_0x3
                 ;	flashStartAdr -> Y+0
00f948 940e f9d8 	CALL ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0000 0137     //_WAIT_FOR_SPM();
                 ; 0000 0138     //_ENABLE_RWW_SECTION();
                 ; 0000 0139 /*
                 ; 0000 013A #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 013B   #ifdef __HAS_RAMPZ__
                 ; 0000 013C   RAMPZ = (unsigned char)(flashStartAdr >> 16);
                 ; 0000 013D   #endif
                 ; 0000 013E   _PAGE_ERASE(flashStartAdr);
                 ; 0000 013F   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0140   _PAGE_WRITE(flashStartAdr);
                 ; 0000 0141   while( SPMControllRegister & (1<<SPMEN) ); // Wait until Flash write completed
                 ; 0000 0142   #ifdef RWWSRE
                 ; 0000 0143   __DataToR0ByteToSPMCR_SPM( 0, (unsigned char)(1<<RWWSRE)|(1<<SPMEN)); // Enable RWW
                 ; 0000 0144   #endif
                 ; 0000 0145 #pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0146 */
                 ; 0000 0147 }
00f94a 940c fc5d 	JMP  _0x2000009
                 ; .FEND
                 ;
                 ;/*!
                 ;* The function reads Flash page given by flashAddr, replaces one byte given by
                 ;* flashAddr with data, and stores entire page in Flash temporary buffer.
                 ;**/
                 ;void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014D void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data){
                 ; 0000 014E //#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
                 ; 0000 014F     unsigned int index, oddByte, pcWord;
                 ; 0000 0150 
                 ; 0000 0151     MyAddressType  pageAdr;
                 ; 0000 0152     oddByte=(unsigned char)flashAddr & 1;
                 ;	flashAddr -> Y+11
                 ;	data -> Y+10
                 ;	index -> R16,R17
                 ;	oddByte -> R18,R19
                 ;	pcWord -> R20,R21
                 ;	pageAdr -> Y+6
                 ; 0000 0153     pcWord=(unsigned int)flashAddr & (PAGESIZE-2); // Used when writing FLASH temp buffer
                 ; 0000 0154     pageAdr=flashAddr & ~(PAGESIZE-1);        // Get FLASH page address from byte address
                 ; 0000 0155     //while( SPMCR_REG & (1<<SPMEN) );
                 ; 0000 0156     //_ENABLE_RWW_SECTION();
                 ; 0000 0157 
                 ; 0000 0158     for(index=0; index < PAGESIZE; index+=2){
                 ; 0000 0159         if(index==pcWord){
                 ; 0000 015A           if(oddByte){
                 ; 0000 015B             //MY_FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015C             _FILL_TEMP_WORD( index, (*(MyFlashCharPointer)(flashAddr & ~1) | ((unsigned int)data<<8)) );
                 ; 0000 015D           }                                     // Write odd byte in temporary buffer
                 ; 0000 015E           else{
                 ; 0000 015F             //MY_FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0160             _FILL_TEMP_WORD( index, ( (*( (MyFlashCharPointer)flashAddr+1)<<8)  | data ) );
                 ; 0000 0161           }                                     // Write even byte in temporary buffer
                 ; 0000 0162         }
                 ; 0000 0163         else{
                 ; 0000 0164           //MY_FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0165           _FILL_TEMP_WORD(index, *( (MyFlashIntPointer)(pageAdr+index) ) );
                 ; 0000 0166         }                                       // Write Flash word directly to temporary buffer
                 ; 0000 0167     }
                 ; 0000 0168 //#pragma diag_default=Pe1053 // Back to default.
                 ; 0000 0169 }
                 ;/*****************************************************************************
                 ;*
                 ;* (C) 2010, HP InfoTech srl, www.hpinfotech.com
                 ;*
                 ;* File              : flash.c
                 ;* Compiler          : CodeVisionAVR V2.xx
                 ;* Revision          : $Revision: 1.0 $
                 ;* Date              : $Date: December 9, 2010 $
                 ;* Updated by        : $Author: HP InfoTech $
                 ;*
                 ;* Target platform   : All AVRs with bootloader support
                 ;*
                 ;* AppNote           : AVR109 - Self-programming
                 ;*
                 ;* Description       : Flash operations for AVR109 Self-programming
                 ;****************************************************************************/
                 ;
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;
                 ;//#define	SPMCR_REG	SPMCSR
                 ;
                 ;void dospmew(void)
                 ; 0001 0018 {
                 
                 	.CSEG
                 _dospmew:
                 ; .FSTART _dospmew
                 ; 0001 0019     #asm
                 ; 0001 001A          ldi   r22,$03
00f94c e063               ldi   r22,$03
                 ; 0001 001B          WR_SPMCR_REG_R22
00f94d 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 001C          spm
00f94f 95e8               spm
                 ; 0001 001D     #endasm
                 ; 0001 001E     _WAIT_FOR_SPM();
                 _0x20003:
00f950 91e0 0068 	LDS  R30,104
00f952 70e1      	ANDI R30,LOW(0x1)
00f953 f7e1      	BRNE _0x20003
                 ; 0001 001F     #asm
                 ; 0001 0020         ldi   r22,$05
00f954 e065              ldi   r22,$05
                 ; 0001 0021         WR_SPMCR_REG_R22
00f955 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0022         spm
00f957 95e8              spm
                 ; 0001 0023     #endasm
                 ; 0001 0024     _WAIT_FOR_SPM();
                 _0x20006:
00f958 91e0 0068 	LDS  R30,104
00f95a 70e1      	ANDI R30,LOW(0x1)
00f95b f7e1      	BRNE _0x20006
                 ; 0001 0025     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20009:
00f95c 91e0 0068 	LDS  R30,104
00f95e 74e0      	ANDI R30,LOW(0x40)
00f95f f049      	BREQ _0x2000B
                 ; 0001 0026     {
                 ; 0001 0027     #asm
                 ; 0001 0028         ldi   r22,$11
00f960 e161              ldi   r22,$11
                 ; 0001 0029         WR_SPMCR_REG_R22
00f961 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 002A         spm
00f963 95e8              spm
                 ; 0001 002B     #endasm
                 ; 0001 002C         _WAIT_FOR_SPM();
                 _0x2000C:
00f964 91e0 0068 	LDS  R30,104
00f966 70e1      	ANDI R30,LOW(0x1)
00f967 f7e1      	BRNE _0x2000C
                 ; 0001 002D     }
00f968 cff3      	RJMP _0x20009
                 _0x2000B:
                 ; 0001 002E }
00f969 9508      	RET
                 ; .FEND
                 ;
                 ;void dospmw(void)
                 ; 0001 0031 {
                 _dospmw:
                 ; .FSTART _dospmw
                 ; 0001 0032     #asm
                 ; 0001 0033         ldi   r22,$05
00f96a e065              ldi   r22,$05
                 ; 0001 0034         WR_SPMCR_REG_R22
00f96b 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0035         spm
00f96d 95e8              spm
                 ; 0001 0036     #endasm
                 ; 0001 0037     _WAIT_FOR_SPM();
                 _0x2000F:
00f96e 91e0 0068 	LDS  R30,104
00f970 70e1      	ANDI R30,LOW(0x1)
00f971 f7e1      	BRNE _0x2000F
                 ; 0001 0038     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20012:
00f972 91e0 0068 	LDS  R30,104
00f974 74e0      	ANDI R30,LOW(0x40)
00f975 f049      	BREQ _0x20014
                 ; 0001 0039     {
                 ; 0001 003A     #asm
                 ; 0001 003B         ldi   r22,$11
00f976 e161              ldi   r22,$11
                 ; 0001 003C         WR_SPMCR_REG_R22
00f977 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 003D         spm
00f979 95e8              spm
                 ; 0001 003E     #endasm
                 ; 0001 003F         _WAIT_FOR_SPM();
                 _0x20015:
00f97a 91e0 0068 	LDS  R30,104
00f97c 70e1      	ANDI R30,LOW(0x1)
00f97d f7e1      	BRNE _0x20015
                 ; 0001 0040     }
00f97e cff3      	RJMP _0x20012
                 _0x20014:
                 ; 0001 0041 }
00f97f 9508      	RET
                 ; .FEND
                 ;
                 ;void dospme(void)
                 ; 0001 0044 {
                 _dospme:
                 ; .FSTART _dospme
                 ; 0001 0045     #asm
                 ; 0001 0046         ldi   r22,$03
00f980 e063              ldi   r22,$03
                 ; 0001 0047         WR_SPMCR_REG_R22
00f981 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0048         spm
00f983 95e8              spm
                 ; 0001 0049     #endasm
                 ; 0001 004A     _WAIT_FOR_SPM();
                 _0x20018:
00f984 91e0 0068 	LDS  R30,104
00f986 70e1      	ANDI R30,LOW(0x1)
00f987 f7e1      	BRNE _0x20018
                 ; 0001 004B     while( SPMCR_REG & (1<<RWWSB) )
                 _0x2001B:
00f988 91e0 0068 	LDS  R30,104
00f98a 74e0      	ANDI R30,LOW(0x40)
00f98b f049      	BREQ _0x2001D
                 ; 0001 004C     {
                 ; 0001 004D     #asm
                 ; 0001 004E         ldi   r22,$11
00f98c e161              ldi   r22,$11
                 ; 0001 004F         WR_SPMCR_REG_R22
00f98d 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0050         spm
00f98f 95e8              spm
                 ; 0001 0051     #endasm
                 ; 0001 0052         _WAIT_FOR_SPM();
                 _0x2001E:
00f990 91e0 0068 	LDS  R30,104
00f992 70e1      	ANDI R30,LOW(0x1)
00f993 f7e1      	BRNE _0x2001E
                 ; 0001 0053     }
00f994 cff3      	RJMP _0x2001B
                 _0x2001D:
                 ; 0001 0054 }
00f995 9508      	RET
                 ; .FEND
                 ;
                 ;void dospm(void)
                 ; 0001 0057 {
                 _dospm:
                 ; .FSTART _dospm
                 ; 0001 0058     #asm
                 ; 0001 0059          ldi   r22,$01
00f996 e061               ldi   r22,$01
                 ; 0001 005A          WR_SPMCR_REG_R22
00f997 9360 0068          WR_SPMCR_REG_R22
                 ; 0001 005B          spm
00f999 95e8               spm
                 ; 0001 005C     #endasm
                 ; 0001 005D     _WAIT_FOR_SPM();
                 _0x20021:
00f99a 91e0 0068 	LDS  R30,104
00f99c 70e1      	ANDI R30,LOW(0x1)
00f99d f7e1      	BRNE _0x20021
                 ; 0001 005E     while( SPMCR_REG & (1<<RWWSB) )
                 _0x20024:
00f99e 91e0 0068 	LDS  R30,104
00f9a0 74e0      	ANDI R30,LOW(0x40)
00f9a1 f049      	BREQ _0x20026
                 ; 0001 005F     {
                 ; 0001 0060     #asm
                 ; 0001 0061         ldi   r22,$11
00f9a2 e161              ldi   r22,$11
                 ; 0001 0062         WR_SPMCR_REG_R22
00f9a3 9360 0068         WR_SPMCR_REG_R22
                 ; 0001 0063         spm
00f9a5 95e8              spm
                 ; 0001 0064     #endasm
                 ; 0001 0065         _WAIT_FOR_SPM();
                 _0x20027:
00f9a6 91e0 0068 	LDS  R30,104
00f9a8 70e1      	ANDI R30,LOW(0x1)
00f9a9 f7e1      	BRNE _0x20027
                 ; 0001 0066     }
00f9aa cff3      	RJMP _0x20024
                 _0x20026:
                 ; 0001 0067 }
00f9ab 9508      	RET
                 ; .FEND
                 ;
                 ;#pragma warn-
                 ;
                 ;unsigned char __AddrToZByteToSPMCR_LPM(void flash *addr, unsigned char ctrl)
                 ; 0001 006C {
                 ; 0001 006D #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 006E      ldd  r30,y+1
                 ; 0001 006F      ldd  r31,y+2
                 ; 0001 0070      ld   r22,y
                 ; 0001 0071      WR_SPMCR_REG_R22
                 ; 0001 0072      lpm
                 ; 0001 0073      mov  r30,r0
                 ; 0001 0074 #endasm
                 ; 0001 0075 }
                 ;
                 ;void __DataToR0ByteToSPMCR_SPM(unsigned char data, unsigned char ctrl)
                 ; 0001 0078 {
                 ; 0001 0079 #asm
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 007A      ldd  r0,y+1
                 ; 0001 007B      ld   r22,y
                 ; 0001 007C      WR_SPMCR_REG_R22
                 ; 0001 007D      spm
                 ; 0001 007E #endasm
                 ; 0001 007F }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 0082 {
                 ; 0001 0083     #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 0084          ldd  r30,y+3
                 ; 0001 0085          ldd  r31,y+4
                 ; 0001 0086          ldd  r0,y+1
                 ; 0001 0087          ldd  r1,y+2
                 ; 0001 0088          ld   r22,y
                 ; 0001 0089          WR_SPMCR_REG_R22
                 ; 0001 008A          spm
                 ; 0001 008B     #endasm
                 ; 0001 008C }
                 ;
                 ;void __AddrToZWordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 008F {
                 ; 0001 0090 _WAIT_FOR_SPM();
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 ; 0001 0091     #asm
                 ; 0001 0092          ldd  r30,y+2
                 ; 0001 0093          ldd  r31,y+3
                 ; 0001 0094          ldd  r0,y+0
                 ; 0001 0095          ldd  r1,y+1
                 ; 0001 0096          //ldi   r22,LOW(1)
                 ; 0001 0097          //WR_SPMCR_REG_R22
                 ; 0001 0098          //spm
                 ; 0001 0099     #endasm
                 ; 0001 009A dospm();
                 ; 0001 009B }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 009E {
                 ; 0001 009F #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00A0      ldd  r30,y+1
                 ; 0001 00A1      ldd  r31,y+2
                 ; 0001 00A2      ld   r22,y
                 ; 0001 00A3      WR_SPMCR_REG_R22
                 ; 0001 00A4      spm
                 ; 0001 00A5 #endasm
                 ; 0001 00A6 }
                 ;
                 ;void __AddrToZByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00A9 {
                 ; 0001 00AA _WAIT_FOR_SPM();
                 ;	*addr -> Y+0
                 ; 0001 00AB #asm
                 ; 0001 00AC      ldd  r30,y+0
                 ; 0001 00AD      ldd  r31,y+1
                 ; 0001 00AE      //ld   r22,y
                 ; 0001 00AF      //WR_SPMCR_REG_R22
                 ; 0001 00B0      //spm
                 ; 0001 00B1 #endasm
                 ; 0001 00B2 dospmew();
                 ; 0001 00B3 }
                 ;
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM(void flash *addr, unsigned int data, unsigned char ctrl)
                 ; 0001 00B7 {
                 ; 0001 00B8 #asm
                 ;	*addr -> Y+3
                 ;	data -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00B9      ldd  r30,y+3
                 ; 0001 00BA      ldd  r31,y+4
                 ; 0001 00BB      ldd  r22,y+5
                 ; 0001 00BC      out  rampz,r22
                 ; 0001 00BD      ldd  r0,y+1
                 ; 0001 00BE      ldd  r1,y+2
                 ; 0001 00BF      ld   r22,y
                 ; 0001 00C0      WR_SPMCR_REG_R22
                 ; 0001 00C1      spm
                 ; 0001 00C2 #endasm
                 ; 0001 00C3 }
                 ;
                 ;void __AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(void flash *addr, unsigned int data)
                 ; 0001 00C6 {
                 ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F:
                 ; .FSTART ___AddrToZ24WordToR1R0ByteToSPMCR_SPM_F
                 ; 0001 00C7 _WAIT_FOR_SPM();
00f9ac 93ba      	ST   -Y,R27
00f9ad 93aa      	ST   -Y,R26
                 ;	*addr -> Y+2
                 ;	data -> Y+0
                 _0x20030:
00f9ae 91e0 0068 	LDS  R30,104
00f9b0 70e1      	ANDI R30,LOW(0x1)
00f9b1 f7e1      	BRNE _0x20030
                 ; 0001 00C8 #asm
                 ; 0001 00C9      ldd  r30,y+2
00f9b2 81ea           ldd  r30,y+2
                 ; 0001 00CA      ldd  r31,y+3
00f9b3 81fb           ldd  r31,y+3
                 ; 0001 00CB      ldd  r22,y+4
00f9b4 816c           ldd  r22,y+4
                 ; 0001 00CC      out  rampz,r22
00f9b5 bf6b           out  rampz,r22
                 ; 0001 00CD      ldd  r0,y+0
00f9b6 8008           ldd  r0,y+0
                 ; 0001 00CE      ldd  r1,y+1
00f9b7 8019           ldd  r1,y+1
                 ; 0001 00CF      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00D0      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00D1      //spm
                      //spm
                 ; 0001 00D2 #endasm
                 ; 0001 00D3 dospm();
00f9b8 940e f996 	CALL _dospm
                 ; 0001 00D4 }
00f9ba 940c fcf1 	JMP  _0x2000003
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM(void flash *addr, unsigned char ctrl)
                 ; 0001 00D7 {
                 ; 0001 00D8 #asm
                 ;	*addr -> Y+1
                 ;	ctrl -> Y+0
                 ; 0001 00D9      ldd  r30,y+1
                 ; 0001 00DA      ldd  r31,y+2
                 ; 0001 00DB      ldd  r22,y+3
                 ; 0001 00DC      out  rampz,r22
                 ; 0001 00DD      ld   r22,y
                 ; 0001 00DE      WR_SPMCR_REG_R22
                 ; 0001 00DF      spm
                 ; 0001 00E0 #endasm
                 ; 0001 00E1 }
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_W(void flash *addr)
                 ; 0001 00E4 {
                 ___AddrToZ24ByteToSPMCR_SPM_W:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_W
                 ; 0001 00E5 _WAIT_FOR_SPM();
00f9bc 940e fefe 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20033:
00f9be 91e0 0068 	LDS  R30,104
00f9c0 70e1      	ANDI R30,LOW(0x1)
00f9c1 f7e1      	BRNE _0x20033
                 ; 0001 00E6 #asm
                 ; 0001 00E7      ldd  r30,y+0
00f9c2 81e8           ldd  r30,y+0
                 ; 0001 00E8      ldd  r31,y+1
00f9c3 81f9           ldd  r31,y+1
                 ; 0001 00E9      ldd  r22,y+2
00f9c4 816a           ldd  r22,y+2
                 ; 0001 00EA      out  rampz,r22
00f9c5 bf6b           out  rampz,r22
                 ; 0001 00EB      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00EC      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00ED      //spm
                      //spm
                 ; 0001 00EE #endasm
                 ; 0001 00EF dospmw();
00f9c6 940e f96a 	CALL _dospmw
                 ; 0001 00F0 }
00f9c8 940c fc5d 	JMP  _0x2000009
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_E(void flash *addr)
                 ; 0001 00F3 {
                 ___AddrToZ24ByteToSPMCR_SPM_E:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_E
                 ; 0001 00F4 _WAIT_FOR_SPM();
00f9ca 940e fefe 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20036:
00f9cc 91e0 0068 	LDS  R30,104
00f9ce 70e1      	ANDI R30,LOW(0x1)
00f9cf f7e1      	BRNE _0x20036
                 ; 0001 00F5 #asm
                 ; 0001 00F6      ldd  r30,y+0
00f9d0 81e8           ldd  r30,y+0
                 ; 0001 00F7      ldd  r31,y+1
00f9d1 81f9           ldd  r31,y+1
                 ; 0001 00F8      ldd  r22,y+2
00f9d2 816a           ldd  r22,y+2
                 ; 0001 00F9      out  rampz,r22
00f9d3 bf6b           out  rampz,r22
                 ; 0001 00FA      //ld   r22,y
                      //ld   r22,y
                 ; 0001 00FB      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 00FC      //spm
                      //spm
                 ; 0001 00FD #endasm
                 ; 0001 00FE dospme();
00f9d4 940e f980 	CALL _dospme
                 ; 0001 00FF }
00f9d6 940c fc5d 	JMP  _0x2000009
                 ; .FEND
                 ;
                 ;void __AddrToZ24ByteToSPMCR_SPM_EW(void flash *addr)
                 ; 0001 0102 {
                 ___AddrToZ24ByteToSPMCR_SPM_EW:
                 ; .FSTART ___AddrToZ24ByteToSPMCR_SPM_EW
                 ; 0001 0103 _WAIT_FOR_SPM();
00f9d8 940e fefe 	CALL __PUTPARD2
                 ;	*addr -> Y+0
                 _0x20039:
00f9da 91e0 0068 	LDS  R30,104
00f9dc 70e1      	ANDI R30,LOW(0x1)
00f9dd f7e1      	BRNE _0x20039
                 ; 0001 0104 #asm
                 ; 0001 0105      ldd  r30,y+0
00f9de 81e8           ldd  r30,y+0
                 ; 0001 0106      ldd  r31,y+1
00f9df 81f9           ldd  r31,y+1
                 ; 0001 0107      ldd  r22,y+2
00f9e0 816a           ldd  r22,y+2
                 ; 0001 0108      out  rampz,r22
00f9e1 bf6b           out  rampz,r22
                 ; 0001 0109      //ld   r22,y
                      //ld   r22,y
                 ; 0001 010A      //WR_SPMCR_REG_R22
                      //WR_SPMCR_REG_R22
                 ; 0001 010B      //spm
                      //spm
                 ; 0001 010C #endasm
                 ; 0001 010D dospmew();
00f9e2 940e f94c 	CALL _dospmew
                 ; 0001 010E }
00f9e4 940c fc5d 	JMP  _0x2000009
                 ; .FEND
                 ;
                 ;#ifdef _WARNINGS_ON_
                 ;#pragma warn+
                 ;#endif
                 ;
                 ;// This file has been prepared for Doxygen automatic documentation generation.
                 ;/*! \file ********************************************************************
                 ;*
                 ;* Atmel Corporation
                 ;*
                 ;* - File              : Self_programming_main.c
                 ;* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
                 ;*
                 ;* - Support mail      : avr@atmel.com
                 ;*
                 ;* - Supported devices : This example is written for ATmega128.
                 ;*
                 ;* - AppNote           : AVR106 - C functions for reading and writing
                 ;*                       to flash memory.
                 ;*
                 ;* - Description       : The file contains an example program using the Flash R/W
                 ;*                       functions provided with the files Self_programming.h /
                 ;*                       Self_programming.c . The program should be compiled using
                 ;*                       a linker file (*.xcl) that is configured to place the
                 ;*                       entire program code into the Boot section of the Flash memory.
                 ;*                       Please refer to the application note document for more
                 ;*                       information.
                 ;*
                 ;* $Revision: 2.0 $
                 ;* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
                 ;*
                 ;*****************************************************************************/
                 ;#include <io.h>
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "flash.h"
                      #define WR_SPMCR_REG_R22 sts 0x68,r22
                 ;#include "Self_programming.h"
                 ;
                 ;#include "spi_sdcard.h"
                 ;
                 ;#define SDBUF_SIZE  512
                 ;#define PAGES_PER_SDBUF (SDBUF_SIZE/PAGESIZE)
                 ;
                 ;unsigned char result[5], sdBuf[SDBUF_SIZE], testBuf[PAGESIZE], token, SectorsPerCluster, pagesCnt;
                 ;unsigned long appStartAdr,adr,SectorsPerFat,fat_begin_lba;
                 ;unsigned long cluster_begin_lba,root_dir_first_cluster,fat_file_adr,fat_file_next_adr,filesize,readbytes;
                 ;unsigned int appPages,bytesChecksum,checksumCnt;
                 ;//(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ;//(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FA ...
                 ;//(unsigned char)sectors_per_cluster = BPB_SecPerClus;
                 ;//(unsigned long)root_dir_first_cluster = BPB_RootClus;
                 ;void testWrite();
                 ;void errorSD();
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len);
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest);
                 ;void (*app_pointer)(void) = (void(*)(void))0x0000;
                 ;
                 ;void main( void ){
                 ; 0002 0034 void main( void ){
                 
                 	.CSEG
                 _main:
                 ; .FSTART _main
                 ; 0002 0035 
                 ; 0002 0036   unsigned int i,j;
                 ; 0002 0037 
                 ; 0002 0038   DDRC=0xFF;
                 ;	i -> R16,R17
                 ;	j -> R18,R19
00f9e6 efef      	LDI  R30,LOW(255)
00f9e7 bbe4      	OUT  0x14,R30
                 ; 0002 0039   PORTC=0xFF;
00f9e8 bbe5      	OUT  0x15,R30
                 ; 0002 003A   /*
                 ; 0002 003B     do
                 ; 0002 003C     {
                 ; 0002 003D       PORTC.6=0;
                 ; 0002 003E       delay_ms(500);
                 ; 0002 003F       PORTC.6=1;
                 ; 0002 0040       delay_ms(500);
                 ; 0002 0041     }while(1);
                 ; 0002 0042   */
                 ; 0002 0043   //init SD
                 ; 0002 0044   if((result[0]=SD_init())!=SD_SUCCESS)
00f9e9 d2cb      	RCALL _SD_init
00f9ea 93e0 0515 	STS  _result,R30
00f9ec 30e0      	CPI  R30,0
00f9ed f009      	BREQ _0x40003
                 ; 0002 0045     errorSD();
00f9ee d1f0      	RCALL _errorSD
                 ; 0002 0046 
                 ; 0002 0047   // read MBR get FAT start sector
                 ; 0002 0048   if((result[0]=SD_readSingleBlock(0, sdBuf, &token))!=SD_SUCCESS)
                 _0x40003:
00f9ef 940e fd53 	CALL SUBOPT_0x1
00f9f1 940e fd67 	CALL SUBOPT_0x5
00f9f3 f009      	BREQ _0x40004
                 ; 0002 0049     errorSD();
00f9f4 d1ea      	RCALL _errorSD
                 ; 0002 004A 
                 ; 0002 004B   adr=buf2num(&sdBuf[445+9],4);//FAT start sector. 1 sector = 512 bytes
                 _0x40004:
                +
00f9f5 eee0     +LDI R30 , LOW ( _sdBuf + ( 454 ) )
00f9f6 e0f6     +LDI R31 , HIGH ( _sdBuf + ( 454 ) )
                 	__POINTW1MN _sdBuf,454
00f9f7 940e fd72 	CALL SUBOPT_0x6
00f9f9 940e fd76 	CALL SUBOPT_0x7
                 ; 0002 004C 
                 ; 0002 004D   //load and read FAT ID (1st) sector. Get FAT info. Secors per Cluster and etc..
                 ; 0002 004E   if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
00f9fb 940e fd7f 	CALL SUBOPT_0x8
00f9fd 940e fd88 	CALL SUBOPT_0x9
00f9ff f009      	BREQ _0x40005
                 ; 0002 004F     errorSD();
00fa00 d1de      	RCALL _errorSD
                 ; 0002 0050 
                 ; 0002 0051   SectorsPerCluster=sdBuf[0x0D];// 8 sectors per cluster
                 _0x40005:
                +
00fa01 9080 0527+LDS R8 , _sdBuf + ( 13 )
                 	__GETBRMN 8,_sdBuf,13
                 ; 0002 0052   SectorsPerFat=buf2num(&sdBuf[0x24],4); // 0xF10 for test sdcard
                +
00fa03 e3ee     +LDI R30 , LOW ( _sdBuf + ( 36 ) )
00fa04 e0f5     +LDI R31 , HIGH ( _sdBuf + ( 36 ) )
                 	__POINTW1MN _sdBuf,36
00fa05 940e fd72 	CALL SUBOPT_0x6
00fa07 93e0 0822 	STS  _SectorsPerFat,R30
00fa09 93f0 0823 	STS  _SectorsPerFat+1,R31
00fa0b 9360 0824 	STS  _SectorsPerFat+2,R22
00fa0d 9370 0825 	STS  _SectorsPerFat+3,R23
                 ; 0002 0053 
                 ; 0002 0054   //read the FAT fils/directories info from Root Directory cluster (usually 2),Number_of_Reserved_Sectors (usually 0x20) ...
                 ; 0002 0055   //(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
                 ; 0002 0056   fat_begin_lba=adr+0x20;//first sector of FAT data
00fa0f 940e fd7f 	CALL SUBOPT_0x8
                +
00fa11 5ee0     +SUBI R30 , LOW ( - 32 )
00fa12 4fff     +SBCI R31 , HIGH ( - 32 )
00fa13 4f6f     +SBCI R22 , BYTE3 ( - 32 )
00fa14 4f7f     +SBCI R23 , BYTE4 ( - 32 )
                 	__ADDD1N 32
00fa15 93e0 0826 	STS  _fat_begin_lba,R30
00fa17 93f0 0827 	STS  _fat_begin_lba+1,R31
00fa19 9360 0828 	STS  _fat_begin_lba+2,R22
00fa1b 9370 0829 	STS  _fat_begin_lba+3,R23
                 ; 0002 0057   //(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_ ...
                 ; 0002 0058   //Number_of_FATs always 2. Offset 0x10 8bit
                 ; 0002 0059   cluster_begin_lba=fat_begin_lba+(2*SectorsPerFat);//number of sector where data begin
00fa1d 91e0 0822 	LDS  R30,_SectorsPerFat
00fa1f 91f0 0823 	LDS  R31,_SectorsPerFat+1
00fa21 9160 0824 	LDS  R22,_SectorsPerFat+2
00fa23 9170 0825 	LDS  R23,_SectorsPerFat+3
00fa25 940e fe8b 	CALL __LSLD1
00fa27 91a0 0826 	LDS  R26,_fat_begin_lba
00fa29 91b0 0827 	LDS  R27,_fat_begin_lba+1
00fa2b 9180 0828 	LDS  R24,_fat_begin_lba+2
00fa2d 9190 0829 	LDS  R25,_fat_begin_lba+3
00fa2f 940e fe60 	CALL __ADDD12
00fa31 93e0 082a 	STS  _cluster_begin_lba,R30
00fa33 93f0 082b 	STS  _cluster_begin_lba+1,R31
00fa35 9360 082c 	STS  _cluster_begin_lba+2,R22
00fa37 9370 082d 	STS  _cluster_begin_lba+3,R23
                 ; 0002 005A   //read root dir (sector 2 but always offset 2 too then 0) to find folder 0 FAT reference. and find Flash.dat sector
                 ; 0002 005B   //lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
                 ; 0002 005C   adr=cluster_begin_lba +(2-2)*SectorsPerCluster;
00fa39 d33c      	RCALL SUBOPT_0x7
                 ; 0002 005D   //adr*=512UL;
                 ; 0002 005E   result[1]=0;
00fa3a e0e0      	LDI  R30,LOW(0)
                +
00fa3b 93e0 0516+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
                 ; 0002 005F   for(i=0;i<SectorsPerCluster;i++)
                +
00fa3d e000     +LDI R16 , LOW ( 0 )
00fa3e e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x40007:
00fa3f 940e fd8b 	CALL SUBOPT_0xA
00fa41 f510      	BRSH _0x40008
                 ; 0002 0060   {
                 ; 0002 0061       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
00fa42 940e fd91 	CALL SUBOPT_0xB
00fa44 f009      	BREQ _0x40009
                 ; 0002 0062         errorSD();
00fa45 d199      	RCALL _errorSD
                 ; 0002 0063       for(j=0;j<(16);j++)
                 _0x40009:
                +
00fa46 e020     +LDI R18 , LOW ( 0 )
00fa47 e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x4000B:
                +
00fa48 3120     +CPI R18 , LOW ( 16 )
00fa49 e0e0     +LDI R30 , HIGH ( 16 )
00fa4a 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
00fa4b f440      	BRSH _0x4000C
                 ; 0002 0064       {
                 ; 0002 0065            if((result[1]=compbuf("0          ",&sdBuf[j*32]))!=0)
                +
00fa4c e0e0     +LDI R30 , LOW ( _0x4000E + ( 0 ) )
00fa4d e0f5     +LDI R31 , HIGH ( _0x4000E + ( 0 ) )
                 	__POINTW1MN _0x4000E,0
00fa4e 940e fd93 	CALL SUBOPT_0xC
00fa50 f419      	BRNE _0x4000C
                 ; 0002 0066            {
                 ; 0002 0067                 break;
                 ; 0002 0068            }
                 ; 0002 0069       }
                +
00fa51 5f2f     +SUBI R18 , LOW ( - 1 )
00fa52 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fa53 cff4      	RJMP _0x4000B
                 _0x4000C:
                 ; 0002 006A       if(result[1]!=0)
                +
00fa54 91e0 0516+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fa56 30e0      	CPI  R30,0
00fa57 f039      	BREQ _0x4000F
                 ; 0002 006B       {
                 ; 0002 006C         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
00fa58 940e fda2 	CALL SUBOPT_0xD
00fa5a 940e fda8 	CALL SUBOPT_0xE
                 ; 0002 006D         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
00fa5c 940e fdb9 	CALL SUBOPT_0xF
                 ; 0002 006E         break;
00fa5e c005      	RJMP _0x40008
                 ; 0002 006F       }
                 ; 0002 0070       else
                 _0x4000F:
                 ; 0002 0071         adr++;
00fa5f 940e fdd2 	CALL SUBOPT_0x10
                 ; 0002 0072   }
                +
00fa61 5f0f     +SUBI R16 , LOW ( - 1 )
00fa62 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fa63 cfdb      	RJMP _0x40007
                 _0x40008:
                 ; 0002 0073   adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
00fa64 940e fddd 	CALL SUBOPT_0x11
                 ; 0002 0074   for(i=0;i<SectorsPerCluster;i++)
                 _0x40012:
00fa66 d324      	RCALL SUBOPT_0xA
00fa67 f560      	BRSH _0x40013
                 ; 0002 0075   {
                 ; 0002 0076       if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
00fa68 d328      	RCALL SUBOPT_0xB
00fa69 f009      	BREQ _0x40014
                 ; 0002 0077         errorSD();
00fa6a d174      	RCALL _errorSD
                 ; 0002 0078       for(j=0;j<(16);j++)
                 _0x40014:
                +
00fa6b e020     +LDI R18 , LOW ( 0 )
00fa6c e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40016:
                +
00fa6d 3120     +CPI R18 , LOW ( 16 )
00fa6e e0e0     +LDI R30 , HIGH ( 16 )
00fa6f 073e     +CPC R19 , R30
                 	__CPWRN 18,19,16
00fa70 f438      	BRSH _0x40017
                 ; 0002 0079       {
                 ; 0002 007A            if((result[1]=compbuf("FLASH   ",&sdBuf[j*32]))!=0)
                +
00fa71 e0ec     +LDI R30 , LOW ( _0x4000E + ( 12 ) )
00fa72 e0f5     +LDI R31 , HIGH ( _0x4000E + ( 12 ) )
                 	__POINTW1MN _0x4000E,12
00fa73 d31f      	RCALL SUBOPT_0xC
00fa74 f419      	BRNE _0x40017
                 ; 0002 007B            {
                 ; 0002 007C                 break;
                 ; 0002 007D            }
                 ; 0002 007E       }
                +
00fa75 5f2f     +SUBI R18 , LOW ( - 1 )
00fa76 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fa77 cff5      	RJMP _0x40016
                 _0x40017:
                 ; 0002 007F       if(result[1]!=0)
                +
00fa78 91e0 0516+LDS R30 , _result + ( 1 )
                 	__GETB1MN _result,1
00fa7a 30e0      	CPI  R30,0
00fa7b f099      	BREQ _0x40019
                 ; 0002 0080       {
                 ; 0002 0081         //read 1st number of cluster where data placed
                 ; 0002 0082         fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
00fa7c d325      	RCALL SUBOPT_0xD
00fa7d d32a      	RCALL SUBOPT_0xE
                 ; 0002 0083         fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
00fa7e d33a      	RCALL SUBOPT_0xF
                 ; 0002 0084         filesize = buf2num(&sdBuf[j*32+0x1C],8);
00fa7f d322      	RCALL SUBOPT_0xD
                +
00fa80 5cea     +SUBI R30 , LOW ( - _sdBuf - ( 28 ) )
00fa81 4ffa     +SBCI R31 , HIGH ( - _sdBuf - ( 28 ) )
                 	__ADDW1MN _sdBuf,28
00fa82 93fa      	ST   -Y,R31
00fa83 93ea      	ST   -Y,R30
00fa84 e0a8      	LDI  R26,LOW(8)
00fa85 d15b      	RCALL _buf2num
00fa86 93e0 0836 	STS  _filesize,R30
00fa88 93f0 0837 	STS  _filesize+1,R31
00fa8a 9360 0838 	STS  _filesize+2,R22
00fa8c 9370 0839 	STS  _filesize+3,R23
                 ; 0002 0085         break;
00fa8e c005      	RJMP _0x40013
                 ; 0002 0086       }
                 ; 0002 0087       else
                 _0x40019:
                 ; 0002 0088         adr++;
00fa8f 940e fdd2 	CALL SUBOPT_0x10
                 ; 0002 0089   }
                +
00fa91 5f0f     +SUBI R16 , LOW ( - 1 )
00fa92 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fa93 cfd2      	RJMP _0x40012
                 _0x40013:
                 ; 0002 008A 
                 ; 0002 008B   //check FAT for chain of clusters to read
                 ; 0002 008C   readbytes=0;
00fa94 e0e0      	LDI  R30,LOW(0)
00fa95 93e0 083a 	STS  _readbytes,R30
00fa97 93e0 083b 	STS  _readbytes+1,R30
00fa99 93e0 083c 	STS  _readbytes+2,R30
00fa9b 93e0 083d 	STS  _readbytes+3,R30
                 ; 0002 008D   while(fat_file_adr != 0x0FFFFFFFUL)
                 _0x4001B:
00fa9d 91a0 082e 	LDS  R26,_fat_file_adr
00fa9f 91b0 082f 	LDS  R27,_fat_file_adr+1
00faa1 9180 0830 	LDS  R24,_fat_file_adr+2
00faa3 9190 0831 	LDS  R25,_fat_file_adr+3
00faa5 940e fdff 	CALL SUBOPT_0x12
00faa7 f409      	BRNE PC+2
00faa8 c11e      	RJMP _0x4001D
                 ; 0002 008E   {
                 ; 0002 008F     //read where next cluster from FAT, check that not EOF
                 ; 0002 0090     if((result[0]=SD_readSingleBlock(fat_begin_lba, sdBuf, &token))!=SD_SUCCESS)
00faa9 91e0 0826 	LDS  R30,_fat_begin_lba
00faab 91f0 0827 	LDS  R31,_fat_begin_lba+1
00faad 9160 0828 	LDS  R22,_fat_begin_lba+2
00faaf 9170 0829 	LDS  R23,_fat_begin_lba+3
00fab1 d2d6      	RCALL SUBOPT_0x9
00fab2 f009      	BREQ _0x4001E
                 ; 0002 0091         errorSD();
00fab3 d12b      	RCALL _errorSD
                 ; 0002 0092     fat_file_next_adr=buf2num(&sdBuf[fat_file_adr*4],4);
                 _0x4001E:
00fab4 91a0 082e 	LDS  R26,_fat_file_adr
00fab6 91b0 082f 	LDS  R27,_fat_file_adr+1
00fab8 e0e4      	LDI  R30,LOW(4)
00fab9 940e fec7 	CALL __MULB1W2U
00fabb 5ee6      	SUBI R30,LOW(-_sdBuf)
00fabc 4ffa      	SBCI R31,HIGH(-_sdBuf)
00fabd d2b4      	RCALL SUBOPT_0x6
00fabe 93e0 0832 	STS  _fat_file_next_adr,R30
00fac0 93f0 0833 	STS  _fat_file_next_adr+1,R31
00fac2 9360 0834 	STS  _fat_file_next_adr+2,R22
00fac4 9370 0835 	STS  _fat_file_next_adr+3,R23
                 ; 0002 0093 
                 ; 0002 0094     adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
00fac6 d316      	RCALL SUBOPT_0x11
                 ; 0002 0095     for(i=0;i<SectorsPerCluster;i++)
                 _0x40020:
00fac7 d2c3      	RCALL SUBOPT_0xA
00fac8 f008      	BRLO PC+2
00fac9 c0ec      	RJMP _0x40021
                 ; 0002 0096     {
                 ; 0002 0097         //read data from next sector of file cluster
                 ; 0002 0098         if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
00faca d2c6      	RCALL SUBOPT_0xB
00facb f009      	BREQ _0x40022
                 ; 0002 0099             errorSD();
00facc d112      	RCALL _errorSD
                 ; 0002 009A         //address 2000 = start adr flash app 3 bytes, flash pages 2 bytes, checksum 2 bytes
                 ; 0002 009B         //app bytes starts from 2048, roll 0x88
                 ; 0002 009C         for(j=0;j<512;j++)
                 _0x40022:
                +
00facd e020     +LDI R18 , LOW ( 0 )
00face e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x40024:
                +
00facf 3020     +CPI R18 , LOW ( 512 )
00fad0 e0e2     +LDI R30 , HIGH ( 512 )
00fad1 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fad2 f530      	BRSH _0x40025
                 ; 0002 009D         {
                 ; 0002 009E             sdBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
00fad3 01f9      	MOVW R30,R18
00fad4 5ee6      	SUBI R30,LOW(-_sdBuf)
00fad5 4ffa      	SBCI R31,HIGH(-_sdBuf)
00fad6 01bf      	MOVW R22,R30
00fad7 d32f      	RCALL SUBOPT_0x13
00fad8 0fee      	LSL  R30
00fad9 2e0e      	MOV  R0,R30
00fada d32c      	RCALL SUBOPT_0x13
00fadb 1fee      	ROL  R30
00fadc e0e0      	LDI  R30,0
00fadd 1fee      	ROL  R30
00fade 29e0      	OR   R30,R0
00fadf 01db      	MOVW R26,R22
00fae0 93ec      	ST   X,R30
                 ; 0002 009F             sdBuf[j]^=0x88;  //XOR
00fae1 01f9      	MOVW R30,R18
00fae2 5ee6      	SUBI R30,LOW(-_sdBuf)
00fae3 4ffa      	SBCI R31,HIGH(-_sdBuf)
00fae4 010f      	MOVW R0,R30
00fae5 81a0      	LD   R26,Z
00fae6 e8e8      	LDI  R30,LOW(136)
00fae7 27ea      	EOR  R30,R26
00fae8 01d0      	MOVW R26,R0
00fae9 93ec      	ST   X,R30
                 ; 0002 00A0             checksumCnt+=sdBuf[j];
00faea d31c      	RCALL SUBOPT_0x13
00faeb e0f0      	LDI  R31,0
00faec 91a0 0840 	LDS  R26,_checksumCnt
00faee 91b0 0841 	LDS  R27,_checksumCnt+1
00faf0 0fea      	ADD  R30,R26
00faf1 1ffb      	ADC  R31,R27
00faf2 93e0 0840 	STS  _checksumCnt,R30
00faf4 93f0 0841 	STS  _checksumCnt+1,R31
                 ; 0002 00A1         }
                +
00faf6 5f2f     +SUBI R18 , LOW ( - 1 )
00faf7 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00faf8 cfd6      	RJMP _0x40024
                 _0x40025:
                 ; 0002 00A2         readbytes+=512;
00faf9 91e0 083a 	LDS  R30,_readbytes
00fafb 91f0 083b 	LDS  R31,_readbytes+1
00fafd 9160 083c 	LDS  R22,_readbytes+2
00faff 9170 083d 	LDS  R23,_readbytes+3
                +
00fb01 50e0     +SUBI R30 , LOW ( - 512 )
00fb02 4ffe     +SBCI R31 , HIGH ( - 512 )
00fb03 4f6f     +SBCI R22 , BYTE3 ( - 512 )
00fb04 4f7f     +SBCI R23 , BYTE4 ( - 512 )
                 	__ADDD1N 512
00fb05 93e0 083a 	STS  _readbytes,R30
00fb07 93f0 083b 	STS  _readbytes+1,R31
00fb09 9360 083c 	STS  _readbytes+2,R22
00fb0b 9370 083d 	STS  _readbytes+3,R23
                 ; 0002 00A3         //read app data
                 ; 0002 00A4         if(readbytes>2048)
00fb0d d2ff      	RCALL SUBOPT_0x14
                +
00fb0e 30a1     +CPI R26 , LOW ( 0x801 )
00fb0f e0e8     +LDI R30 , HIGH ( 0x801 )
00fb10 07be     +CPC R27 , R30
00fb11 e0e0     +LDI R30 , BYTE3 ( 0x801 )
00fb12 078e     +CPC R24 , R30
00fb13 e0e0     +LDI R30 , BYTE4 ( 0x801 )
00fb14 079e     +CPC R25 , R30
                 	__CPD2N 0x801
00fb15 f190      	BRLO _0x40026
                 ; 0002 00A5         {
                 ; 0002 00A6            for(pagesCnt=0;pagesCnt<PAGES_PER_SDBUF;pagesCnt++)
00fb16 24bb      	CLR  R11
                 _0x40028:
00fb17 e0e2      	LDI  R30,LOW(2)
00fb18 16be      	CP   R11,R30
00fb19 f568      	BRSH _0x40029
                 ; 0002 00A7            {
                 ; 0002 00A8                if(WriteFlashPage(appStartAdr, &sdBuf[pagesCnt*PAGESIZE])==0)
00fb1a d2fb      	RCALL SUBOPT_0x15
00fb1b 940e fef9 	CALL __PUTPARD1
00fb1d 2dab      	MOV  R26,R11
00fb1e e0b0      	LDI  R27,0
00fb1f e0e0      	LDI  R30,LOW(256)
00fb20 e0f1      	LDI  R31,HIGH(256)
00fb21 940e fecd 	CALL __MULW12
00fb23 5ee6      	SUBI R30,LOW(-_sdBuf)
00fb24 4ffa      	SBCI R31,HIGH(-_sdBuf)
00fb25 01df      	MOVW R26,R30
00fb26 940e f8cb 	CALL _WriteFlashPage
00fb28 30e0      	CPI  R30,0
00fb29 f429      	BRNE _0x4002A
                 ; 0002 00A9                {
                 ; 0002 00AA                     //while(1)
                 ; 0002 00AB                     do
                 _0x4002C:
                 ; 0002 00AC                     {
                 ; 0002 00AD                       PORTC.6=0;
00fb2a 98ae      	CBI  0x15,6
                 ; 0002 00AE                       delay_ms(500);
00fb2b d2f3      	RCALL SUBOPT_0x16
                 ; 0002 00AF                       PORTC.6=1;
00fb2c 9aae      	SBI  0x15,6
                 ; 0002 00B0                       delay_ms(500);
00fb2d d2f1      	RCALL SUBOPT_0x16
                 ; 0002 00B1                     }while(1);
00fb2e cffb      	RJMP _0x4002C
                 ; 0002 00B2                }
                 ; 0002 00B3                appStartAdr+=PAGESIZE;
                 _0x4002A:
00fb2f d2e6      	RCALL SUBOPT_0x15
                +
00fb30 50e0     +SUBI R30 , LOW ( - 256 )
00fb31 4fff     +SBCI R31 , HIGH ( - 256 )
00fb32 4f6f     +SBCI R22 , BYTE3 ( - 256 )
00fb33 4f7f     +SBCI R23 , BYTE4 ( - 256 )
                 	__ADDD1N 256
00fb34 d2ee      	RCALL SUBOPT_0x17
                 ; 0002 00B4                appPages--;
00fb35 01f6      	MOVW R30,R12
00fb36 9731      	SBIW R30,1
00fb37 016f      	MOVW R12,R30
                 ; 0002 00B5                if(appPages==0)
00fb38 2c0c      	MOV  R0,R12
00fb39 280d      	OR   R0,R13
00fb3a f451      	BRNE _0x40032
                 ; 0002 00B6                {
                 ; 0002 00B7                     app_pointer();
                +
00fb3b 91e0 0842+LDS R30 , _app_pointer + ( 0 )
00fb3d 91f0 0843+LDS R31 , _app_pointer + ( 0 ) + 1
00fb3f 9509     +ICALL
                 	__CALL1MN _app_pointer,0
                 ; 0002 00B8                     do
                 _0x40034:
                 ; 0002 00B9                     {
                 ; 0002 00BA                       PORTC.5=0;
00fb40 98ad      	CBI  0x15,5
                 ; 0002 00BB                       delay_ms(500);
00fb41 d2dd      	RCALL SUBOPT_0x16
                 ; 0002 00BC                       PORTC.5=1;
00fb42 9aad      	SBI  0x15,5
                 ; 0002 00BD                       delay_ms(500);
00fb43 d2db      	RCALL SUBOPT_0x16
                 ; 0002 00BE                     }while(1);
00fb44 cffb      	RJMP _0x40034
                 ; 0002 00BF                }
                 ; 0002 00C0            }
                 _0x40032:
00fb45 94b3      	INC  R11
00fb46 cfd0      	RJMP _0x40028
                 _0x40029:
                 ; 0002 00C1         }
                 ; 0002 00C2         //read app start adr, num of pages, checksum
                 ; 0002 00C3         else if(readbytes>=2000)//Offset=512-48=464
00fb47 c044      	RJMP _0x4003A
                 _0x40026:
00fb48 d2c4      	RCALL SUBOPT_0x14
                +
00fb49 3da0     +CPI R26 , LOW ( 0x7D0 )
00fb4a e0e7     +LDI R30 , HIGH ( 0x7D0 )
00fb4b 07be     +CPC R27 , R30
00fb4c e0e0     +LDI R30 , BYTE3 ( 0x7D0 )
00fb4d 078e     +CPC R24 , R30
00fb4e e0e0     +LDI R30 , BYTE4 ( 0x7D0 )
00fb4f 079e     +CPC R25 , R30
                 	__CPD2N 0x7D0
00fb50 f1d8      	BRLO _0x4003B
                 ; 0002 00C4         {
                 ; 0002 00C5            appStartAdr=(unsigned long)sdBuf[464]<<16;
                +
00fb51 91e0 06ea+LDS R30 , _sdBuf + ( 464 )
                 	__GETB1MN _sdBuf,464
00fb53 e0f0      	LDI  R31,0
00fb54 940e fe9a 	CALL __CWD1
00fb56 940e fe95 	CALL __LSLD16
00fb58 d2ca      	RCALL SUBOPT_0x17
                 ; 0002 00C6            appStartAdr|=(unsigned long)sdBuf[465]<<8;
                +
00fb59 91e0 06eb+LDS R30 , _sdBuf + ( 465 )
                 	__GETB1MN _sdBuf,465
00fb5b e0f0      	LDI  R31,0
00fb5c 940e fe9a 	CALL __CWD1
00fb5e 01df      	MOVW R26,R30
00fb5f 01cb      	MOVW R24,R22
00fb60 e0e8      	LDI  R30,LOW(8)
00fb61 940e fe73 	CALL __LSLD12
00fb63 d2c8      	RCALL SUBOPT_0x18
                 ; 0002 00C7            appStartAdr|=(unsigned long)sdBuf[466];
                +
00fb64 91e0 06ec+LDS R30 , _sdBuf + ( 466 )
                 	__GETB1MN _sdBuf,466
00fb66 e0f0      	LDI  R31,0
00fb67 940e fe9a 	CALL __CWD1
00fb69 d2c2      	RCALL SUBOPT_0x18
                 ; 0002 00C8            appPages=(unsigned int)sdBuf[467]<<8;
                +
00fb6a 91f0 06ed+LDS R31 , _sdBuf + ( 467 )
                 	__GETBRMN 31,_sdBuf,467
00fb6c e0e0      	LDI  R30,LOW(0)
00fb6d 016f      	MOVW R12,R30
                 ; 0002 00C9            appPages|=(unsigned int)sdBuf[468];
                +
00fb6e 91e0 06ee+LDS R30 , _sdBuf + ( 468 )
                 	__GETB1MN _sdBuf,468
00fb70 e0f0      	LDI  R31,0
                +
00fb71 2ace     +OR R12 , R30
00fb72 2adf     +OR R13 , R31
                 	__ORWRR 12,13,30,31
                 ; 0002 00CA            bytesChecksum=(unsigned int)sdBuf[469]<<8;
                +
00fb73 91f0 06ef+LDS R31 , _sdBuf + ( 469 )
                 	__GETBRMN 31,_sdBuf,469
00fb75 e0e0      	LDI  R30,LOW(0)
00fb76 93e0 083e 	STS  _bytesChecksum,R30
00fb78 93f0 083f 	STS  _bytesChecksum+1,R31
                 ; 0002 00CB            bytesChecksum|=(unsigned int)sdBuf[470];
                +
00fb7a 91e0 06f0+LDS R30 , _sdBuf + ( 470 )
                 	__GETB1MN _sdBuf,470
00fb7c e0f0      	LDI  R31,0
00fb7d 91a0 083e 	LDS  R26,_bytesChecksum
00fb7f 91b0 083f 	LDS  R27,_bytesChecksum+1
00fb81 2bea      	OR   R30,R26
00fb82 2bfb      	OR   R31,R27
00fb83 93e0 083e 	STS  _bytesChecksum,R30
00fb85 93f0 083f 	STS  _bytesChecksum+1,R31
                 ; 0002 00CC            checksumCnt=0;
00fb87 e0e0      	LDI  R30,LOW(0)
00fb88 93e0 0840 	STS  _checksumCnt,R30
00fb8a 93e0 0841 	STS  _checksumCnt+1,R30
                 ; 0002 00CD         }
                 ; 0002 00CE         if(fat_file_next_adr == 0x0FFFFFFFUL)
                 _0x4003B:
                 _0x4003A:
00fb8c 91a0 0832 	LDS  R26,_fat_file_next_adr
00fb8e 91b0 0833 	LDS  R27,_fat_file_next_adr+1
00fb90 9180 0834 	LDS  R24,_fat_file_next_adr+2
00fb92 9190 0835 	LDS  R25,_fat_file_next_adr+3
00fb94 d26a      	RCALL SUBOPT_0x12
00fb95 f4e1      	BRNE _0x4003C
                 ; 0002 00CF             if(readbytes >= filesize)
00fb96 91e0 0836 	LDS  R30,_filesize
00fb98 91f0 0837 	LDS  R31,_filesize+1
00fb9a 9160 0838 	LDS  R22,_filesize+2
00fb9c 9170 0839 	LDS  R23,_filesize+3
00fb9e d26e      	RCALL SUBOPT_0x14
00fb9f 940e ff07 	CALL __CPD21
00fba1 f4a0      	BRSH _0x40021
                 ; 0002 00D0             {
                 ; 0002 00D1                 break;
                 ; 0002 00D2             }
                 ; 0002 00D3             else
                 ; 0002 00D4             {
                 ; 0002 00D5 
                 ; 0002 00D6                 if(  WriteFlashPage(0x1EF00, sdBuf))//;     // Writes testbuffer1 to Flash page 2
00fba2 d294      	RCALL SUBOPT_0x19
00fba3 e1aa      	LDI  R26,LOW(_sdBuf)
00fba4 e0b5      	LDI  R27,HIGH(_sdBuf)
00fba5 940e f8cb 	CALL _WriteFlashPage
00fba7 30e0      	CPI  R30,0
00fba8 f009      	BREQ _0x4003F
                 ; 0002 00D7                     PORTC.5=0;                                          // Function returns TRUE
00fba9 98ad      	CBI  0x15,5
                 ; 0002 00D8                 if(  ReadFlashPage (0x1EF00, testBuf))//;      // Reads back Flash page 2 to TestBuffer2
                 _0x4003F:
00fbaa d28c      	RCALL SUBOPT_0x19
00fbab e1aa      	LDI  R26,LOW(_testBuf)
00fbac e0b7      	LDI  R27,HIGH(_testBuf)
00fbad 940e f89e 	CALL _ReadFlashPage
00fbaf 30e0      	CPI  R30,0
00fbb0 f009      	BREQ _0x40042
                 ; 0002 00D9                     PORTC.6=0;
00fbb1 98ae      	CBI  0x15,6
                 ; 0002 00DA             }
                 _0x40042:
                 ; 0002 00DB 
                 ; 0002 00DC         adr++;
                 _0x4003C:
00fbb2 d21f      	RCALL SUBOPT_0x10
                 ; 0002 00DD     }
                +
00fbb3 5f0f     +SUBI R16 , LOW ( - 1 )
00fbb4 4f1f     +SBCI R17 , HIGH ( - 1 )
                 	__ADDWRN 16,17,1
00fbb5 cf11      	RJMP _0x40020
                 _0x40021:
                 ; 0002 00DE     fat_file_adr = fat_file_next_adr;
00fbb6 91e0 0832 	LDS  R30,_fat_file_next_adr
00fbb8 91f0 0833 	LDS  R31,_fat_file_next_adr+1
00fbba 9160 0834 	LDS  R22,_fat_file_next_adr+2
00fbbc 9170 0835 	LDS  R23,_fat_file_next_adr+3
00fbbe 93e0 082e 	STS  _fat_file_adr,R30
00fbc0 93f0 082f 	STS  _fat_file_adr+1,R31
00fbc2 9360 0830 	STS  _fat_file_adr+2,R22
00fbc4 9370 0831 	STS  _fat_file_adr+3,R23
                 ; 0002 00DF   }
00fbc6 ced6      	RJMP _0x4001B
                 _0x4001D:
                 ; 0002 00E0 
                 ; 0002 00E1 
                 ; 0002 00E2   while(1);
                 _0x40045:
00fbc7 cfff      	RJMP _0x40045
                 ; 0002 00E3   //static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
                 ; 0002 00E4   //if(PORTA==0x55)
                 ; 0002 00E5     //testWrite();                                          // Returns TRUE
                 ; 0002 00E6   //__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
                 ; 0002 00E7   //__AddrToZ24ByteToSPMCR_SPM_W((void flash *)0);
                 ; 0002 00E8   /*
                 ; 0002 00E9   unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
                 ; 0002 00EA   unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                 ; 0002 00EB                                             // code stack
                 ; 0002 00EC   int index;
                 ; 0002 00ED 
                 ; 0002 00EE   DDRC=0xFF;
                 ; 0002 00EF   PORTC=0xFF;
                 ; 0002 00F0   //DDRC=0x00;
                 ; 0002 00F1   //PORTC=0x00;
                 ; 0002 00F2   //MCUCR |= (1<<IVSEL);
                 ; 0002 00F3                         // Move interrupt vectors to boot
                 ; 0002 00F4   //RecoverFlash();
                 ; 0002 00F5 
                 ; 0002 00F6   dospm();
                 ; 0002 00F7 
                 ; 0002 00F8   for(index=0; index<PAGESIZE; index++){
                 ; 0002 00F9     testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
                 ; 0002 00FA   }
                 ; 0002 00FB   PORTC.4=0;
                 ; 0002 00FC   //for(;;){
                 ; 0002 00FD   if(  WriteFlashPage(0x1000, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
                 ; 0002 00FE     PORTC.5=0;                                          // Function returns TRUE
                 ; 0002 00FF   if(  ReadFlashPage(0x1000, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
                 ; 0002 0100     PORTC.6=0;                                          // Function returns TRUE
                 ; 0002 0101   if(  WriteFlashByte(0x1004, 0x38))//;            // Writes 0x38 to byte address 0x204
                 ; 0002 0102     PORTC.5=0;                                          // Same as byte 4 on page 2
                 ; 0002 0103   */
                 ; 0002 0104 
                 ; 0002 0105   //}
                 ; 0002 0106 }
                 _0x40048:
00fbc8 cfff      	RJMP _0x40048
                 ; .FEND
                 
                 	.DSEG
                 _0x4000E:
000500           	.BYTE 0x15
                 ;
                 ;unsigned char compbuf(const unsigned char *src,unsigned char *dest)
                 ; 0002 0109 {
                 
                 	.CSEG
                 _compbuf:
                 ; .FSTART _compbuf
                 ; 0002 010A     while(*src)
00fbc9 93ba      	ST   -Y,R27
00fbca 93aa      	ST   -Y,R26
                 ;	*src -> Y+2
                 ;	*dest -> Y+0
                 _0x40049:
00fbcb 81aa      	LDD  R26,Y+2
00fbcc 81bb      	LDD  R27,Y+2+1
00fbcd 91ec      	LD   R30,X
00fbce 30e0      	CPI  R30,0
00fbcf f069      	BREQ _0x4004B
                 ; 0002 010B     {
                 ; 0002 010C         if(*src++ != *dest++)
00fbd0 900d      	LD   R0,X+
00fbd1 83aa      	STD  Y+2,R26
00fbd2 83bb      	STD  Y+2+1,R27
00fbd3 81a8      	LD   R26,Y
00fbd4 81b9      	LDD  R27,Y+1
00fbd5 91ed      	LD   R30,X+
00fbd6 83a8      	ST   Y,R26
00fbd7 83b9      	STD  Y+1,R27
00fbd8 15e0      	CP   R30,R0
00fbd9 f011      	BREQ _0x4004C
                 ; 0002 010D             return 0;
00fbda e0e0      	LDI  R30,LOW(0)
00fbdb c081      	RJMP _0x2000009
                 ; 0002 010E         //src++;dest++;
                 ; 0002 010F         //len--;
                 ; 0002 0110     }
                 _0x4004C:
00fbdc cfee      	RJMP _0x40049
                 _0x4004B:
                 ; 0002 0111     return 1;
00fbdd e0e1      	LDI  R30,LOW(1)
00fbde c07e      	RJMP _0x2000009
                 ; 0002 0112 }
                 ; .FEND
                 ;
                 ;void errorSD()
                 ; 0002 0115 {
                 _errorSD:
                 ; .FSTART _errorSD
                 ; 0002 0116     PORTC.1=0;
00fbdf 98a9      	CBI  0x15,1
                 ; 0002 0117     while(1);
                 _0x4004F:
00fbe0 cfff      	RJMP _0x4004F
                 ; 0002 0118 }
                 ; .FEND
                 ;
                 ;unsigned long buf2num(unsigned char *buf,unsigned char len)
                 ; 0002 011B {
                 _buf2num:
                 ; .FSTART _buf2num
                 ; 0002 011C     unsigned long num=0;
                 ; 0002 011D     //unsigned char i;
                 ; 0002 011E     for(;len>0;len--)
00fbe1 93aa      	ST   -Y,R26
00fbe2 9724      	SBIW R28,4
00fbe3 e0e0      	LDI  R30,LOW(0)
00fbe4 83e8      	ST   Y,R30
00fbe5 83e9      	STD  Y+1,R30
00fbe6 83ea      	STD  Y+2,R30
00fbe7 83eb      	STD  Y+3,R30
                 ;	*buf -> Y+5
                 ;	len -> Y+4
                 ;	num -> Y+0
                 _0x40053:
00fbe8 81ac      	LDD  R26,Y+4
00fbe9 30a1      	CPI  R26,LOW(0x1)
00fbea f0d0      	BRLO _0x40054
                 ; 0002 011F     {
                 ; 0002 0120         num<<=8;
00fbeb d178      	RCALL SUBOPT_0x4
00fbec e0e8      	LDI  R30,LOW(8)
00fbed 940e fe73 	CALL __LSLD12
00fbef 940e fef4 	CALL __PUTD1S0
                 ; 0002 0121         num|=buf[len-1];
00fbf1 81ec      	LDD  R30,Y+4
00fbf2 e0f0      	LDI  R31,0
00fbf3 9731      	SBIW R30,1
00fbf4 81ad      	LDD  R26,Y+5
00fbf5 81be      	LDD  R27,Y+5+1
00fbf6 0fae      	ADD  R26,R30
00fbf7 1fbf      	ADC  R27,R31
00fbf8 91ec      	LD   R30,X
00fbf9 d16a      	RCALL SUBOPT_0x4
00fbfa 27ff      	CLR  R31
00fbfb 2766      	CLR  R22
00fbfc 2777      	CLR  R23
00fbfd 940e fe6a 	CALL __ORD12
00fbff 940e fef4 	CALL __PUTD1S0
                 ; 0002 0122     }
00fc01 81ec      	LDD  R30,Y+4
00fc02 50e1      	SUBI R30,LOW(1)
00fc03 83ec      	STD  Y+4,R30
00fc04 cfe3      	RJMP _0x40053
                 _0x40054:
                 ; 0002 0123     return num;
00fc05 d14a      	RCALL SUBOPT_0x0
00fc06 9627      	ADIW R28,7
00fc07 9508      	RET
                 ; 0002 0124 }
                 ; .FEND
                 ;
                 ;
                 ;void testWrite()
                 ; 0002 0128 {
                 ; 0002 0129   unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
                 ; 0002 012A   unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                 ; 0002 012B                                             // code stack
                 ; 0002 012C 
                 ; 0002 012D 
                 ; 0002 012E   static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
                 ; 0002 012F   int index;
                 ; 0002 0130 
                 ; 0002 0131   //DDRC=0xFF;
                 ; 0002 0132   //PORTC=0xFF;
                 ; 0002 0133   //DDRC=0x00;
                 ; 0002 0134   //PORTC=0x00;
                 ; 0002 0135   //MCUCR |= (1<<IVSEL);
                 ; 0002 0136                         // Move interrupt vectors to boot
                 ; 0002 0137   //RecoverFlash();
                 ; 0002 0138 
                 ; 0002 0139   //dospm();
                 ; 0002 013A 
                 ; 0002 013B   for(index=0; index<PAGESIZE; index++){
                 ;	testBuffer1 -> Y+258
                 ;	testBuffer2 -> Y+2
                 ;	index -> R16,R17
                 ; 0002 013C     testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
                 ; 0002 013D   }
                 ; 0002 013E   PORTC.4=0;
                 ; 0002 013F   //for(;;){
                 ; 0002 0140   if(  WriteFlashPage(0x1EF00, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
                 ; 0002 0141     PORTC.5=0;                                          // Function returns TRUE
                 ; 0002 0142   if(  ReadFlashPage(0x1EF00, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
                 ; 0002 0143     PORTC.6=0;                                          // Function returns TRUE
                 ; 0002 0144   if(  WriteFlashByte(0x1EF04, 0x38))//;            // Writes 0x38 to byte address 0x204
                 ; 0002 0145     PORTC.5=1;                                          // Same as byte 4 on page 2
                 ; 0002 0146   testChar = ReadFlashByte(0x1EF04);        // Reads back value from address 0x204
                 ; 0002 0147 
                 ; 0002 0148   if(testChar==0x38)
                 ; 0002 0149   {
                 ; 0002 014A     while(1)
                 ; 0002 014B     {
                 ; 0002 014C       PORTC.6=0;
                 ; 0002 014D       delay_ms(500);
                 ; 0002 014E       PORTC.6=1;
                 ; 0002 014F       delay_ms(500);;
                 ; 0002 0150     }
                 ; 0002 0151   }
                 ; 0002 0152 }
                 ;#include "spi_sdcard.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;
                 ;
                 ;
                 ;void SPI_init()
                 ; 0003 0007 {
                 
                 	.CSEG
                 _SPI_init:
                 ; .FSTART _SPI_init
                 ; 0003 0008     // set CS, MOSI and SCK to output
                 ; 0003 0009     DDR_SPI = (1 << CS) | (1 << MOSI) | (1 << SCK);
00fc08 e0e7      	LDI  R30,LOW(7)
00fc09 bbe7      	OUT  0x17,R30
                 ; 0003 000A     PORT_SPI|=(1 << CS);
00fc0a 9ac0      	SBI  0x18,0
                 ; 0003 000B     // enable pull up resistor in MISO
                 ; 0003 000C     DDR_SPI &= ~(1 << MISO);
00fc0b 98bb      	CBI  0x17,3
                 ; 0003 000D     PORT_SPI &= ~(1 << MISO);
00fc0c 98c3      	CBI  0x18,3
                 ; 0003 000E     //PORT_SPI |= (1 << MISO);
                 ; 0003 000F 
                 ; 0003 0010     // enable SPI, set as master, and clock to fosc/128
                 ; 0003 0011     SPCR = (1 << SPE) | (1 << MSTR) | (0 << SPR1) | (0 << SPR0);
00fc0d e5e0      	LDI  R30,LOW(80)
00fc0e b9ed      	OUT  0xD,R30
                 ; 0003 0012 }
00fc0f 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SPI_transfer(unsigned char data)
                 ; 0003 0015 {
                 _SPI_transfer:
                 ; .FSTART _SPI_transfer
                 ; 0003 0016     // load data into register
                 ; 0003 0017     SPDR = data;
00fc10 93aa      	ST   -Y,R26
                 ;	data -> Y+0
00fc11 81e8      	LD   R30,Y
00fc12 b9ef      	OUT  0xF,R30
                 ; 0003 0018 
                 ; 0003 0019     // Wait for transmission complete
                 ; 0003 001A     while(!(SPSR & (1 << SPIF)));
                 _0x60003:
00fc13 9b77      	SBIS 0xE,7
00fc14 cffe      	RJMP _0x60003
                 ; 0003 001B 
                 ; 0003 001C     // return SPDR
                 ; 0003 001D     return SPDR;
00fc15 b1ef      	IN   R30,0xF
00fc16 9621      	ADIW R28,1
00fc17 9508      	RET
                 ; 0003 001E }
                 ; .FEND
                 ;
                 ;
                 ;void SD_powerUpSeq()
                 ; 0003 0022 {
                 _SD_powerUpSeq:
                 ; .FSTART _SD_powerUpSeq
                 ; 0003 0023     unsigned char i;
                 ; 0003 0024 
                 ; 0003 0025     SPI_init();
00fc18 931a      	ST   -Y,R17
                 ;	i -> R17
00fc19 dfee      	RCALL _SPI_init
                 ; 0003 0026 
                 ; 0003 0027     // make sure card is deselected
                 ; 0003 0028     CS_DISABLE();
00fc1a 9ac0      	SBI  0x18,0
                 ; 0003 0029 
                 ; 0003 002A     // give SD card time to power up
                 ; 0003 002B     delay_ms(1);
00fc1b e0a1      	LDI  R26,LOW(1)
00fc1c e0b0      	LDI  R27,0
00fc1d 940e fe56 	CALL _delay_ms
                 ; 0003 002C 
                 ; 0003 002D     // send 80 clock cycles to synchronize
                 ; 0003 002E     for(i = 0; i < 10; i++)
00fc1f e010      	LDI  R17,LOW(0)
                 _0x60007:
00fc20 301a      	CPI  R17,10
00fc21 f420      	BRSH _0x60008
                 ; 0003 002F         SPI_transfer(0xFF);
00fc22 efaf      	LDI  R26,LOW(255)
00fc23 dfec      	RCALL _SPI_transfer
00fc24 5f1f      	SUBI R17,-1
00fc25 cffa      	RJMP _0x60007
                 _0x60008:
                 ; 0003 0032 PORTB |= (1 << 0       );
00fc26 d217      	RCALL SUBOPT_0x1A
                 ; 0003 0033     SPI_transfer(0xFF);
                 ; 0003 0034 }
00fc27 c08b      	RJMP _0x2000006
                 ; .FEND
                 ;
                 ;unsigned char SD_command(unsigned char cmd, unsigned long arg, unsigned char crc)
                 ; 0003 0037 {
                 _SD_command:
                 ; .FSTART _SD_command
                 ; 0003 0038     unsigned char res,count;
                 ; 0003 0039     // transmit command to sd card
                 ; 0003 003A     SPI_transfer(cmd|0x40);
00fc28 93aa      	ST   -Y,R26
00fc29 931a      	ST   -Y,R17
00fc2a 930a      	ST   -Y,R16
                 ;	cmd -> Y+7
                 ;	arg -> Y+3
                 ;	crc -> Y+2
                 ;	res -> R17
                 ;	count -> R16
00fc2b 81ef      	LDD  R30,Y+7
00fc2c 64e0      	ORI  R30,0x40
00fc2d d213      	RCALL SUBOPT_0x1B
                 ; 0003 003B 
                 ; 0003 003C     // transmit argument
                 ; 0003 003D     SPI_transfer((unsigned char)(arg >> 24));
00fc2e e1e8      	LDI  R30,LOW(24)
00fc2f 940e fe7f 	CALL __LSRD12
00fc31 2fae      	MOV  R26,R30
00fc32 dfdd      	RCALL _SPI_transfer
                 ; 0003 003E     SPI_transfer((unsigned char)(arg >> 16));
                +
00fc33 81eb     +LDD R30 , Y + 3
00fc34 81fc     +LDD R31 , Y + 3 + 1
00fc35 816d     +LDD R22 , Y + 3 + 2
00fc36 817e     +LDD R23 , Y + 3 + 3
                 	__GETD1S 3
00fc37 940e fe90 	CALL __LSRD16
00fc39 d207      	RCALL SUBOPT_0x1B
                 ; 0003 003F     SPI_transfer((unsigned char)(arg >> 8));
00fc3a e0e8      	LDI  R30,LOW(8)
00fc3b 940e fe7f 	CALL __LSRD12
00fc3d 2fae      	MOV  R26,R30
00fc3e dfd1      	RCALL _SPI_transfer
                 ; 0003 0040     SPI_transfer((unsigned char)(arg));
00fc3f 81ab      	LDD  R26,Y+3
00fc40 dfcf      	RCALL _SPI_transfer
                 ; 0003 0041 
                 ; 0003 0042     // transmit crc
                 ; 0003 0043     SPI_transfer(crc|0x01);
00fc41 81ea      	LDD  R30,Y+2
00fc42 60e1      	ORI  R30,1
00fc43 2fae      	MOV  R26,R30
00fc44 dfcb      	RCALL _SPI_transfer
                 ; 0003 0044 
                 ; 0003 0045     //wait response R1
                 ; 0003 0046     res = SD_readRes1();
00fc45 d005      	RCALL _SD_readRes1
00fc46 2f1e      	MOV  R17,R30
                 ; 0003 0047     /*
                 ; 0003 0048     do {
                 ; 0003 0049      res=SPI_transfer(0xFF);;
                 ; 0003 004A      count++;
                 ; 0003 004B     } while ( ((res&0x80)!=0x00)&&(count<0xff) );
                 ; 0003 004C     */
                 ; 0003 004D     return res;
                 _0x200000A:
00fc47 8119      	LDD  R17,Y+1
00fc48 8108      	LDD  R16,Y+0
00fc49 9628      	ADIW R28,8
00fc4a 9508      	RET
                 ; 0003 004E }
                 ; .FEND
                 ;
                 ;
                 ;unsigned char SD_readRes1()
                 ; 0003 0052 {
                 _SD_readRes1:
                 ; .FSTART _SD_readRes1
                 ; 0003 0053     unsigned char res1;
                 ; 0003 0054     unsigned int i = 0;
                 ; 0003 0055 
                 ; 0003 0056     // keep polling until actual data received
                 ; 0003 0057     //while((res1 = SPI_transfer(0xFF)) == 0xFF)
                 ; 0003 0058     while(((res1 = SPI_transfer(0xFF))&0x80) != 0x00)
00fc4b 940e ff0e 	CALL __SAVELOCR4
                 ;	res1 -> R17
                 ;	i -> R18,R19
                +
00fc4d e020     +LDI R18 , LOW ( 0 )
00fc4e e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60009:
00fc4f efaf      	LDI  R26,LOW(255)
00fc50 dfbf      	RCALL _SPI_transfer
00fc51 2f1e      	MOV  R17,R30
00fc52 78e0      	ANDI R30,LOW(0x80)
00fc53 f031      	BREQ _0x6000B
                 ; 0003 0059     {
                 ; 0003 005A         i++;
                +
00fc54 5f2f     +SUBI R18 , LOW ( - 1 )
00fc55 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                 ; 0003 005B 
                 ; 0003 005C         // if no data received for (254)8 bytes, break
                 ; 0003 005D         if(i > 0x1FF) break;
                +
00fc56 3020     +CPI R18 , LOW ( 512 )
00fc57 e0e2     +LDI R30 , HIGH ( 512 )
00fc58 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fc59 f3a8      	BRLO _0x60009
                 ; 0003 005E     }
                 _0x6000B:
                 ; 0003 005F 
                 ; 0003 0060     return res1;
00fc5a 2fe1      	MOV  R30,R17
00fc5b 940e ff15 	CALL __LOADLOCR4
                 _0x2000009:
00fc5d 9624      	ADIW R28,4
00fc5e 9508      	RET
                 ; 0003 0061 }
                 ; .FEND
                 ;
                 ;unsigned char SD_goIdleState()
                 ; 0003 0064 {
                 _SD_goIdleState:
                 ; .FSTART _SD_goIdleState
                 ; 0003 0065     unsigned char res1;
                 ; 0003 0066     // assert chip select
                 ; 0003 0067     SPI_transfer(0xFF);
00fc5f d1e8      	RCALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 0068     CS_ENABLE();
                 ; 0003 0069     //SPI_transfer(0xFF);
                 ; 0003 006A 
                 ; 0003 006B     // send CMD0
                 ; 0003 006C     res1 = SD_command(CMD0, CMD0_ARG, CMD0_CRC);
00fc60 e0e0      	LDI  R30,LOW(0)
00fc61 93ea      	ST   -Y,R30
00fc62 d0f0      	RCALL SUBOPT_0x1
00fc63 e9a4      	LDI  R26,LOW(148)
00fc64 c04a      	RJMP _0x2000005
                 ; 0003 006D 
                 ; 0003 006E     // read response
                 ; 0003 006F     //res1 = SD_readRes1();
                 ; 0003 0070 
                 ; 0003 0071     // deassert chip select
                 ; 0003 0072     SPI_transfer(0xFF);
                 ; 0003 0073     CS_DISABLE();
                 ; 0003 0074     SPI_transfer(0xFF);
                 ; 0003 0075 
                 ; 0003 0076     return res1;
                 ; 0003 0077 }
                 ; .FEND
                 ;
                 ;void SD_readRes7(unsigned char *res)
                 ; 0003 007A {
                 _SD_readRes7:
                 ; .FSTART _SD_readRes7
                 ; 0003 007B     // read response 1 in R7
                 ; 0003 007C     //res[0] = SD_readRes1();
                 ; 0003 007D 
                 ; 0003 007E     // if error reading R1, return
                 ; 0003 007F     if(res[0] > 1) return;
00fc65 93ba      	ST   -Y,R27
00fc66 93aa      	ST   -Y,R26
                 ;	*res -> Y+0
00fc67 81a8      	LD   R26,Y
00fc68 81b9      	LDD  R27,Y+1
00fc69 91ac      	LD   R26,X
00fc6a 30a2      	CPI  R26,LOW(0x2)
00fc6b f578      	BRSH _0x2000008
                 ; 0003 0080 
                 ; 0003 0081     // read remaining bytes
                 ; 0003 0082     res[1] = SPI_transfer(0xFF);
00fc6c efaf      	LDI  R26,LOW(255)
00fc6d dfa2      	RCALL _SPI_transfer
                +
00fc6e 81a8     +LDD R26 , Y + 0
00fc6f 81b9     +LDD R27 , Y + 0 + 1
00fc70 9611     +ADIW R26 , 1
00fc71 93ec     +ST X , R30
                 	__PUTB1SNS 0,1
                 ; 0003 0083     res[2] = SPI_transfer(0xFF);
00fc72 efaf      	LDI  R26,LOW(255)
00fc73 df9c      	RCALL _SPI_transfer
                +
00fc74 81a8     +LDD R26 , Y + 0
00fc75 81b9     +LDD R27 , Y + 0 + 1
00fc76 9612     +ADIW R26 , 2
00fc77 93ec     +ST X , R30
                 	__PUTB1SNS 0,2
                 ; 0003 0084     res[3] = SPI_transfer(0xFF);
00fc78 efaf      	LDI  R26,LOW(255)
00fc79 df96      	RCALL _SPI_transfer
                +
00fc7a 81a8     +LDD R26 , Y + 0
00fc7b 81b9     +LDD R27 , Y + 0 + 1
00fc7c 9613     +ADIW R26 , 3
00fc7d 93ec     +ST X , R30
                 	__PUTB1SNS 0,3
                 ; 0003 0085     res[4] = SPI_transfer(0xFF);
00fc7e efaf      	LDI  R26,LOW(255)
00fc7f df90      	RCALL _SPI_transfer
                +
00fc80 81a8     +LDD R26 , Y + 0
00fc81 81b9     +LDD R27 , Y + 0 + 1
00fc82 9614     +ADIW R26 , 4
00fc83 93ec     +ST X , R30
                 	__PUTB1SNS 0,4
                 ; 0003 0086 }
00fc84 c016      	RJMP _0x2000008
                 ; .FEND
                 ;
                 ;void SD_sendIfCond(unsigned char *res)
                 ; 0003 0089 {
                 _SD_sendIfCond:
                 ; .FSTART _SD_sendIfCond
                 ; 0003 008A     // assert chip select
                 ; 0003 008B     SPI_transfer(0xFF);
00fc85 d1c7      	RCALL SUBOPT_0x1D
                 ;	*res -> Y+0
                 ; 0003 008C     CS_ENABLE();
                 ; 0003 008D     //SPI_transfer(0xFF);
                 ; 0003 008E 
                 ; 0003 008F     // send CMD8
                 ; 0003 0090     res[0]=SD_command(CMD8, CMD8_ARG, CMD8_CRC);
00fc86 e0e8      	LDI  R30,LOW(8)
00fc87 93ea      	ST   -Y,R30
                +
00fc88 eaea     +LDI R30 , LOW ( 0x1AA )
00fc89 e0f1     +LDI R31 , HIGH ( 0x1AA )
00fc8a e060     +LDI R22 , BYTE3 ( 0x1AA )
00fc8b e070     +LDI R23 , BYTE4 ( 0x1AA )
                 	__GETD1N 0x1AA
00fc8c 940e fef9 	CALL __PUTPARD1
00fc8e e8a6      	LDI  R26,LOW(134)
00fc8f c005      	RJMP _0x2000007
                 ; 0003 0091 
                 ; 0003 0092     // read response
                 ; 0003 0093     SD_readRes7(res);
                 ; 0003 0094 
                 ; 0003 0095     // deassert chip select
                 ; 0003 0096     SPI_transfer(0xFF);
                 ; 0003 0097     CS_DISABLE();
                 ; 0003 0098     SPI_transfer(0xFF);
                 ; 0003 0099 }
                 ; .FEND
                 ;
                 ;/*
                 ;void SD_readRes3_7(unsigned char *res)
                 ;{
                 ;    // read R1
                 ;    //res[0] = SD_readRes1();
                 ;
                 ;    // if error reading R1, return
                 ;    if(res[0] > 1) return;
                 ;
                 ;    // read remaining bytes
                 ;    res[1] = SPI_transfer(0xFF);
                 ;    res[2] = SPI_transfer(0xFF);
                 ;    res[3] = SPI_transfer(0xFF);
                 ;    res[4] = SPI_transfer(0xFF);
                 ;}
                 ;*/
                 ;
                 ;void SD_readOCR(unsigned char *res)
                 ; 0003 00AD {
                 _SD_readOCR:
                 ; .FSTART _SD_readOCR
                 ; 0003 00AE     // assert chip select
                 ; 0003 00AF     SPI_transfer(0xFF);
00fc90 d1bc      	RCALL SUBOPT_0x1D
                 ;	*res -> Y+0
                 ; 0003 00B0     CS_ENABLE();
                 ; 0003 00B1     //SPI_transfer(0xFF);
                 ; 0003 00B2 
                 ; 0003 00B3     // send CMD58
                 ; 0003 00B4     res[0] = SD_command(CMD58, CMD58_ARG, CMD58_CRC);
00fc91 e3ea      	LDI  R30,LOW(58)
00fc92 93ea      	ST   -Y,R30
00fc93 d0bf      	RCALL SUBOPT_0x1
00fc94 e0a0      	LDI  R26,LOW(0)
                 _0x2000007:
00fc95 df92      	RCALL _SD_command
00fc96 81a8      	LD   R26,Y
00fc97 81b9      	LDD  R27,Y+1
00fc98 93ec      	ST   X,R30
                 ; 0003 00B5 
                 ; 0003 00B6     // read response
                 ; 0003 00B7     //SD_readRes3_7(res);
                 ; 0003 00B8     SD_readRes7(res);
00fc99 dfcb      	RCALL _SD_readRes7
                 ; 0003 00B9 
                 ; 0003 00BA     // deassert chip select
                 ; 0003 00BB     SPI_transfer(0xFF);
00fc9a d1b8      	RCALL SUBOPT_0x1E
                 ; 0003 00BC     CS_DISABLE();
                 ; 0003 00BD     SPI_transfer(0xFF);
                 ; 0003 00BE }
                 _0x2000008:
00fc9b 9622      	ADIW R28,2
00fc9c 9508      	RET
                 ; .FEND
                 ;
                 ;unsigned char SD_sendApp()
                 ; 0003 00C1 {
                 _SD_sendApp:
                 ; .FSTART _SD_sendApp
                 ; 0003 00C2     unsigned char res1;
                 ; 0003 00C3     // assert chip select
                 ; 0003 00C4     SPI_transfer(0xFF);
00fc9d d1aa      	RCALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 00C5     CS_ENABLE();
                 ; 0003 00C6     //SPI_transfer(0xFF);
                 ; 0003 00C7 
                 ; 0003 00C8     // send CMD0
                 ; 0003 00C9     res1 = SD_command(CMD55, CMD55_ARG, CMD55_CRC);
00fc9e e3e7      	LDI  R30,LOW(55)
00fc9f 93ea      	ST   -Y,R30
                +
00fca0 e0e0     +LDI R30 , LOW ( 0x0 )
00fca1 e0f0     +LDI R31 , HIGH ( 0x0 )
00fca2 e060     +LDI R22 , BYTE3 ( 0x0 )
00fca3 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
00fca4 c007      	RJMP _0x2000004
                 ; 0003 00CA 
                 ; 0003 00CB     // read response
                 ; 0003 00CC     //res1 = SD_readRes1();
                 ; 0003 00CD 
                 ; 0003 00CE     // deassert chip select
                 ; 0003 00CF     SPI_transfer(0xFF);
                 ; 0003 00D0     CS_DISABLE();
                 ; 0003 00D1     SPI_transfer(0xFF);
                 ; 0003 00D2 
                 ; 0003 00D3     return res1;
                 ; 0003 00D4 }
                 ; .FEND
                 ;
                 ;unsigned char SD_sendOpCond()
                 ; 0003 00D7 {
                 _SD_sendOpCond:
                 ; .FSTART _SD_sendOpCond
                 ; 0003 00D8     unsigned char res1;
                 ; 0003 00D9     // assert chip select
                 ; 0003 00DA     SPI_transfer(0xFF);
00fca5 d1a2      	RCALL SUBOPT_0x1C
                 ;	res1 -> R17
                 ; 0003 00DB     CS_ENABLE();
                 ; 0003 00DC     //SPI_transfer(0xFF);
                 ; 0003 00DD 
                 ; 0003 00DE     // send CMD0
                 ; 0003 00DF     res1 =  SD_command(ACMD41, ACMD41_ARG, ACMD41_CRC);
00fca6 e2e9      	LDI  R30,LOW(41)
00fca7 93ea      	ST   -Y,R30
                +
00fca8 e0e0     +LDI R30 , LOW ( 0x40000000 )
00fca9 e0f0     +LDI R31 , HIGH ( 0x40000000 )
00fcaa e060     +LDI R22 , BYTE3 ( 0x40000000 )
00fcab e470     +LDI R23 , BYTE4 ( 0x40000000 )
                 	__GETD1N 0x40000000
                 _0x2000004:
00fcac 940e fef9 	CALL __PUTPARD1
00fcae e0a0      	LDI  R26,LOW(0)
                 _0x2000005:
00fcaf df78      	RCALL _SD_command
00fcb0 2f1e      	MOV  R17,R30
                 ; 0003 00E0 
                 ; 0003 00E1     // read response
                 ; 0003 00E2     //res1 = SD_readRes1();
                 ; 0003 00E3 
                 ; 0003 00E4     // deassert chip select
                 ; 0003 00E5     SPI_transfer(0xFF);
00fcb1 d1a1      	RCALL SUBOPT_0x1E
                 ; 0003 00E6     CS_DISABLE();
                 ; 0003 00E7     SPI_transfer(0xFF);
                 ; 0003 00E8 
                 ; 0003 00E9     return res1;
00fcb2 2fe1      	MOV  R30,R17
                 _0x2000006:
00fcb3 9119      	LD   R17,Y+
00fcb4 9508      	RET
                 ; 0003 00EA }
                 ; .FEND
                 ;
                 ;unsigned char SD_init()
                 ; 0003 00ED {
                 _SD_init:
                 ; .FSTART _SD_init
                 ; 0003 00EE     unsigned char res[5], cmdAttempts = 0;
                 ; 0003 00EF 
                 ; 0003 00F0     SD_powerUpSeq();
00fcb5 9725      	SBIW R28,5
00fcb6 931a      	ST   -Y,R17
                 ;	res -> Y+1
                 ;	cmdAttempts -> R17
00fcb7 e010      	LDI  R17,0
00fcb8 df5f      	RCALL _SD_powerUpSeq
                 ; 0003 00F1 
                 ; 0003 00F2     // command card to idle
                 ; 0003 00F3     while((res[0] = SD_goIdleState()) != 0x01)
                 _0x6000E:
00fcb9 dfa5      	RCALL _SD_goIdleState
00fcba 83e9      	STD  Y+1,R30
00fcbb 30e1      	CPI  R30,LOW(0x1)
00fcbc f031      	BREQ _0x60010
                 ; 0003 00F4     {
                 ; 0003 00F5         cmdAttempts++;
00fcbd 5f1f      	SUBI R17,-1
                 ; 0003 00F6         if(cmdAttempts > 100) return SD_ERROR;
00fcbe 3615      	CPI  R17,101
00fcbf f010      	BRLO _0x60011
00fcc0 e0e1      	LDI  R30,LOW(1)
00fcc1 c02e      	RJMP _0x2000002
                 ; 0003 00F7     }
                 _0x60011:
00fcc2 cff6      	RJMP _0x6000E
                 _0x60010:
                 ; 0003 00F8 
                 ; 0003 00F9     // send interface conditions
                 ; 0003 00FA     SD_sendIfCond(res);
00fcc3 01de      	MOVW R26,R28
00fcc4 9611      	ADIW R26,1
00fcc5 dfbf      	RCALL _SD_sendIfCond
                 ; 0003 00FB     if(res[0] != 0x01)
00fcc6 81a9      	LDD  R26,Y+1
00fcc7 30a1      	CPI  R26,LOW(0x1)
00fcc8 f011      	BREQ _0x60012
                 ; 0003 00FC     {
                 ; 0003 00FD         return SD_ERROR;
00fcc9 e0e1      	LDI  R30,LOW(1)
00fcca c025      	RJMP _0x2000002
                 ; 0003 00FE     }
                 ; 0003 00FF 
                 ; 0003 0100     // check echo pattern
                 ; 0003 0101     if(res[4] != 0xAA)
                 _0x60012:
00fccb 81ad      	LDD  R26,Y+5
00fccc 3aaa      	CPI  R26,LOW(0xAA)
00fccd f011      	BREQ _0x60013
                 ; 0003 0102     {
                 ; 0003 0103         return SD_ERROR;
00fcce e0e1      	LDI  R30,LOW(1)
00fccf c020      	RJMP _0x2000002
                 ; 0003 0104     }
                 ; 0003 0105 
                 ; 0003 0106     // attempt to initialize card
                 ; 0003 0107     cmdAttempts = 0;
                 _0x60013:
00fcd0 e010      	LDI  R17,LOW(0)
                 ; 0003 0108     do
                 _0x60015:
                 ; 0003 0109     {
                 ; 0003 010A         if(cmdAttempts > 100) return SD_ERROR;
00fcd1 3615      	CPI  R17,101
00fcd2 f010      	BRLO _0x60017
00fcd3 e0e1      	LDI  R30,LOW(1)
00fcd4 c01b      	RJMP _0x2000002
                 ; 0003 010B 
                 ; 0003 010C         // send app cmd
                 ; 0003 010D         res[0] = SD_sendApp();
                 _0x60017:
00fcd5 dfc7      	RCALL _SD_sendApp
00fcd6 83e9      	STD  Y+1,R30
                 ; 0003 010E 
                 ; 0003 010F         // if no error in response
                 ; 0003 0110         if(res[0] < 2)
00fcd7 81a9      	LDD  R26,Y+1
00fcd8 30a2      	CPI  R26,LOW(0x2)
00fcd9 f410      	BRSH _0x60018
                 ; 0003 0111         {
                 ; 0003 0112             res[0] = SD_sendOpCond();
00fcda dfca      	RCALL _SD_sendOpCond
00fcdb 83e9      	STD  Y+1,R30
                 ; 0003 0113         }
                 ; 0003 0114 
                 ; 0003 0115         // wait
                 ; 0003 0116         if(res[0] != SD_READY)
                 _0x60018:
00fcdc 81e9      	LDD  R30,Y+1
00fcdd 30e0      	CPI  R30,0
00fcde f021      	BREQ _0x60019
                 ; 0003 0117             delay_ms(10);
00fcdf e0aa      	LDI  R26,LOW(10)
00fce0 e0b0      	LDI  R27,0
00fce1 940e fe56 	CALL _delay_ms
                 ; 0003 0118 
                 ; 0003 0119         cmdAttempts++;
                 _0x60019:
00fce3 5f1f      	SUBI R17,-1
                 ; 0003 011A     }
                 ; 0003 011B     while(res[0] != SD_READY);
00fce4 81e9      	LDD  R30,Y+1
00fce5 30e0      	CPI  R30,0
00fce6 f751      	BRNE _0x60015
                 ; 0003 011C 
                 ; 0003 011D     // read OCR
                 ; 0003 011E     SD_readOCR(res);
00fce7 01de      	MOVW R26,R28
00fce8 9611      	ADIW R26,1
00fce9 dfa6      	RCALL _SD_readOCR
                 ; 0003 011F 
                 ; 0003 0120     // check card is ready
                 ; 0003 0121     if(!(res[1] & 0x80)) return SD_ERROR;
00fcea 81ea      	LDD  R30,Y+2
00fceb 78e0      	ANDI R30,LOW(0x80)
00fcec f411      	BRNE _0x6001A
00fced e0e1      	LDI  R30,LOW(1)
00fcee c001      	RJMP _0x2000002
                 ; 0003 0122 
                 ; 0003 0123     return SD_SUCCESS;
                 _0x6001A:
00fcef e0e0      	LDI  R30,LOW(0)
                 _0x2000002:
00fcf0 8118      	LDD  R17,Y+0
                 _0x2000003:
00fcf1 9626      	ADIW R28,6
00fcf2 9508      	RET
                 ; 0003 0124 }
                 ; .FEND
                 ;
                 ;#define CMD17                   17
                 ;#define CMD17_CRC               0x00
                 ;#define SD_MAX_READ_ATTEMPTS    1563
                 ;
                 ;/*******************************************************************************
                 ; Read single 512 byte block
                 ; token = 0xFE - Successful read
                 ; token = 0x0X - Data error
                 ; token = 0xFF - Timeout
                 ;*******************************************************************************/
                 ;unsigned char SD_readSingleBlock(unsigned long addr, unsigned char *buf, unsigned char *token)
                 ; 0003 0131 {
                 _SD_readSingleBlock:
                 ; .FSTART _SD_readSingleBlock
                 ; 0003 0132     unsigned char res1, read;
                 ; 0003 0133     unsigned int i, readAttempts;
                 ; 0003 0134     addr*=512UL;
00fcf3 93ba      	ST   -Y,R27
00fcf4 93aa      	ST   -Y,R26
00fcf5 940e ff0c 	CALL __SAVELOCR6
                 ;	addr -> Y+10
                 ;	*buf -> Y+8
                 ;	*token -> Y+6
                 ;	res1 -> R17
                 ;	read -> R16
                 ;	i -> R18,R19
                 ;	readAttempts -> R20,R21
                +
00fcf7 85ea     +LDD R30 , Y + 10
00fcf8 85fb     +LDD R31 , Y + 10 + 1
00fcf9 856c     +LDD R22 , Y + 10 + 2
00fcfa 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
                +
00fcfb e0a0     +LDI R26 , LOW ( 0x200 )
00fcfc e0b2     +LDI R27 , HIGH ( 0x200 )
00fcfd e080     +LDI R24 , BYTE3 ( 0x200 )
00fcfe e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
00fcff 940e fea7 	CALL __MULD12U
                +
00fd01 87ea     +STD Y + 10 , R30
00fd02 87fb     +STD Y + 10 + 1 , R31
00fd03 876c     +STD Y + 10 + 2 , R22
00fd04 877d     +STD Y + 10 + 3 , R23
                 	__PUTD1S 10
                 ; 0003 0135     // set token to none
                 ; 0003 0136     *token = 0xFF;
00fd05 81ae      	LDD  R26,Y+6
00fd06 81bf      	LDD  R27,Y+6+1
00fd07 efef      	LDI  R30,LOW(255)
00fd08 93ec      	ST   X,R30
                 ; 0003 0137 
                 ; 0003 0138     // assert chip select
                 ; 0003 0139     SPI_transfer(0xFF);
00fd09 efaf      	LDI  R26,LOW(255)
00fd0a df05      	RCALL _SPI_transfer
                 ; 0003 013A     CS_ENABLE();
00fd0b 98c0      	CBI  0x18,0
                 ; 0003 013B     //SPI_transfer(0xFF);
                 ; 0003 013C 
                 ; 0003 013D     // send CMD17
                 ; 0003 013E     res1 = SD_command(CMD17, addr, CMD17_CRC);
00fd0c e1e1      	LDI  R30,LOW(17)
00fd0d 93ea      	ST   -Y,R30
                +
00fd0e 85eb     +LDD R30 , Y + 11
00fd0f 85fc     +LDD R31 , Y + 11 + 1
00fd10 856d     +LDD R22 , Y + 11 + 2
00fd11 857e     +LDD R23 , Y + 11 + 3
                 	__GETD1S 11
00fd12 940e fef9 	CALL __PUTPARD1
00fd14 e0a0      	LDI  R26,LOW(0)
00fd15 df12      	RCALL _SD_command
00fd16 2f1e      	MOV  R17,R30
                 ; 0003 013F 
                 ; 0003 0140     // read R1
                 ; 0003 0141     //res1 = SD_readRes1();
                 ; 0003 0142 
                 ; 0003 0143     // if response received from card
                 ; 0003 0144     if(res1 != 0xFF)
00fd17 3f1f      	CPI  R17,255
00fd18 f169      	BREQ _0x6001B
                 ; 0003 0145     {
                 ; 0003 0146         // wait for a response token (timeout = 100ms)
                 ; 0003 0147         readAttempts = 0;
                +
00fd19 e040     +LDI R20 , LOW ( 0 )
00fd1a e050     +LDI R21 , HIGH ( 0 )
                 	__GETWRN 20,21,0
                 ; 0003 0148         while(++readAttempts != SD_MAX_READ_ATTEMPTS)
                 _0x6001C:
00fd1b 01fa      	MOVW R30,R20
00fd1c 9631      	ADIW R30,1
00fd1d 01af      	MOVW R20,R30
00fd1e 31eb      	CPI  R30,LOW(0x61B)
00fd1f e0a6      	LDI  R26,HIGH(0x61B)
00fd20 07fa      	CPC  R31,R26
00fd21 f029      	BREQ _0x6001E
                 ; 0003 0149             if((read = SPI_transfer(0xFF)) != 0xFF) break;
00fd22 efaf      	LDI  R26,LOW(255)
00fd23 deec      	RCALL _SPI_transfer
00fd24 2f0e      	MOV  R16,R30
00fd25 3fef      	CPI  R30,LOW(0xFF)
00fd26 f3a1      	BREQ _0x6001C
                 ; 0003 014A 
                 ; 0003 014B         // if response token is 0xFE
                 ; 0003 014C         if(read == 0xFE)
                 _0x6001E:
00fd27 3f0e      	CPI  R16,254
00fd28 f4d1      	BRNE _0x60020
                 ; 0003 014D         {
                 ; 0003 014E             // read 512 byte block
                 ; 0003 014F             for(i = 0; i < 512; i++) *buf++ = SPI_transfer(0xFF);
                +
00fd29 e020     +LDI R18 , LOW ( 0 )
00fd2a e030     +LDI R19 , HIGH ( 0 )
                 	__GETWRN 18,19,0
                 _0x60022:
                +
00fd2b 3020     +CPI R18 , LOW ( 512 )
00fd2c e0e2     +LDI R30 , HIGH ( 512 )
00fd2d 073e     +CPC R19 , R30
                 	__CPWRN 18,19,512
00fd2e f480      	BRSH _0x60023
00fd2f 85e8      	LDD  R30,Y+8
00fd30 85f9      	LDD  R31,Y+8+1
00fd31 9631      	ADIW R30,1
00fd32 87e8      	STD  Y+8,R30
00fd33 87f9      	STD  Y+8+1,R31
00fd34 9731      	SBIW R30,1
00fd35 93ff      	PUSH R31
00fd36 93ef      	PUSH R30
00fd37 efaf      	LDI  R26,LOW(255)
00fd38 ded7      	RCALL _SPI_transfer
00fd39 91af      	POP  R26
00fd3a 91bf      	POP  R27
00fd3b 93ec      	ST   X,R30
                +
00fd3c 5f2f     +SUBI R18 , LOW ( - 1 )
00fd3d 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
00fd3e cfec      	RJMP _0x60022
                 _0x60023:
                 ; 0003 0152 SPI_transfer(0xFF);
00fd3f efaf      	LDI  R26,LOW(255)
00fd40 decf      	RCALL _SPI_transfer
                 ; 0003 0153             SPI_transfer(0xFF);
00fd41 efaf      	LDI  R26,LOW(255)
00fd42 decd      	RCALL _SPI_transfer
                 ; 0003 0154         }
                 ; 0003 0155 
                 ; 0003 0156         // set token to card response
                 ; 0003 0157         *token = read;
                 _0x60020:
00fd43 81ae      	LDD  R26,Y+6
00fd44 81bf      	LDD  R27,Y+6+1
00fd45 930c      	ST   X,R16
                 ; 0003 0158     }
                 ; 0003 0159 
                 ; 0003 015A     // deassert chip select
                 ; 0003 015B     SPI_transfer(0xFF);
                 _0x6001B:
00fd46 d10c      	RCALL SUBOPT_0x1E
                 ; 0003 015C     CS_DISABLE();
                 ; 0003 015D     SPI_transfer(0xFF);
                 ; 0003 015E     if(read==0xFE)
00fd47 3f0e      	CPI  R16,254
00fd48 f411      	BRNE _0x60024
                 ; 0003 015F         return res1;
00fd49 2fe1      	MOV  R30,R17
00fd4a c001      	RJMP _0x2000001
                 ; 0003 0160     else
                 _0x60024:
                 ; 0003 0161         return SD_ERROR;
00fd4b e0e1      	LDI  R30,LOW(1)
                 ; 0003 0162 }
                 _0x2000001:
00fd4c 940e ff13 	CALL __LOADLOCR6
00fd4e 962e      	ADIW R28,14
00fd4f 9508      	RET
                 ; .FEND
                 
                 	.DSEG
                 _result:
000515           	.BYTE 0x5
                 _sdBuf:
00051a           	.BYTE 0x200
                 _testBuf:
00071a           	.BYTE 0x100
                 _appStartAdr:
00081a           	.BYTE 0x4
                 _adr:
00081e           	.BYTE 0x4
                 _SectorsPerFat:
000822           	.BYTE 0x4
                 _fat_begin_lba:
000826           	.BYTE 0x4
                 _cluster_begin_lba:
00082a           	.BYTE 0x4
                 _fat_file_adr:
00082e           	.BYTE 0x4
                 _fat_file_next_adr:
000832           	.BYTE 0x4
                 _filesize:
000836           	.BYTE 0x4
                 _readbytes:
00083a           	.BYTE 0x4
                 _bytesChecksum:
00083e           	.BYTE 0x2
                 _checksumCnt:
000840           	.BYTE 0x2
                 _app_pointer:
000842           	.BYTE 0x2
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x0:
00fd50 940e feea 	CALL __GETD1S0
00fd52 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x1:
                +
00fd53 e0e0     +LDI R30 , LOW ( 0x0 )
00fd54 e0f0     +LDI R31 , HIGH ( 0x0 )
00fd55 e060     +LDI R22 , BYTE3 ( 0x0 )
00fd56 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
00fd57 940e fef9 	CALL __PUTPARD1
00fd59 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2:
                +
00fd5a e0a0     +LDI R26 , LOW ( 0x1EF00 )
00fd5b eebf     +LDI R27 , HIGH ( 0x1EF00 )
00fd5c e081     +LDI R24 , BYTE3 ( 0x1EF00 )
00fd5d e090     +LDI R25 , BYTE4 ( 0x1EF00 )
                 	__GETD2N 0x1EF00
00fd5e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3:
00fd5f 940e fefe 	CALL __PUTPARD2
00fd61 940e feef 	CALL __GETD2S0
00fd63 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4:
00fd64 940e feef 	CALL __GETD2S0
00fd66 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:42 WORDS
                 SUBOPT_0x5:
00fd67 e1ea      	LDI  R30,LOW(_sdBuf)
00fd68 e0f5      	LDI  R31,HIGH(_sdBuf)
00fd69 93fa      	ST   -Y,R31
00fd6a 93ea      	ST   -Y,R30
00fd6b e0a9      	LDI  R26,LOW(9)
00fd6c e0b0      	LDI  R27,HIGH(9)
00fd6d df85      	RCALL _SD_readSingleBlock
00fd6e 93e0 0515 	STS  _result,R30
00fd70 30e0      	CPI  R30,0
00fd71 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x6:
00fd72 93fa      	ST   -Y,R31
00fd73 93ea      	ST   -Y,R30
00fd74 e0a4      	LDI  R26,LOW(4)
00fd75 ce6b      	RJMP _buf2num
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x7:
00fd76 93e0 081e 	STS  _adr,R30
00fd78 93f0 081f 	STS  _adr+1,R31
00fd7a 9360 0820 	STS  _adr+2,R22
00fd7c 9370 0821 	STS  _adr+3,R23
00fd7e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
                 SUBOPT_0x8:
00fd7f 91e0 081e 	LDS  R30,_adr
00fd81 91f0 081f 	LDS  R31,_adr+1
00fd83 9160 0820 	LDS  R22,_adr+2
00fd85 9170 0821 	LDS  R23,_adr+3
00fd87 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x9:
00fd88 940e fef9 	CALL __PUTPARD1
00fd8a cfdc      	RJMP SUBOPT_0x5
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0xA:
00fd8b 2de8      	MOV  R30,R8
00fd8c 01d8      	MOVW R26,R16
00fd8d e0f0      	LDI  R31,0
00fd8e 17ae      	CP   R26,R30
00fd8f 07bf      	CPC  R27,R31
00fd90 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0xB:
00fd91 dfed      	RCALL SUBOPT_0x8
00fd92 cff5      	RJMP SUBOPT_0x9
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0xC:
00fd93 93fa      	ST   -Y,R31
00fd94 93ea      	ST   -Y,R30
                +
00fd95 e2a0     +LDI R26 , 32
00fd96 9fa2     +MUL R26 , R18
00fd97 01f0     +MOVW R30 , R0
00fd98 9fa3     +MUL R26 , R19
00fd99 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
00fd9a 5ee6      	SUBI R30,LOW(-_sdBuf)
00fd9b 4ffa      	SBCI R31,HIGH(-_sdBuf)
00fd9c 01df      	MOVW R26,R30
00fd9d de2b      	RCALL _compbuf
                +
00fd9e 93e0 0516+STS _result + ( 1 ) , R30
                 	__PUTB1MN _result,1
00fda0 30e0      	CPI  R30,0
00fda1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0xD:
                +
00fda2 e2a0     +LDI R26 , 32
00fda3 9fa2     +MUL R26 , R18
00fda4 01f0     +MOVW R30 , R0
00fda5 9fa3     +MUL R26 , R19
00fda6 0df0     +ADD R31 , R0
                 	__MULBNWRU 18,19,32
00fda7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xE:
                +
00fda8 5de2     +SUBI R30 , LOW ( - _sdBuf - ( 20 ) )
00fda9 4ffa     +SBCI R31 , HIGH ( - _sdBuf - ( 20 ) )
                 	__ADDW1MN _sdBuf,20
00fdaa 81e0      	LD   R30,Z
00fdab e0f0      	LDI  R31,0
00fdac 940e fe9a 	CALL __CWD1
00fdae 940e fe95 	CALL __LSLD16
00fdb0 93e0 082e 	STS  _fat_file_adr,R30
00fdb2 93f0 082f 	STS  _fat_file_adr+1,R31
00fdb4 9360 0830 	STS  _fat_file_adr+2,R22
00fdb6 9370 0831 	STS  _fat_file_adr+3,R23
00fdb8 cfe9      	RJMP SUBOPT_0xD
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:19 WORDS
                 SUBOPT_0xF:
                +
00fdb9 5cec     +SUBI R30 , LOW ( - _sdBuf - ( 26 ) )
00fdba 4ffa     +SBCI R31 , HIGH ( - _sdBuf - ( 26 ) )
                 	__ADDW1MN _sdBuf,26
00fdbb 81e0      	LD   R30,Z
00fdbc e0f0      	LDI  R31,0
00fdbd 940e fe9a 	CALL __CWD1
00fdbf 91a0 082e 	LDS  R26,_fat_file_adr
00fdc1 91b0 082f 	LDS  R27,_fat_file_adr+1
00fdc3 9180 0830 	LDS  R24,_fat_file_adr+2
00fdc5 9190 0831 	LDS  R25,_fat_file_adr+3
00fdc7 940e fe6a 	CALL __ORD12
00fdc9 93e0 082e 	STS  _fat_file_adr,R30
00fdcb 93f0 082f 	STS  _fat_file_adr+1,R31
00fdcd 9360 0830 	STS  _fat_file_adr+2,R22
00fdcf 9370 0831 	STS  _fat_file_adr+3,R23
00fdd1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x10:
00fdd2 e1ae      	LDI  R26,LOW(_adr)
00fdd3 e0b8      	LDI  R27,HIGH(_adr)
00fdd4 940e fee0 	CALL __GETD1P_INC
                +
00fdd6 5fef     +SUBI R30 , LOW ( - 1 )
00fdd7 4fff     +SBCI R31 , HIGH ( - 1 )
00fdd8 4f6f     +SBCI R22 , BYTE3 ( - 1 )
00fdd9 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
00fdda 940e fee5 	CALL __PUTDP1_DEC
00fddc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:29 WORDS
                 SUBOPT_0x11:
00fddd 91e0 082e 	LDS  R30,_fat_file_adr
00fddf 91f0 082f 	LDS  R31,_fat_file_adr+1
00fde1 9160 0830 	LDS  R22,_fat_file_adr+2
00fde3 9170 0831 	LDS  R23,_fat_file_adr+3
                +
00fde5 50e2     +SUBI R30 , LOW ( 2 )
00fde6 40f0     +SBCI R31 , HIGH ( 2 )
00fde7 4060     +SBCI R22 , BYTE3 ( 2 )
00fde8 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
00fde9 01df      	MOVW R26,R30
00fdea 01cb      	MOVW R24,R22
00fdeb 2de8      	MOV  R30,R8
00fdec e0f0      	LDI  R31,0
00fded 940e fe9a 	CALL __CWD1
00fdef 940e fea7 	CALL __MULD12U
00fdf1 91a0 082a 	LDS  R26,_cluster_begin_lba
00fdf3 91b0 082b 	LDS  R27,_cluster_begin_lba+1
00fdf5 9180 082c 	LDS  R24,_cluster_begin_lba+2
00fdf7 9190 082d 	LDS  R25,_cluster_begin_lba+3
00fdf9 940e fe60 	CALL __ADDD12
00fdfb df7a      	RCALL SUBOPT_0x7
                +
00fdfc e000     +LDI R16 , LOW ( 0 )
00fdfd e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
00fdfe 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x12:
                +
00fdff 3faf     +CPI R26 , LOW ( 0xFFFFFFF )
00fe00 efef     +LDI R30 , HIGH ( 0xFFFFFFF )
00fe01 07be     +CPC R27 , R30
00fe02 efef     +LDI R30 , BYTE3 ( 0xFFFFFFF )
00fe03 078e     +CPC R24 , R30
00fe04 e0ef     +LDI R30 , BYTE4 ( 0xFFFFFFF )
00fe05 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFFFFF
00fe06 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x13:
00fe07 e1aa      	LDI  R26,LOW(_sdBuf)
00fe08 e0b5      	LDI  R27,HIGH(_sdBuf)
00fe09 0fa2      	ADD  R26,R18
00fe0a 1fb3      	ADC  R27,R19
00fe0b 91ec      	LD   R30,X
00fe0c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x14:
00fe0d 91a0 083a 	LDS  R26,_readbytes
00fe0f 91b0 083b 	LDS  R27,_readbytes+1
00fe11 9180 083c 	LDS  R24,_readbytes+2
00fe13 9190 083d 	LDS  R25,_readbytes+3
00fe15 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x15:
00fe16 91e0 081a 	LDS  R30,_appStartAdr
00fe18 91f0 081b 	LDS  R31,_appStartAdr+1
00fe1a 9160 081c 	LDS  R22,_appStartAdr+2
00fe1c 9170 081d 	LDS  R23,_appStartAdr+3
00fe1e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x16:
00fe1f efa4      	LDI  R26,LOW(500)
00fe20 e0b1      	LDI  R27,HIGH(500)
00fe21 940c fe56 	JMP  _delay_ms
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
                 SUBOPT_0x17:
00fe23 93e0 081a 	STS  _appStartAdr,R30
00fe25 93f0 081b 	STS  _appStartAdr+1,R31
00fe27 9360 081c 	STS  _appStartAdr+2,R22
00fe29 9370 081d 	STS  _appStartAdr+3,R23
00fe2b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x18:
00fe2c 91a0 081a 	LDS  R26,_appStartAdr
00fe2e 91b0 081b 	LDS  R27,_appStartAdr+1
00fe30 9180 081c 	LDS  R24,_appStartAdr+2
00fe32 9190 081d 	LDS  R25,_appStartAdr+3
00fe34 940e fe6a 	CALL __ORD12
00fe36 cfec      	RJMP SUBOPT_0x17
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x19:
                +
00fe37 e0e0     +LDI R30 , LOW ( 0x1EF00 )
00fe38 eeff     +LDI R31 , HIGH ( 0x1EF00 )
00fe39 e061     +LDI R22 , BYTE3 ( 0x1EF00 )
00fe3a e070     +LDI R23 , BYTE4 ( 0x1EF00 )
                 	__GETD1N 0x1EF00
00fe3b 940e fef9 	CALL __PUTPARD1
00fe3d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1A:
00fe3e 9ac0      	SBI  0x18,0
00fe3f efaf      	LDI  R26,LOW(255)
00fe40 cdcf      	RJMP _SPI_transfer
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1B:
00fe41 2fae      	MOV  R26,R30
00fe42 ddcd      	RCALL _SPI_transfer
                +
00fe43 81ab     +LDD R26 , Y + 3
00fe44 81bc     +LDD R27 , Y + 3 + 1
00fe45 818d     +LDD R24 , Y + 3 + 2
00fe46 819e     +LDD R25 , Y + 3 + 3
                 	__GETD2S 3
00fe47 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1C:
00fe48 931a      	ST   -Y,R17
00fe49 efaf      	LDI  R26,LOW(255)
00fe4a ddc5      	RCALL _SPI_transfer
00fe4b 98c0      	CBI  0x18,0
00fe4c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x1D:
00fe4d 93ba      	ST   -Y,R27
00fe4e 93aa      	ST   -Y,R26
00fe4f efaf      	LDI  R26,LOW(255)
00fe50 ddbf      	RCALL _SPI_transfer
00fe51 98c0      	CBI  0x18,0
00fe52 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x1E:
00fe53 efaf      	LDI  R26,LOW(255)
00fe54 ddbb      	RCALL _SPI_transfer
00fe55 cfe8      	RJMP SUBOPT_0x1A
                 
                 
                 	.CSEG
                 _delay_ms:
00fe56 9610      	adiw r26,0
00fe57 f039      	breq __delay_ms1
                 __delay_ms0:
                +
00fe58 ed80     +LDI R24 , LOW ( 0x7D0 )
00fe59 e097     +LDI R25 , HIGH ( 0x7D0 )
                +__DELAY_USW_LOOP :
00fe5a 9701     +SBIW R24 , 1
00fe5b f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x7D0
00fe5c 95a8      	wdr
00fe5d 9711      	sbiw r26,1
00fe5e f7c9      	brne __delay_ms0
                 __delay_ms1:
00fe5f 9508      	ret
                 
                 __ADDD12:
00fe60 0fea      	ADD  R30,R26
00fe61 1ffb      	ADC  R31,R27
00fe62 1f68      	ADC  R22,R24
00fe63 1f79      	ADC  R23,R25
00fe64 9508      	RET
                 
                 __ADDD21:
00fe65 0fae      	ADD  R26,R30
00fe66 1fbf      	ADC  R27,R31
00fe67 1f86      	ADC  R24,R22
00fe68 1f97      	ADC  R25,R23
00fe69 9508      	RET
                 
                 __ORD12:
00fe6a 2bea      	OR   R30,R26
00fe6b 2bfb      	OR   R31,R27
00fe6c 2b68      	OR   R22,R24
00fe6d 2b79      	OR   R23,R25
00fe6e 9508      	RET
                 
                 __ANEGW1:
00fe6f 95f1      	NEG  R31
00fe70 95e1      	NEG  R30
00fe71 40f0      	SBCI R31,0
00fe72 9508      	RET
                 
                 __LSLD12:
00fe73 23ee      	TST  R30
00fe74 2e0e      	MOV  R0,R30
00fe75 01fd      	MOVW R30,R26
00fe76 01bc      	MOVW R22,R24
00fe77 f031      	BREQ __LSLD12R
                 __LSLD12L:
00fe78 0fee      	LSL  R30
00fe79 1fff      	ROL  R31
00fe7a 1f66      	ROL  R22
00fe7b 1f77      	ROL  R23
00fe7c 940a      	DEC  R0
00fe7d f7d1      	BRNE __LSLD12L
                 __LSLD12R:
00fe7e 9508      	RET
                 
                 __LSRD12:
00fe7f 23ee      	TST  R30
00fe80 2e0e      	MOV  R0,R30
00fe81 01fd      	MOVW R30,R26
00fe82 01bc      	MOVW R22,R24
00fe83 f031      	BREQ __LSRD12R
                 __LSRD12L:
00fe84 9576      	LSR  R23
00fe85 9567      	ROR  R22
00fe86 95f7      	ROR  R31
00fe87 95e7      	ROR  R30
00fe88 940a      	DEC  R0
00fe89 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
00fe8a 9508      	RET
                 
                 __LSLD1:
00fe8b 0fee      	LSL  R30
00fe8c 1fff      	ROL  R31
00fe8d 1f66      	ROL  R22
00fe8e 1f77      	ROL  R23
00fe8f 9508      	RET
                 
                 __LSRD16:
00fe90 2fe6      	MOV  R30,R22
00fe91 2ff7      	MOV  R31,R23
00fe92 e060      	LDI  R22,0
00fe93 e070      	LDI  R23,0
00fe94 9508      	RET
                 
                 __LSLD16:
00fe95 2f6e      	MOV  R22,R30
00fe96 2f7f      	MOV  R23,R31
00fe97 e0e0      	LDI  R30,0
00fe98 e0f0      	LDI  R31,0
00fe99 9508      	RET
                 
                 __CWD1:
00fe9a 2f6f      	MOV  R22,R31
00fe9b 0f66      	ADD  R22,R22
00fe9c 0b66      	SBC  R22,R22
00fe9d 2f76      	MOV  R23,R22
00fe9e 9508      	RET
                 
                 __MULW12U:
00fe9f 9ffa      	MUL  R31,R26
00fea0 2df0      	MOV  R31,R0
00fea1 9feb      	MUL  R30,R27
00fea2 0df0      	ADD  R31,R0
00fea3 9fea      	MUL  R30,R26
00fea4 2de0      	MOV  R30,R0
00fea5 0df1      	ADD  R31,R1
00fea6 9508      	RET
                 
                 __MULD12U:
00fea7 9f7a      	MUL  R23,R26
00fea8 2d70      	MOV  R23,R0
00fea9 9f6b      	MUL  R22,R27
00feaa 0d70      	ADD  R23,R0
00feab 9ff8      	MUL  R31,R24
00feac 0d70      	ADD  R23,R0
00fead 9fe9      	MUL  R30,R25
00feae 0d70      	ADD  R23,R0
00feaf 9f6a      	MUL  R22,R26
00feb0 2d60      	MOV  R22,R0
00feb1 0d71      	ADD  R23,R1
00feb2 9ffb      	MUL  R31,R27
00feb3 0d60      	ADD  R22,R0
00feb4 1d71      	ADC  R23,R1
00feb5 9fe8      	MUL  R30,R24
00feb6 0d60      	ADD  R22,R0
00feb7 1d71      	ADC  R23,R1
00feb8 2788      	CLR  R24
00feb9 9ffa      	MUL  R31,R26
00feba 2df0      	MOV  R31,R0
00febb 0d61      	ADD  R22,R1
00febc 1f78      	ADC  R23,R24
00febd 9feb      	MUL  R30,R27
00febe 0df0      	ADD  R31,R0
00febf 1d61      	ADC  R22,R1
00fec0 1f78      	ADC  R23,R24
00fec1 9fea      	MUL  R30,R26
00fec2 2de0      	MOV  R30,R0
00fec3 0df1      	ADD  R31,R1
00fec4 1f68      	ADC  R22,R24
00fec5 1f78      	ADC  R23,R24
00fec6 9508      	RET
                 
                 __MULB1W2U:
00fec7 2f6e      	MOV  R22,R30
00fec8 9f6a      	MUL  R22,R26
00fec9 01f0      	MOVW R30,R0
00feca 9f6b      	MUL  R22,R27
00fecb 0df0      	ADD  R31,R0
00fecc 9508      	RET
                 
                 __MULW12:
00fecd d004      	RCALL __CHKSIGNW
00fece dfd0      	RCALL __MULW12U
00fecf f40e      	BRTC __MULW121
00fed0 df9e      	RCALL __ANEGW1
                 __MULW121:
00fed1 9508      	RET
                 
                 __CHKSIGNW:
00fed2 94e8      	CLT
00fed3 fff7      	SBRS R31,7
00fed4 c002      	RJMP __CHKSW1
00fed5 df99      	RCALL __ANEGW1
00fed6 9468      	SET
                 __CHKSW1:
00fed7 ffb7      	SBRS R27,7
00fed8 c006      	RJMP __CHKSW2
00fed9 95a0      	COM  R26
00feda 95b0      	COM  R27
00fedb 9611      	ADIW R26,1
00fedc f800      	BLD  R0,0
00fedd 9403      	INC  R0
00fede fa00      	BST  R0,0
                 __CHKSW2:
00fedf 9508      	RET
                 
                 __GETD1P_INC:
00fee0 91ed      	LD   R30,X+
00fee1 91fd      	LD   R31,X+
00fee2 916d      	LD   R22,X+
00fee3 917d      	LD   R23,X+
00fee4 9508      	RET
                 
                 __PUTDP1_DEC:
00fee5 937e      	ST   -X,R23
00fee6 936e      	ST   -X,R22
00fee7 93fe      	ST   -X,R31
00fee8 93ee      	ST   -X,R30
00fee9 9508      	RET
                 
                 __GETD1S0:
00feea 81e8      	LD   R30,Y
00feeb 81f9      	LDD  R31,Y+1
00feec 816a      	LDD  R22,Y+2
00feed 817b      	LDD  R23,Y+3
00feee 9508      	RET
                 
                 __GETD2S0:
00feef 81a8      	LD   R26,Y
00fef0 81b9      	LDD  R27,Y+1
00fef1 818a      	LDD  R24,Y+2
00fef2 819b      	LDD  R25,Y+3
00fef3 9508      	RET
                 
                 __PUTD1S0:
00fef4 83e8      	ST   Y,R30
00fef5 83f9      	STD  Y+1,R31
00fef6 836a      	STD  Y+2,R22
00fef7 837b      	STD  Y+3,R23
00fef8 9508      	RET
                 
                 __PUTPARD1:
00fef9 937a      	ST   -Y,R23
00fefa 936a      	ST   -Y,R22
00fefb 93fa      	ST   -Y,R31
00fefc 93ea      	ST   -Y,R30
00fefd 9508      	RET
                 
                 __PUTPARD2:
00fefe 939a      	ST   -Y,R25
00feff 938a      	ST   -Y,R24
00ff00 93ba      	ST   -Y,R27
00ff01 93aa      	ST   -Y,R26
00ff02 9508      	RET
                 
                 __CPD20:
00ff03 9710      	SBIW R26,0
00ff04 4080      	SBCI R24,0
00ff05 4090      	SBCI R25,0
00ff06 9508      	RET
                 
                 __CPD21:
00ff07 17ae      	CP   R26,R30
00ff08 07bf      	CPC  R27,R31
00ff09 0786      	CPC  R24,R22
00ff0a 0797      	CPC  R25,R23
00ff0b 9508      	RET
                 
                 __SAVELOCR6:
00ff0c 935a      	ST   -Y,R21
                 __SAVELOCR5:
00ff0d 934a      	ST   -Y,R20
                 __SAVELOCR4:
00ff0e 933a      	ST   -Y,R19
                 __SAVELOCR3:
00ff0f 932a      	ST   -Y,R18
                 __SAVELOCR2:
00ff10 931a      	ST   -Y,R17
00ff11 930a      	ST   -Y,R16
00ff12 9508      	RET
                 
                 __LOADLOCR6:
00ff13 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
00ff14 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
00ff15 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
00ff16 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
00ff17 8119      	LDD  R17,Y+1
00ff18 8108      	LD   R16,Y
00ff19 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  41 r1 :  10 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   3 r9 :   0 r10:   0 r11:   4 r12:   5 r13:   2 r14:   0 r15:   0 
r16:  26 r17:  39 r18:  24 r19:  22 r20:   5 r21:   3 r22: 104 r23:  64 
r24:  44 r25:  28 r26: 153 r27:  80 r28:  15 r29:   5 r30: 373 r31: 128 
x  :  30 y  : 181 z  :  13 
Registers used: 25 out of 35 (71.4%)

ATmega128 instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  20 add   :  24 
adiw  :  19 and   :   0 andi  :  21 asr   :   0 bclr  :   0 bld   :   1 
brbc  :   0 brbs  :   0 brcc  :   0 brcs  :   0 break :   0 breq  :  30 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :   8 
brlt  :   0 brmi  :   0 brne  :  34 brpl  :   0 brsh  :  14 brtc  :   1 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   1 call  :  94 
cbi   :  11 cbr   :   0 clc   :   0 clh   :   0 cli   :   2 cln   :   0 
clr   :  12 cls   :   0 clt   :   1 clv   :   0 clz   :   0 com   :   2 
cp    :   5 cpc   :  25 cpi   :  39 cpse  :   0 dec   :   3 des   :   0 
elpm  :  10 eor   :   1 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   1 
ijmp  :   0 in    :   5 inc   :   2 jmp   :  48 ld    :  23 ldd   :  99 
ldi   : 209 lds   :  96 lpm   :   0 lsl   :   3 lsr   :   1 mov   :  34 
movw  :  35 mul   :  19 muls  :   0 mulsu :   0 neg   :   2 nop   :   0 
or    :  11 ori   :   2 out   :  19 pop   :   4 push  :   4 rcall : 100 
ret   :  64 reti  :   0 rjmp  :  57 rol   :   8 ror   :   3 sbc   :   1 
sbci  :  36 sbi   :   5 sbic  :   1 sbis  :   1 sbiw  :  11 sbr   :   0 
sbrc  :   0 sbrs  :   2 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   0 
spm   :  18 st    :  73 std   :  19 sts   :  70 sub   :   0 subi  :  27 
swap  :   0 tst   :   2 wdr   :   1 
Instructions used: 62 out of 117 (53.0%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fe34   3588     52   3640  131072   2.8%
[.dseg] 0x000100 0x000844      0    836    836    4096  20.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 10 warnings
