// This file has been prepared for Doxygen automatic documentation generation.
/*! \file ********************************************************************
*
* Atmel Corporation
*
* - File              : Self_programming_main.c
* - Compiler          : IAR EWAVR 2.28a / 3.10c and newer
*
* - Support mail      : avr@atmel.com
*
* - Supported devices : This example is written for ATmega128.
*
* - AppNote           : AVR106 - C functions for reading and writing
*                       to flash memory.
*
* - Description       : The file contains an example program using the Flash R/W
*                       functions provided with the files Self_programming.h /
*                       Self_programming.c . The program should be compiled using
*                       a linker file (*.xcl) that is configured to place the
*                       entire program code into the Boot section of the Flash memory.
*                       Please refer to the application note document for more
*                       information.
*
* $Revision: 2.0 $
* $Date: Wednesday, January 18, 2006 15:18:52 UTC $
*
*****************************************************************************/
#include <io.h>
#include <delay.h>
#include "flash.h"
#include "Self_programming.h"
//#include <ff.h>
/* printf */
#include <stdio.h>
#include <string.h>

#include "spi_sdcard.h"

#define SDBUF_SIZE  512
#define PAGES_PER_SDBUF (SDBUF_SIZE/PAGESIZE)

/* MMC/SD/SD HC card support */
//#include <sdcard.h>

/* Timer1 overflow interrupt frequency [Hz] */
#define T1_OVF_FREQ 100
/* Timer1 clock prescaler value */
#define T1_PRESC 1024L
/* Timer1 initialization value after overflow */
#define T1_INIT (0x10000L-(_MCU_CLOCK_FREQUENCY_/(T1_PRESC*T1_OVF_FREQ)))

/* 100Hz timer interrupt generated by ATmega128 Timer1 overflow */
interrupt [TIM1_OVF] void timer_comp_isr(void)
{
/* re-initialize Timer1 */
TCNT1H=T1_INIT>>8;
TCNT1L=T1_INIT&0xFF;
/* card access low level timing function */
disk_timerproc();
}

unsigned char result[5], sdBuf[SDBUF_SIZE], testBuf[PAGESIZE], token, SectorsPerCluster, pagesCnt;
unsigned long appStartAdr,adr,SectorsPerFat,fat_begin_lba;
unsigned long cluster_begin_lba,root_dir_first_cluster,fat_file_adr,fat_file_next_adr,filesize,readbytes;
unsigned int appPages,bytesChecksum,checksumCnt;
//(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
//(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);
//(unsigned char)sectors_per_cluster = BPB_SecPerClus;
//(unsigned long)root_dir_first_cluster = BPB_RootClus;
void testWrite();
void errorSD(unsigned char err);
unsigned long buf2num(unsigned char *buf,unsigned char len);
unsigned char compbuf(const unsigned char *src,unsigned char *dest);
void (*app_pointer)(void) = (void(*)(void))0x0000;

/* error message list */
flash char * flash error_msg[]=
{
"", /* not used */
"FR_DISK_ERR",
"FR_INT_ERR",
"FR_INT_ERR",
"FR_NOT_READY",
"FR_NO_FILE",
"FR_NO_PATH",
"FR_INVALID_NAME",
"FR_DENIED",
"FR_EXIST",
"FR_INVALID_OBJECT",
"FR_WRITE_PROTECTED",
"FR_INVALID_DRIVE",
"FR_NOT_ENABLED",
"FR_NO_FILESYSTEM",
"FR_MKFS_ABORTED",
"FR_TIMEOUT"
};


/* display error message and stop */
void error(FRESULT res)
{
if ((res>=FR_DISK_ERR) && (res<=FR_TIMEOUT))
   printf("ERROR: %p\r\n",error_msg[res]);
/* stop here */
while(1);
}

/* will hold file/directory information returned by f_readdir */
FILINFO file_info;

/* recursively scan directory entries and display them */
FRESULT directory_scan(char *path)
{
/* will hold the directory information */
DIR directory;
/* FAT function result */
FRESULT res;
int i;


if ((res=f_opendir(&directory,path))==FR_OK)
   {
   while (((res=f_readdir(&directory,&file_info))==FR_OK) &&
         file_info.fname[0])
         {
         /* display file/directory name and associated information */
         printf("%c%c%c%c%c %02u/%02u/%u %02u:%02u:%02u %9lu"                 "  %s/%s\r\n",
                (file_info.fattrib & AM_DIR) ? 'D' : '-',
                (file_info.fattrib & AM_RDO) ? 'R' : '-',
                (file_info.fattrib & AM_HID) ? 'H' : '-',
                (file_info.fattrib & AM_SYS) ? 'S' : '-',
                (file_info.fattrib & AM_ARC) ? 'A' : '-',
                file_info.fdate & 0x1F,(file_info.fdate >> 5) & 0xF,
                (file_info.fdate >> 9)+1980,
                file_info.ftime >> 11,(file_info.ftime >> 5) & 0x3F,
                (file_info.ftime & 0x1F) << 1,
                file_info.fsize,path,file_info.fname);
         if (file_info.fattrib & AM_DIR)
            {
            /* its a subdirectory */
            /* make sure to skip past "." and ".." when recursing */
            if (file_info.fname[0]!='.')
               {
               i=strlen(path);
               /* append the subdirectory name to the path */
               if (path[i-1]!='/') strcatf(path,"/");
               strcat(path,file_info.fname);
               /* scan subdirectory */
               res=directory_scan(path);
               /* restore the old path name */
               path[i]=0;
               /* remove any eventual '/' from the end of the path */
               --i;
               if (path[i]=='/') path[i]=0;
               /* stop if an error occured */
               if (res!=FR_OK) break;
               }
            }
          }
   }
return res;
}


void main( void ){

  unsigned int i,j;
  
  /* FAT function result */
FRESULT res;
/* will hold the information for logical drive 0: */
FATFS fat;
/* pointer to the FATFS type structure */
//FATFS *pfat;
/* will hold the file information */
FIL file;
/* number of free clusters on logical drive 0:*/
unsigned long free_clusters;
/* number of free kbytes on logical drive 0: */
unsigned long free_kbytes;
/* root directory path for logical drive 0: */
char path[]="0:/0/FLASH.DAT";
char dirpath[]="0:/";

/* number of bytes written/read to the file */
unsigned int nbytes;
/* file read buffer */
char buffer[256];
unsigned char disk_status;
unsigned int sector_size;
unsigned long int sector_count;

/* initialize Timer1 overflow interrupts in Mode 0 (Normal) */
TCCR1A=0x00;
/* clkio/1024 */
TCCR1B=(1<<CS12)|(1<<CS10);
/* timer overflow interrupts will occur with 100Hz frequency */
TCNT1H=T1_INIT>>8;
TCNT1L=T1_INIT&0xFF;
/* enable Timer1 overflow interrupt */
TIMSK=1<<TOIE1;

/* globally enable interrupts */
#asm("sei")

/* initialize SPI interface and card driver */
//disk_status=disk_initialize(0);

/* point to the FATFS structure that holds
information for the logical drive 0: */
//pfat=&fat;
/* mount logical drive 0: */
if ((res=f_mount(0,&fat))==FR_OK)
   printf("Logical drive 0: mounted OK\r\n");
else
   /* an error occured, display it and stop */
   error(res);
/* repeateadly read directory entries and display them */
//if ((res=directory_scan(dirpath))!=FR_OK)
   /* if an error occured, display it and stop */
   //error(res);
/* open the file in read mode */
if ((res=f_open(&file,path,FA_READ))==FR_OK)
   printf("File %s opened OK\r\n",path);
else
   /* an error occured, display it and stop */
   error(res);
/* read and display the file's content.
   make sure to leave space for a NULL terminator
   in the buffer, so maximum sizeof(buffer)-1 bytes can be read */
if ((res=f_read(&file,buffer,sizeof(buffer)-1,&nbytes))==FR_OK)
   {
   printf("%u bytes read\r\n",nbytes);
   /* NULL terminate the char string in the buffer */
   buffer[nbytes+1]=NULL;
   /* display the buffer contents */
   printf("Read text: \"%s\"\r\n",buffer);
   }
else
   /* an error occured, display it and stop */
   error(res);


/* close the file */
if ((res=f_close(&file))==FR_OK)
   printf("File %s closed OK\r\n",path);
else
   /* an error occured, display it and stop */
   error(res);


/* repeateadly read directory entries and display them */
//if ((res=directory_scan(path))!=FR_OK)
   /* if an error occured, display it and stop */
//   error(res);


  DDRC=0xFF;
  PORTC=0xFF;
  /*
    do
    {
      PORTC.6=0;
      delay_ms(500);
      PORTC.6=1;
      delay_ms(500);
    }while(1);
  */
  //init SD
  if((result[0]=SD_init())!=SD_SUCCESS)
    errorSD(0);
  
  // read MBR get FAT start sector
  if((result[0]=SD_readSingleBlock(0, sdBuf, &token))!=SD_SUCCESS)
    errorSD(1);  
    
  adr=buf2num(&sdBuf[445+9],4);//FAT start sector. 1 sector = 512 bytes  
  
  //load and read FAT ID (1st) sector. Get FAT info. Secors per Cluster and etc..
  if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS){
    errorSD(2);
  }  

  SectorsPerCluster=sdBuf[0x0D];// 8 sectors per cluster
  SectorsPerFat=buf2num(&sdBuf[0x24],4); // 0xF10 for test sdcard
  
  //read the FAT fils/directories info from Root Directory cluster (usually 2),Number_of_Reserved_Sectors (usually 0x20). Looking for Folder '0' and clucter of FLASH.DAT file
  //(unsigned long)fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
  fat_begin_lba=adr+0x20;//first sector of FAT data
  //(unsigned long)cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);
  //Number_of_FATs always 2. Offset 0x10 8bit
  cluster_begin_lba=fat_begin_lba+(2*SectorsPerFat);//number of sector where data begin
  //read root dir (sector 2 but always offset 2 too then 0) to find folder 0 FAT reference. and find Flash.dat sector
  //lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
  adr=cluster_begin_lba +(2-2)*SectorsPerCluster;
  //adr*=512UL;
  result[1]=0;
  for(i=0;i<SectorsPerCluster;i++)
  {
      if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
        errorSD(3);  
      for(j=0;j<(16);j++)
      {
           if((result[1]=compbuf("0          ",&sdBuf[j*32]))!=0)
           {
                break;
           }
      }
      if(result[1]!=0)
      {
        fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
        fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
        break;
      }
      else
        adr++;
  }
  adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
  for(i=0;i<SectorsPerCluster;i++)
  {
      if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
        errorSD(4);  
      for(j=0;j<(16);j++)
      {
           if((result[1]=compbuf("FLASH   ",&sdBuf[j*32]))!=0)
           {
                break;
           }
      }
      if(result[1]!=0)
      {
        //read 1st number of cluster where data placed 
        fat_file_adr =(unsigned long)sdBuf[j*32+0x14]<<16;
        fat_file_adr|=(unsigned long)sdBuf[j*32+0x1A];
        filesize = buf2num(&sdBuf[j*32+0x1C],8);
        break;
      }
      else
        adr++;
  }
  
  //check FAT for chain of clusters to read
  readbytes=0;
  while(fat_file_adr != 0x0FFFFFFFUL)
  {
    //read where next cluster from FAT, check that not EOF
    if((result[0]=SD_readSingleBlock(fat_begin_lba, sdBuf, &token))!=SD_SUCCESS)
        errorSD(5);
    fat_file_next_adr=buf2num(&sdBuf[fat_file_adr*4],4);
    
    adr=cluster_begin_lba +(fat_file_adr-2)*SectorsPerCluster;
    for(i=0;i<SectorsPerCluster;i++)
    {             
        //read data from next sector of file cluster
        if((result[0]=SD_readSingleBlock(adr, sdBuf, &token))!=SD_SUCCESS)
            errorSD(6);
        //address 2000 = start adr flash app 3 bytes, flash pages 2 bytes, checksum 2 bytes
        //app bytes starts from 2048, roll 0x88
        for(j=0;j<512;j++)
        {
            sdBuf[j]=(sdBuf[j]<<1)|(sdBuf[j]>>7);  //ROL
            sdBuf[j]^=0x88;  //XOR
            checksumCnt+=sdBuf[j];
        }
        readbytes+=512;
        //read app data
        if(readbytes>2048)
        {
           for(pagesCnt=0;pagesCnt<PAGES_PER_SDBUF;pagesCnt++)
           {
               if(WriteFlashPage(appStartAdr, &sdBuf[pagesCnt*PAGESIZE])==0)
               {
                    //while(1)
                    do
                    {
                      PORTC.6=0;
                      delay_ms(500);
                      PORTC.6=1;
                      delay_ms(500);
                    }while(1);
               }
               appStartAdr+=PAGESIZE;
               appPages--;
               if(appPages==0)
               {
                    app_pointer();
                    do
                    {
                      PORTC.5=0;
                      delay_ms(500);
                      PORTC.5=1;
                      delay_ms(500);
                    }while(1); 
               }
           }      
        }
        //read app start adr, num of pages, checksum
        else if(readbytes>=2000)//Offset=512-48=464
        {
           appStartAdr=(unsigned long)sdBuf[464]<<16;
           appStartAdr|=(unsigned long)sdBuf[465]<<8;
           appStartAdr|=(unsigned long)sdBuf[466];
           appPages=(unsigned int)sdBuf[467]<<8;
           appPages|=(unsigned int)sdBuf[468];
           bytesChecksum=(unsigned int)sdBuf[469]<<8;
           bytesChecksum|=(unsigned int)sdBuf[470];
           checksumCnt=0;
        }
        if(fat_file_next_adr == 0x0FFFFFFFUL)
            if(readbytes >= filesize)
            {
                break;
            }
            else
            {
                
                if(  WriteFlashPage(0x1EF00, sdBuf))//;     // Writes testbuffer1 to Flash page 2
                    PORTC.5=0;                                          // Function returns TRUE
                if(  ReadFlashPage (0x1EF00, testBuf))//;      // Reads back Flash page 2 to TestBuffer2
                    PORTC.6=0;
            }
            
        adr++;              
    }
    fat_file_adr = fat_file_next_adr;        
  }  
  
  
  while(1);
  //static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
  //if(PORTA==0x55)
    //testWrite();                                          // Returns TRUE
  //__AddrToZ24WordToR1R0ByteToSPMCR_SPM_F(0,0);
  //__AddrToZ24ByteToSPMCR_SPM_W((void flash *)0);
  /*
  unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
  unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                                            // code stack
  int index;

  DDRC=0xFF;
  PORTC=0xFF;
  //DDRC=0x00;
  //PORTC=0x00;
  //MCUCR |= (1<<IVSEL);
                        // Move interrupt vectors to boot
  //RecoverFlash();
  
  dospm();
  
  for(index=0; index<PAGESIZE; index++){
    testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
  }
  PORTC.4=0;
  //for(;;){
  if(  WriteFlashPage(0x1000, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
    PORTC.5=0;                                          // Function returns TRUE
  if(  ReadFlashPage(0x1000, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
    PORTC.6=0;                                          // Function returns TRUE
  if(  WriteFlashByte(0x1004, 0x38))//;            // Writes 0x38 to byte address 0x204
    PORTC.5=0;                                          // Same as byte 4 on page 2
  */
  
  //}
}

unsigned char compbuf(const unsigned char *src,unsigned char *dest)
{
    while(*src)
    {
        if(*src++ != *dest++)
            return 0;
        //src++;dest++;
        //len--;
    }
    return 1;
}

void errorSD(unsigned char err)
{
    /*
    insigned int dly=0;
    if(err==1){
        dly=200;
    }
    else if(err==2){
        dly=500;
    }
    else if(err==3){
        dly=500;
    }
    */
    do{
       PORTC &= ~(1<<err);
       delay_ms(500);
       PORTC = 0xFF; 
       delay_ms(500);
    }
    
    //PORTC.1=0;
    while(1);
}

unsigned long buf2num(unsigned char *buf,unsigned char len)
{
    unsigned long num=0;
    //unsigned char i;
    for(;len>0;len--)
    {
        num<<=8;
        num|=buf[len-1];        
    }
    return num;
}


void testWrite()
{
  unsigned char testBuffer1[PAGESIZE];      // Declares variables for testing
  unsigned char testBuffer2[PAGESIZE];      // Note. Each array uses PAGESIZE bytes of
                                            // code stack
  
  
  static unsigned char testChar; // A warning will come saying that this var is set but never used. Ignore it.
  int index;

  //DDRC=0xFF;
  //PORTC=0xFF;
  //DDRC=0x00;
  //PORTC=0x00;
  //MCUCR |= (1<<IVSEL);
                        // Move interrupt vectors to boot
  //RecoverFlash();
  
  //dospm();
  
  for(index=0; index<PAGESIZE; index++){
    testBuffer1[index]=(unsigned char)index; // Fills testBuffer1 with values 0,1,2..255
  }
  PORTC.4=0;
  //for(;;){
  if(  WriteFlashPage(0x1EF00, testBuffer1))//;     // Writes testbuffer1 to Flash page 2
    PORTC.5=0;                                          // Function returns TRUE
  if(  ReadFlashPage(0x1EF00, testBuffer2))//;      // Reads back Flash page 2 to TestBuffer2
    PORTC.6=0;                                          // Function returns TRUE
  if(  WriteFlashByte(0x1EF04, 0x38))//;            // Writes 0x38 to byte address 0x204
    PORTC.5=1;                                          // Same as byte 4 on page 2
  testChar = ReadFlashByte(0x1EF04);        // Reads back value from address 0x204
  
  if(testChar==0x38)
  {
    while(1)
    {
      PORTC.6=0;
      delay_ms(500);
      PORTC.6=1;
      delay_ms(500);;
    }
  }  
}
